package middleware

import (
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"time"

	"github.com/charmbracelet/ssh"
	"github.com/charmbracelet/wish"
	"github.com/hegner123/modulacms/internal/config"
	"github.com/hegner123/modulacms/internal/db"
	"github.com/hegner123/modulacms/internal/utility"
)

// SSHPublicKeyAuth creates a Wish middleware that authenticates users via SSH public keys.
// It validates the key against the database and stores the authenticated user in the SSH context.
func SSHPublicKeyAuth(c *config.Config) wish.Middleware {
	return func(sh ssh.Handler) ssh.Handler {
		return func(s ssh.Session) {
			// If user is already authenticated, continue
			if s.Context().Value("user_id") != nil {
				sh(s)
				return
			}

			sh(s)
		}
	}
}

// PublicKeyHandler is the actual SSH public key authentication callback.
// This is used by Wish's WithPublicKeyAuth option.
func PublicKeyHandler(c *config.Config) func(ssh.Context, ssh.PublicKey) bool {
	return func(ctx ssh.Context, key ssh.PublicKey) bool {
		// Generate fingerprint from the public key
		fingerprint := FingerprintSHA256(key)

		utility.DefaultLogger.Info("SSH auth attempt with fingerprint: %s", fingerprint)

		// Look up user by SSH key fingerprint
		dbc := db.ConfigDB(*c)
		user, err := dbc.GetUserBySSHFingerprint(fingerprint)

		if err != nil {
			// Key not registered in database - allow connection for provisioning
			utility.DefaultLogger.Info("SSH key not registered, will provision new user. Fingerprint: %s", fingerprint)

			// Store provisioning info in context
			ctx.SetValue("needs_provisioning", true)
			ctx.SetValue("ssh_fingerprint", fingerprint)
			ctx.SetValue("ssh_key_type", key.Type())
			ctx.SetValue("ssh_public_key", string(key.Marshal()))
			ctx.SetValue("authenticated", false)

			return true // Allow connection for user creation
		}

		// User found - update last used timestamp
		sshKey, err := dbc.GetUserSshKeyByFingerprint(fingerprint)
		if err == nil && sshKey != nil {
			lastUsed := time.Now().Format(time.RFC3339)
			_ = dbc.UpdateUserSshKeyLastUsed(sshKey.SshKeyID, lastUsed)
		}

		// Store user in SSH context for downstream handlers
		ctx.SetValue("user_id", user.UserID)
		ctx.SetValue("user", user)
		ctx.SetValue("authenticated", true)
		ctx.SetValue("needs_provisioning", false)

		utility.DefaultLogger.Info("SSH authentication successful for user: %s (user_id: %d)", user.Email, user.UserID)
		return true
	}
}

// FingerprintSHA256 generates a SHA256 fingerprint from an SSH public key.
// This matches the format used by modern SSH clients (SHA256:...).
func FingerprintSHA256(key ssh.PublicKey) string {
	hash := sha256.Sum256(key.Marshal())
	b64hash := base64.StdEncoding.EncodeToString(hash[:])
	return fmt.Sprintf("SHA256:%s", b64hash)
}

// ParseSSHPublicKey parses an SSH public key string (e.g., from authorized_keys format)
// and returns the key type and fingerprint.
func ParseSSHPublicKey(publicKeyStr string) (keyType string, fingerprint string, err error) {
	pubKey, _, _, _, err := ssh.ParseAuthorizedKey([]byte(publicKeyStr))
	if err != nil {
		return "", "", fmt.Errorf("failed to parse SSH public key: %w", err)
	}

	keyType = pubKey.Type()
	fingerprint = FingerprintSHA256(pubKey)

	return keyType, fingerprint, nil
}
