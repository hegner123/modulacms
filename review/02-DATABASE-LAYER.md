# Database Layer Review

## Schema Design: Strong

30 numbered schema directories, each containing 6 files (DDL + queries for SQLite, MySQL, PostgreSQL). Well-normalized. Proper foreign keys with appropriate ON DELETE policies (CASCADE, SET NULL, RESTRICT). ULID primary keys with length constraints. Composite indexes on junction tables. Content tree uses sibling pointers for O(1) navigation and reordering.

### What Is Good

**Schema organization** is excellent. Numbered directories create a clear creation order. Each directory is self-contained with all three SQL dialects. The `sql/schema/` directory is the definitive source of truth, and sqlc generates Go code from it.

**Content tree design** using `parent_id`, `first_child_id`, `next_sibling_id`, `prev_sibling_id` is a smart choice. It enables O(1) insertion, deletion, and reordering without touching other rows. Most CMS systems use `sort_order` integers that require renumbering.

**Change events table** has proper indexes: `(table_name, record_id)` for entity history, `hlc_timestamp` for distributed ordering, `node_id` for multi-node replication, `user_id` for user activity. The schema is ready for distributed deployment even though the app currently runs single-node.

**The audited command pattern** wraps mutations and audit records in a single transaction. If audit recording fails, the mutation rolls back. Before-hooks can abort operations. After-hooks fire asynchronously. This is a solid foundation for compliance.

### What Needs Attention

**Missing indexes on frequently-queried foreign keys:**
- `content_fields.content_data_id` - no index, but filtered in most content queries
- `content_fields.field_id` - no index
- These will cause full table scans on large datasets

**Nullable author_id** on `content_data` and `datatypes` tables. All content should have a creator. This forces defensive NULL checks throughout the application code for a field that should logically never be NULL.

**Timestamp column naming** (resolved): All entity tables now use `date_created`/`date_modified`. Domain-specific timestamps (`expires_at`, `issued_at`, `wall_timestamp`, `synced_at`, `last_access`, `token_expires_at`) remain as-is since they describe specific events rather than generic record lifecycle.

**N+1 query risks**: `GetContentFieldsByRoute` returns content fields without loading field definitions. No batch fetch methods like `GetFieldsByIDs`. Complex tree queries join 5 tables without EXPLAIN analysis.

### The Type Conversion Layer

`convert.go` has ~36 conversion functions across 359 lines. This is necessary given SQLite's int64 vs MySQL's int32 width differences and the custom Nullable types. It's focused and correct. The sqlc.yml type overrides (~399 column overrides) ensure the generated code uses the right branded types from the start.

### Test Coverage

69 test files, ~58,000 lines. Comprehensive coverage of CRUD operations, pagination, transactions, and audit trails. Table-driven tests throughout. The db package has the highest test coverage in the entire project.

### Code Generation (tools/dbgen)

The wrapper layer is now generated by `tools/dbgen/`, which produces 21 `*_gen.go` files from entity definitions in `definitions.go` and a Go template. Each generated file contains: entity struct, CreateParams/UpdateParams, MapString conversion, per-driver Map/MapCreate/MapUpdate mappers, CRUD query methods, and audited command types (Create/Update/Delete with recorder wiring).

Entities with per-driver type differences (bool vs int64 for `SystemProtected`, time format conversions, field name casing) use `SkipMappers` and `SkipAuditedCommands` flags to keep those sections hand-written in `*_custom.go` files. Eight entities use this escape hatch: Roles, Permissions, Tokens, Sessions, MediaDimensions, UserOauth, Routes, and AdminRoutes.

The generator supports `--verify` mode for CI to ensure committed files match regenerated output, `--entity` for single-entity regeneration, and `--dry-run` for previewing.

## Recommendations

1. Add indexes on `content_fields(content_data_id)` and `content_fields(field_id)`
2. Make `author_id` NOT NULL on content_data and datatypes (with migration)
3. Standardize timestamp column names across all tables
4. Add batch fetch methods (e.g., `GetFieldsByIDs([]FieldID)`) to reduce N+1 queries
