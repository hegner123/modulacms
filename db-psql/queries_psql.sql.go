// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries_psql.sql

package mdbp

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const checkAdminParentExists = `-- name: CheckAdminParentExists :one
SELECT EXISTS(SELECT 1 FROM admin_datatypes WHERE admin_datatype_id = $1)
`

func (q *Queries) CheckAdminParentExists(ctx context.Context, adminDatatypeID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAdminParentExists, adminDatatypeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAdminRouteExists = `-- name: CheckAdminRouteExists :one
SELECT EXISTS(SELECT 1 FROM admin_routes WHERE admin_route_id = $1)
`

func (q *Queries) CheckAdminRouteExists(ctx context.Context, adminRouteID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAdminRouteExists, adminRouteID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAuthorExists = `-- name: CheckAuthorExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE username = $1)
`

func (q *Queries) CheckAuthorExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAuthorExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAuthorIdExists = `-- name: CheckAuthorIdExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE user_id = $1)
`

func (q *Queries) CheckAuthorIdExists(ctx context.Context, userID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAuthorIdExists, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkParentExists = `-- name: CheckParentExists :one
SELECT EXISTS(SELECT 1 FROM datatypes WHERE datatype_id = $1)
`

func (q *Queries) CheckParentExists(ctx context.Context, datatypeID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkParentExists, datatypeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkRouteExists = `-- name: CheckRouteExists :one
SELECT EXISTS(SELECT 1 FROM routes WHERE route_id = $1)
`

func (q *Queries) CheckRouteExists(ctx context.Context, routeID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkRouteExists, routeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAdminContentData = `-- name: CountAdminContentData :one
SELECT COUNT(*)
FROM admin_content_data
`

func (q *Queries) CountAdminContentData(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminContentData)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminContentField = `-- name: CountAdminContentField :one
SELECT COUNT(*)
FROM admin_content_fields
`

func (q *Queries) CountAdminContentField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminContentField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminDatatype = `-- name: CountAdminDatatype :one
SELECT COUNT(*)
FROM admin_datatypes
`

func (q *Queries) CountAdminDatatype(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminDatatype)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminField = `-- name: CountAdminField :one
SELECT COUNT(*)
FROM admin_fields
`

func (q *Queries) CountAdminField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminroute = `-- name: CountAdminroute :one
SELECT COUNT(*)
FROM admin_routes
`

func (q *Queries) CountAdminroute(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminroute)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContentData = `-- name: CountContentData :one
SELECT COUNT(*)
FROM content_data
`

func (q *Queries) CountContentData(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContentData)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContentField = `-- name: CountContentField :one
SELECT COUNT(*)
FROM content_fields
`

func (q *Queries) CountContentField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContentField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDatatype = `-- name: CountDatatype :one
SELECT COUNT(*)
FROM datatypes
`

func (q *Queries) CountDatatype(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDatatype)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countField = `-- name: CountField :one
SELECT COUNT(*)
FROM fields
`

func (q *Queries) CountField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*)
FROM media
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMediaDimension = `-- name: CountMediaDimension :one
SELECT COUNT(*)
FROM media_dimensions
`

func (q *Queries) CountMediaDimension(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMediaDimension)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPermission = `-- name: CountPermission :one
SELECT COUNT(*)
FROM permissions
`

func (q *Queries) CountPermission(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPermission)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRole = `-- name: CountRole :one
SELECT COUNT(*)
FROM roles
`

func (q *Queries) CountRole(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRole)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRoute = `-- name: CountRoute :one
SELECT COUNT(*)
FROM routes
`

func (q *Queries) CountRoute(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRoute)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSession = `-- name: CountSession :one
SELECT COUNT(*)
FROM sessions
`

func (q *Queries) CountSession(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSession)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTables = `-- name: CountTables :one
SELECT COUNT(*)
FROM tables
`

func (q *Queries) CountTables(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTables)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countToken = `-- name: CountToken :one
SELECT COUNT(*)
FROM tokens
`

func (q *Queries) CountToken(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countToken)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUser = `-- name: CountUser :one
SELECT COUNT(*)
FROM users
`

func (q *Queries) CountUser(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUser)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserOauths = `-- name: CountUserOauths :one
SELECT COUNT(*)
FROM user_oauth
`

func (q *Queries) CountUserOauths(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserOauths)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAdminContentData = `-- name: CreateAdminContentData :one
INSERT INTO admin_content_data (
    admin_route_id,
    admin_datatype_id,
    history,
    date_created,
    date_modified
    ) VALUES (
$1,$2,$3,$4,$5
    ) RETURNING admin_content_data_id, admin_route_id, admin_datatype_id, date_created, date_modified, history
`

type CreateAdminContentDataParams struct {
	AdminRouteID    sql.NullInt32  `json:"admin_route_id"`
	AdminDatatypeID sql.NullInt32  `json:"admin_datatype_id"`
	History         sql.NullString `json:"history"`
	DateCreated     sql.NullTime   `json:"date_created"`
	DateModified    sql.NullTime   `json:"date_modified"`
}

func (q *Queries) CreateAdminContentData(ctx context.Context, arg CreateAdminContentDataParams) (AdminContentData, error) {
	row := q.db.QueryRowContext(ctx, createAdminContentData,
		arg.AdminRouteID,
		arg.AdminDatatypeID,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
	)
	var i AdminContentData
	err := row.Scan(
		&i.AdminContentDataID,
		&i.AdminRouteID,
		&i.AdminDatatypeID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createAdminContentDataTable = `-- name: CreateAdminContentDataTable :exec
CREATE TABLE IF NOT EXISTS admin_content_data (
    admin_content_data_id SERIAL PRIMARY KEY,
    admin_route_id INTEGER,
    admin_datatype_id INTEGER,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT DEFAULT NULL,
    CONSTRAINT fk_admin_routes FOREIGN KEY (admin_route_id)
        REFERENCES admin_routes(route_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_admin_datatypes FOREIGN KEY (admin_datatype_id)
        REFERENCES admin_datatypes(admin_datatype_id)
        ON UPDATE CASCADE ON DELETE SET NULL
)
`

func (q *Queries) CreateAdminContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminContentDataTable)
	return err
}

const createAdminContentField = `-- name: CreateAdminContentField :one
INSERT INTO admin_content_fields (
    admin_content_field_id,
    admin_route_id,
    admin_content_data_id,
    admin_field_id,
    admin_field_value, 
    history,
    date_created, 
    date_modified
    ) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8
    ) RETURNING admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, date_created, date_modified, history
`

type CreateAdminContentFieldParams struct {
	AdminContentFieldID int32          `json:"admin_content_field_id"`
	AdminRouteID        sql.NullInt32  `json:"admin_route_id"`
	AdminContentDataID  int32          `json:"admin_content_data_id"`
	AdminFieldID        int32          `json:"admin_field_id"`
	AdminFieldValue     string         `json:"admin_field_value"`
	History             sql.NullString `json:"history"`
	DateCreated         sql.NullTime   `json:"date_created"`
	DateModified        sql.NullTime   `json:"date_modified"`
}

func (q *Queries) CreateAdminContentField(ctx context.Context, arg CreateAdminContentFieldParams) (AdminContentFields, error) {
	row := q.db.QueryRowContext(ctx, createAdminContentField,
		arg.AdminContentFieldID,
		arg.AdminRouteID,
		arg.AdminContentDataID,
		arg.AdminFieldID,
		arg.AdminFieldValue,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
	)
	var i AdminContentFields
	err := row.Scan(
		&i.AdminContentFieldID,
		&i.AdminRouteID,
		&i.AdminContentDataID,
		&i.AdminFieldID,
		&i.AdminFieldValue,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createAdminContentFieldTable = `-- name: CreateAdminContentFieldTable :exec
CREATE TABLE IF NOT EXISTS admin_content_fields (
    admin_content_field_id SERIAL PRIMARY KEY,
    admin_route_id INTEGER,
    admin_content_data_id INTEGER NOT NULL,
    admin_field_id INTEGER NOT NULL,
    admin_field_value TEXT NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT,
    CONSTRAINT fk_admin_route_id FOREIGN KEY (admin_route_id)
        REFERENCES admin_routes(admin_route_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_admin_content_data FOREIGN KEY (admin_content_data_id)
        REFERENCES admin_content_data(admin_content_data_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_fields FOREIGN KEY (admin_field_id)
        REFERENCES admin_fields(admin_field_id)
        ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateAdminContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminContentFieldTable)
	return err
}

const createAdminDatatype = `-- name: CreateAdminDatatype :one
INSERT INTO admin_datatypes (
    parent_id,
    label,
    type,
    author,
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING admin_datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history
`

type CreateAdminDatatypeParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Type         string         `json:"type"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateAdminDatatype(ctx context.Context, arg CreateAdminDatatypeParams) (AdminDatatypes, error) {
	row := q.db.QueryRowContext(ctx, createAdminDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	var i AdminDatatypes
	err := row.Scan(
		&i.AdminDatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createAdminDatatypeTable = `-- name: CreateAdminDatatypeTable :exec
CREATE TABLE IF NOT EXISTS admin_datatypes (
    admin_datatype_id SERIAL PRIMARY KEY,
    parent_id INT DEFAULT NULL,
    label TEXT NOT NULL,
    type TEXT NOT NULL,
    author TEXT NOT NULL,
    author_id INT NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT,
    CONSTRAINT fk_parent_id FOREIGN KEY (parent_id)
        REFERENCES admin_datatypes(admin_datatype_id)
        ON UPDATE CASCADE
        ON DELETE SET DEFAULT,
    CONSTRAINT fk_author FOREIGN KEY (author)
        REFERENCES users(username)
        ON UPDATE CASCADE
        ON DELETE SET DEFAULT,
    CONSTRAINT fk_author_id FOREIGN KEY (author_id)
        REFERENCES users(user_id)
        ON UPDATE CASCADE
        ON DELETE SET DEFAULT
)
`

func (q *Queries) CreateAdminDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminDatatypeTable)
	return err
}

const createAdminField = `-- name: CreateAdminField :one
INSERT INTO admin_fields (    
    parent_id,
    label,
    data,
    type,
    author,
    author_id,
    date_created,
    date_modified,
    history
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING admin_field_id, parent_id, label, data, type, author, author_id, date_created, date_modified, history
`

type CreateAdminFieldParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateAdminField(ctx context.Context, arg CreateAdminFieldParams) (AdminFields, error) {
	row := q.db.QueryRowContext(ctx, createAdminField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Type,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	var i AdminFields
	err := row.Scan(
		&i.AdminFieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createAdminFieldTable = `-- name: CreateAdminFieldTable :exec
CREATE TABLE IF NOT EXISTS admin_fields (
    admin_field_id SERIAL PRIMARY KEY,
    parent_id INTEGER DEFAULT NULL
        REFERENCES admin_datatypes
            ON UPDATE CASCADE ON DELETE SET DEFAULT,
    label TEXT NOT NULL DEFAULT 'unlabeled',
    data TEXT NOT NULL DEFAULT '',
    type TEXT NOT NULL DEFAULT 'text',
    author TEXT NOT NULL DEFAULT 'system'
        REFERENCES users(username)
            ON UPDATE CASCADE ON DELETE SET DEFAULT,
    author_id INTEGER NOT NULL DEFAULT 1
        REFERENCES users(user_id)
            ON UPDATE CASCADE ON DELETE SET DEFAULT,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT
)
`

func (q *Queries) CreateAdminFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminFieldTable)
	return err
}

const createAdminRoute = `-- name: CreateAdminRoute :one
INSERT INTO admin_routes (
author,
author_id,
slug,
title,
status,
date_created,
date_modified,
history
    ) VALUES (
$1,$2,$3,$4,$5,$6,$7,$8
    ) RETURNING admin_route_id, slug, title, status, author, author_id, date_created, date_modified, history
`

type CreateAdminRouteParams struct {
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	Status       int32          `json:"status"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateAdminRoute(ctx context.Context, arg CreateAdminRouteParams) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, createAdminRoute,
		arg.Author,
		arg.AuthorID,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createAdminRouteTable = `-- name: CreateAdminRouteTable :exec
CREATE TABLE IF NOT EXISTS admin_routes (
    admin_route_id SERIAL PRIMARY KEY,
    slug TEXT NOT NULL UNIQUE,
    title TEXT NOT NULL,
    status INTEGER NOT NULL,
    author TEXT NOT NULL DEFAULT 'system'
        REFERENCES users(username)
            ON UPDATE CASCADE ON DELETE SET DEFAULT,
    author_id INTEGER NOT NULL DEFAULT 1
        REFERENCES users(user_id)
            ON UPDATE CASCADE ON DELETE SET DEFAULT,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT
)
`

func (q *Queries) CreateAdminRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminRouteTable)
	return err
}

const createContentData = `-- name: CreateContentData :one
INSERT INTO content_data (
    route_id,
    datatype_id,
    history,
    date_created,
    date_modified
    ) VALUES (
$1,$2,$3,$4,$5
    ) RETURNING content_data_id, route_id, datatype_id, date_created, date_modified, history
`

type CreateContentDataParams struct {
	RouteID      sql.NullInt32  `json:"route_id"`
	DatatypeID   sql.NullInt32  `json:"datatype_id"`
	History      sql.NullString `json:"history"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
}

func (q *Queries) CreateContentData(ctx context.Context, arg CreateContentDataParams) (ContentData, error) {
	row := q.db.QueryRowContext(ctx, createContentData,
		arg.RouteID,
		arg.DatatypeID,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
	)
	var i ContentData
	err := row.Scan(
		&i.ContentDataID,
		&i.RouteID,
		&i.DatatypeID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createContentDataTable = `-- name: CreateContentDataTable :exec
CREATE TABLE IF NOT EXISTS content_data (
    content_data_id SERIAL PRIMARY KEY,
    route_id INTEGER,
    datatype_id INTEGER,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT DEFAULT NULL,
    CONSTRAINT fk_routes FOREIGN KEY (route_id)
        REFERENCES routes(route_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_datatypes FOREIGN KEY (datatype_id)
        REFERENCES datatypes(datatype_id)
        ON UPDATE CASCADE ON DELETE SET NULL
)
`

func (q *Queries) CreateContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createContentDataTable)
	return err
}

const createContentField = `-- name: CreateContentField :one
INSERT INTO content_fields (
    content_field_id,
    route_id,
    content_data_id,
    field_id,
    field_value, 
    history,
    date_created, 
    date_modified
    ) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8
    ) RETURNING content_field_id, route_id, content_data_id, field_id, field_value, date_created, date_modified, history
`

type CreateContentFieldParams struct {
	ContentFieldID int32          `json:"content_field_id"`
	RouteID        sql.NullInt32  `json:"route_id"`
	ContentDataID  int32          `json:"content_data_id"`
	FieldID        int32          `json:"field_id"`
	FieldValue     string         `json:"field_value"`
	History        sql.NullString `json:"history"`
	DateCreated    sql.NullTime   `json:"date_created"`
	DateModified   sql.NullTime   `json:"date_modified"`
}

func (q *Queries) CreateContentField(ctx context.Context, arg CreateContentFieldParams) (ContentFields, error) {
	row := q.db.QueryRowContext(ctx, createContentField,
		arg.ContentFieldID,
		arg.RouteID,
		arg.ContentDataID,
		arg.FieldID,
		arg.FieldValue,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
	)
	var i ContentFields
	err := row.Scan(
		&i.ContentFieldID,
		&i.RouteID,
		&i.ContentDataID,
		&i.FieldID,
		&i.FieldValue,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createContentFieldTable = `-- name: CreateContentFieldTable :exec
CREATE TABLE IF NOT EXISTS content_fields (
    content_field_id SERIAL PRIMARY KEY,
    route_id INTEGER,
    content_data_id INTEGER NOT NULL,
    field_id INTEGER NOT NULL,
    field_value TEXT NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT,
    CONSTRAINT fk_route_id FOREIGN KEY (route_id)
        REFERENCES routes(route_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_content_data FOREIGN KEY (content_data_id)
        REFERENCES content_data(content_data_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_fields FOREIGN KEY (admin_field_id)
        REFERENCES admin_fields(admin_field_id)
        ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createContentFieldTable)
	return err
}

const createDatatype = `-- name: CreateDatatype :one
INSERT INTO datatypes (    
    parent_id,
    label,
    type,
    author,
    author_id,
    history,
    date_created,
    date_modified
    ) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8
    ) RETURNING datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history
`

type CreateDatatypeParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Type         string         `json:"type"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	History      sql.NullString `json:"history"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
}

func (q *Queries) CreateDatatype(ctx context.Context, arg CreateDatatypeParams) (Datatypes, error) {
	row := q.db.QueryRowContext(ctx, createDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.Author,
		arg.AuthorID,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
	)
	var i Datatypes
	err := row.Scan(
		&i.DatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createDatatypeTable = `-- name: CreateDatatypeTable :exec
CREATE TABLE IF NOT EXISTS datatypes (
    datatype_id SERIAL PRIMARY KEY,
    
    parent_id INTEGER DEFAULT NULL,
    label TEXT NOT NULL,
    type TEXT NOT NULL,
    author TEXT NOT NULL DEFAULT 'system',
    author_id INTEGER NOT NULL DEFAULT 1,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT,
    CONSTRAINT fk_datatypes_parent FOREIGN KEY (parent_id)
        REFERENCES datatypes(datatype_id)
        ON UPDATE CASCADE ON DELETE SET DEFAULT,
    CONSTRAINT fk_users_author FOREIGN KEY (author)
        REFERENCES users(username)
        ON UPDATE CASCADE ON DELETE SET DEFAULT,
    CONSTRAINT fk_users_author_id FOREIGN KEY (author_id)
        REFERENCES users(user_id)
        ON UPDATE CASCADE ON DELETE SET DEFAULT
)
`

func (q *Queries) CreateDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createDatatypeTable)
	return err
}

const createField = `-- name: CreateField :one
INSERT INTO fields  (    
    parent_id,
    label,
    data,
    type,
    author,
    author_id,
    history,
    date_created,
    date_modified
    ) VALUES (
$1,$2,$3,$4,$5,$6,$7,$8,$9
    ) RETURNING field_id, parent_id, label, data, type, author, author_id, date_created, date_modified, history
`

type CreateFieldParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	History      sql.NullString `json:"history"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
}

func (q *Queries) CreateField(ctx context.Context, arg CreateFieldParams) (Fields, error) {
	row := q.db.QueryRowContext(ctx, createField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Type,
		arg.Author,
		arg.AuthorID,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
	)
	var i Fields
	err := row.Scan(
		&i.FieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createFieldTable = `-- name: CreateFieldTable :exec
CREATE TABLE IF NOT EXISTS fields (
    field_id SERIAL PRIMARY KEY,
    
    parent_id INTEGER DEFAULT NULL,
    label TEXT NOT NULL DEFAULT 'unlabeled',
    data TEXT NOT NULL,
    type TEXT NOT NULL,
    author TEXT NOT NULL DEFAULT 'system',
    author_id INTEGER NOT NULL DEFAULT 1,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    history TEXT,
    CONSTRAINT fk_datatypes FOREIGN KEY (parent_id)
        REFERENCES datatypes(datatype_id)
        ON UPDATE CASCADE ON DELETE SET DEFAULT,
    CONSTRAINT fk_users_author FOREIGN KEY (author)
        REFERENCES users(username)
        ON UPDATE CASCADE ON DELETE SET DEFAULT,
    CONSTRAINT fk_users_author_id FOREIGN KEY (author_id)
        REFERENCES users(user_id)
        ON UPDATE CASCADE ON DELETE SET DEFAULT
)
`

func (q *Queries) CreateFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createFieldTable)
	return err
}

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (
    name,
    display_name,
    alt,
    caption,
    description,
    class,
    url,
    mimetype,
    dimensions,
    srcset,
    author,
    author_id,
    date_created,
    date_modified
) VALUES (
 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14
)
RETURNING media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author, author_id, date_created, date_modified
`

type CreateMediaParams struct {
	Name         sql.NullString `json:"name"`
	DisplayName  sql.NullString `json:"display_name"`
	Alt          sql.NullString `json:"alt"`
	Caption      sql.NullString `json:"caption"`
	Description  sql.NullString `json:"description"`
	Class        sql.NullString `json:"class"`
	Url          sql.NullString `json:"url"`
	Mimetype     sql.NullString `json:"mimetype"`
	Dimensions   sql.NullString `json:"dimensions"`
	Srcset       sql.NullString `json:"srcset"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Media, error) {
	row := q.db.QueryRowContext(ctx, createMedia,
		arg.Name,
		arg.DisplayName,
		arg.Alt,
		arg.Caption,
		arg.Description,
		arg.Class,
		arg.Url,
		arg.Mimetype,
		arg.Dimensions,
		arg.Srcset,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.Url,
		&i.Srcset,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createMediaDimension = `-- name: CreateMediaDimension :one
INSERT INTO media_dimensions(
    label,
    width,
    height,
    aspect_ratio
) VALUES (
  $1, $2, $3, $4
)
RETURNING md_id, label, width, height, aspect_ratio
`

type CreateMediaDimensionParams struct {
	Label       sql.NullString `json:"label"`
	Width       sql.NullInt32  `json:"width"`
	Height      sql.NullInt32  `json:"height"`
	AspectRatio sql.NullString `json:"aspect_ratio"`
}

func (q *Queries) CreateMediaDimension(ctx context.Context, arg CreateMediaDimensionParams) (MediaDimensions, error) {
	row := q.db.QueryRowContext(ctx, createMediaDimension,
		arg.Label,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
	)
	var i MediaDimensions
	err := row.Scan(
		&i.MdID,
		&i.Label,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
	)
	return i, err
}

const createMediaDimensionTable = `-- name: CreateMediaDimensionTable :exec
CREATE TABLE IF NOT EXISTS media_dimensions (
    md_id SERIAL PRIMARY KEY,
    label TEXT UNIQUE,
    width INTEGER,
    height INTEGER,
    aspect_ratio TEXT
)
`

func (q *Queries) CreateMediaDimensionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createMediaDimensionTable)
	return err
}

const createMediaTable = `-- name: CreateMediaTable :exec
CREATE TABLE IF NOT EXISTS media (
    media_id SERIAL PRIMARY KEY,
    name TEXT,
    display_name TEXT,
    alt TEXT,
    caption TEXT,
    description TEXT,
    class TEXT,
    mimetype TEXT,
    dimensions TEXT,
    url TEXT UNIQUE,
    srcset TEXT, 
    author TEXT NOT NULL DEFAULT 'system',
    author_id INTEGER NOT NULL DEFAULT 1,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_users_author FOREIGN KEY (author)
        REFERENCES users(username)
        ON UPDATE CASCADE ON DELETE SET DEFAULT,
    CONSTRAINT fk_users_author_id FOREIGN KEY (author_id)
        REFERENCES users(user_id)
        ON UPDATE CASCADE ON DELETE SET DEFAULT
)
`

func (q *Queries) CreateMediaTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createMediaTable)
	return err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions(
    table_id,
    mode,
    label
) VALUES (
  $1,$2,$3
)
RETURNING permission_id, table_id, mode, label
`

type CreatePermissionParams struct {
	TableID int32  `json:"table_id"`
	Mode    int32  `json:"mode"`
	Label   string `json:"label"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permissions, error) {
	row := q.db.QueryRowContext(ctx, createPermission, arg.TableID, arg.Mode, arg.Label)
	var i Permissions
	err := row.Scan(
		&i.PermissionID,
		&i.TableID,
		&i.Mode,
		&i.Label,
	)
	return i, err
}

const createPermissionTable = `-- name: CreatePermissionTable :exec
CREATE TABLE IF NOT EXISTS permissions (
    permission_id SERIAL PRIMARY KEY,
    table_id INTEGER NOT NULL,
    mode INTEGER NOT NULL,
    label TEXT NOT NULL
)
`

func (q *Queries) CreatePermissionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createPermissionTable)
	return err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (
    label,
    permissions
) VALUES (
    $1, $2
)
RETURNING role_id, label, permissions
`

type CreateRoleParams struct {
	Label       string                `json:"label"`
	Permissions pqtype.NullRawMessage `json:"permissions"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Roles, error) {
	row := q.db.QueryRowContext(ctx, createRole, arg.Label, arg.Permissions)
	var i Roles
	err := row.Scan(&i.RoleID, &i.Label, &i.Permissions)
	return i, err
}

const createRoleTable = `-- name: CreateRoleTable :exec
CREATE TABLE IF NOT EXISTS roles (
    role_id SERIAL PRIMARY KEY,
    label TEXT NOT NULL UNIQUE,
    permissions JSONB
)
`

func (q *Queries) CreateRoleTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createRoleTable)
	return err
}

const createRoute = `-- name: CreateRoute :one
INSERT INTO routes (
    slug,
    title,
    status,
    author,
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING route_id, slug, title, status, author, author_id, date_created, date_modified, history
`

type CreateRouteParams struct {
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	Status       int32          `json:"status"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  sql.NullString `json:"date_created"`
	DateModified sql.NullString `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) (Routes, error) {
	row := q.db.QueryRowContext(ctx, createRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	var i Routes
	err := row.Scan(
		&i.RouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const createRouteTable = `-- name: CreateRouteTable :exec
CREATE TABLE IF NOT EXISTS routes (
    route_id INTEGER
        PRIMARY KEY,
    slug TEXT NOT NULL
        UNIQUE,
    title TEXT NOT NULL,
    status INTEGER NOT NULL,
    author TEXT DEFAULT "system" NOT NULL
    REFERENCES users (username)
    ON UPDATE CASCADE ON DELETE SET DEFAULT,
    author_id INTEGER DEFAULT 1 NOT NULL
    REFERENCES users (user_id)
    ON UPDATE CASCADE ON DELETE SET DEFAULT,
    date_created TEXT DEFAULT CURRENT_TIMESTAMP,
    date_modified TEXT DEFAULT CURRENT_TIMESTAMP,
    history TEXT
)
`

func (q *Queries) CreateRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createRouteTable)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    user_id,
    created_at,
    expires_at,
    last_access,
    ip_address,
    user_agent,
    session_data
    ) VALUES( 
    $1,$2,$3,$4,$5,$6,$7
    ) RETURNING session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data
`

type CreateSessionParams struct {
	UserID      int32          `json:"user_id"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	ExpiresAt   sql.NullTime   `json:"expires_at"`
	LastAccess  sql.NullTime   `json:"last_access"`
	IpAddress   sql.NullString `json:"ip_address"`
	UserAgent   sql.NullString `json:"user_agent"`
	SessionData sql.NullString `json:"session_data"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Sessions, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastAccess,
		arg.IpAddress,
		arg.UserAgent,
		arg.SessionData,
	)
	var i Sessions
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccess,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionData,
	)
	return i, err
}

const createSessionTable = `-- name: CreateSessionTable :exec
CREATE TABLE sessions (
    session_id   INTEGER PRIMARY KEY, 
    user_id      INTEGER NOT NULL, 
    created_at   TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at   TIMESTAMP,
    last_access  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address   TEXT,
    user_agent   TEXT,
    session_data TEXT,
    CONSTRAINT fk_sessions_user_id FOREIGN KEY (user_id)
        REFERENCES users(user_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
)
`

func (q *Queries) CreateSessionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createSessionTable)
	return err
}

const createTable = `-- name: CreateTable :one
INSERT INTO tables (
    label
) VALUES (
    $1
)
RETURNING id, label, author_id
`

func (q *Queries) CreateTable(ctx context.Context, label sql.NullString) (Tables, error) {
	row := q.db.QueryRowContext(ctx, createTable, label)
	var i Tables
	err := row.Scan(&i.ID, &i.Label, &i.AuthorID)
	return i, err
}

const createTablesTable = `-- name: CreateTablesTable :exec
CREATE TABLE IF NOT EXISTS tables (
    id INTEGER PRIMARY KEY,
    label TEXT UNIQUE,
    author_id INTEGER DEFAULT 1 NOT NULL
        REFERENCES users (user_id)
            ON UPDATE CASCADE ON DELETE SET DEFAULT
)
`

func (q *Queries) CreateTablesTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTablesTable)
	return err
}

const createToken = `-- name: CreateToken :one
INSERT INTO tokens (
    user_id,
    token_type,
    token,
    issued_at,
    expires_at,
    revoked
    ) VALUES( 
    $1,$2,$3,$4,$5,$6
    ) RETURNING id, user_id, token_type, token, issued_at, expires_at, revoked
`

type CreateTokenParams struct {
	UserID    int32        `json:"user_id"`
	TokenType string       `json:"token_type"`
	Token     string       `json:"token"`
	IssuedAt  time.Time    `json:"issued_at"`
	ExpiresAt time.Time    `json:"expires_at"`
	Revoked   sql.NullBool `json:"revoked"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (Tokens, error) {
	row := q.db.QueryRowContext(ctx, createToken,
		arg.UserID,
		arg.TokenType,
		arg.Token,
		arg.IssuedAt,
		arg.ExpiresAt,
		arg.Revoked,
	)
	var i Tokens
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.Token,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const createTokenTable = `-- name: CreateTokenTable :exec
CREATE TABLE IF NOT EXISTS tokens (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    token_type TEXT NOT NULL,
    token TEXT NOT NULL UNIQUE,
    issued_at TIMESTAMP NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    revoked BOOLEAN DEFAULT false,
    CONSTRAINT fk_tokens_users FOREIGN KEY (user_id)
        REFERENCES users(user_id)
        ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateTokenTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTokenTable)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    date_created,
    date_modified,
    username,
    name,
    email,
    hash,
    role
) VALUES (
$1,$2,$3,$4,$5,$6,$7
)
RETURNING user_id, username, name, email, hash, role, date_created, date_modified
`

type CreateUserParams struct {
	DateCreated  sql.NullTime  `json:"date_created"`
	DateModified sql.NullTime  `json:"date_modified"`
	Username     string        `json:"username"`
	Name         string        `json:"name"`
	Email        string        `json:"email"`
	Hash         string        `json:"hash"`
	Role         sql.NullInt32 `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Users, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.DateCreated,
		arg.DateModified,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.Hash,
		arg.Role,
	)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Role,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createUserOauth = `-- name: CreateUserOauth :one
INSERT INTO user_oauth (
    user_id,
    oauth_provider,
    oauth_provider_user_id,
    access_token,
    refresh_token,
    token_expires_at,
    date_created
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
`

type CreateUserOauthParams struct {
	UserID              int32          `json:"user_id"`
	OauthProvider       string         `json:"oauth_provider"`
	OauthProviderUserID string         `json:"oauth_provider_user_id"`
	AccessToken         sql.NullString `json:"access_token"`
	RefreshToken        sql.NullString `json:"refresh_token"`
	TokenExpiresAt      sql.NullTime   `json:"token_expires_at"`
	DateCreated         sql.NullTime   `json:"date_created"`
}

func (q *Queries) CreateUserOauth(ctx context.Context, arg CreateUserOauthParams) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, createUserOauth,
		arg.UserID,
		arg.OauthProvider,
		arg.OauthProviderUserID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenExpiresAt,
		arg.DateCreated,
	)
	var i UserOauth
	err := row.Scan(
		&i.UserOauthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OauthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const createUserOauthTable = `-- name: CreateUserOauthTable :exec
CREATE TABLE IF NOT EXISTS user_oauth (
    user_oauth_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    oauth_provider VARCHAR(255) NOT NULL,        -- e.g., 'google', 'facebook'
    oauth_provider_user_id VARCHAR(255) NOT NULL,  -- Unique identifier provided by the OAuth provider
    access_token TEXT,                             -- Optional: for making API calls on behalf of the user
    refresh_token TEXT,                            -- Optional: if token refresh is required
    token_expires_at TIMESTAMP,                    -- Optional: expiry time for the access token
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
        ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateUserOauthTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUserOauthTable)
	return err
}

const createUserTable = `-- name: CreateUserTable :exec
CREATE TABLE IF NOT EXISTS users (
    user_id SERIAL PRIMARY KEY,
    username TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    email TEXT NOT NULL,
    hash TEXT NOT NULL,
    role INTEGER,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_users_role FOREIGN KEY (role)
        REFERENCES roles(role_id)
        ON UPDATE CASCADE ON DELETE SET NULL
)
`

func (q *Queries) CreateUserTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUserTable)
	return err
}

const deleteAdminContentData = `-- name: DeleteAdminContentData :exec
DELETE FROM admin_content_data
WHERE admin_content_data_id = $1
`

func (q *Queries) DeleteAdminContentData(ctx context.Context, adminContentDataID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminContentData, adminContentDataID)
	return err
}

const deleteAdminContentField = `-- name: DeleteAdminContentField :exec
DELETE FROM admin_content_fields
WHERE admin_content_field_id = $1
`

func (q *Queries) DeleteAdminContentField(ctx context.Context, adminContentFieldID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminContentField, adminContentFieldID)
	return err
}

const deleteAdminDatatype = `-- name: DeleteAdminDatatype :exec
DELETE FROM admin_datatypes
WHERE admin_datatype_id = $1
`

func (q *Queries) DeleteAdminDatatype(ctx context.Context, adminDatatypeID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminDatatype, adminDatatypeID)
	return err
}

const deleteAdminField = `-- name: DeleteAdminField :exec
DELETE FROM admin_fields
WHERE admin_field_id = $1
`

func (q *Queries) DeleteAdminField(ctx context.Context, adminFieldID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminField, adminFieldID)
	return err
}

const deleteAdminRoute = `-- name: DeleteAdminRoute :exec
DELETE FROM admin_routes
WHERE slug = $1
`

func (q *Queries) DeleteAdminRoute(ctx context.Context, slug string) error {
	_, err := q.db.ExecContext(ctx, deleteAdminRoute, slug)
	return err
}

const deleteContentData = `-- name: DeleteContentData :exec
DELETE FROM content_data
WHERE content_data_id = $1
`

func (q *Queries) DeleteContentData(ctx context.Context, contentDataID int32) error {
	_, err := q.db.ExecContext(ctx, deleteContentData, contentDataID)
	return err
}

const deleteContentField = `-- name: DeleteContentField :exec
DELETE FROM content_fields
WHERE content_field_id = $1
`

func (q *Queries) DeleteContentField(ctx context.Context, contentFieldID int32) error {
	_, err := q.db.ExecContext(ctx, deleteContentField, contentFieldID)
	return err
}

const deleteDatatype = `-- name: DeleteDatatype :exec
DELETE FROM datatypes
WHERE datatype_id = $1
`

func (q *Queries) DeleteDatatype(ctx context.Context, datatypeID int32) error {
	_, err := q.db.ExecContext(ctx, deleteDatatype, datatypeID)
	return err
}

const deleteField = `-- name: DeleteField :exec
DELETE FROM fields 
WHERE field_id = $1
`

func (q *Queries) DeleteField(ctx context.Context, fieldID int32) error {
	_, err := q.db.ExecContext(ctx, deleteField, fieldID)
	return err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media
WHERE media_id = $1
`

func (q *Queries) DeleteMedia(ctx context.Context, mediaID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMedia, mediaID)
	return err
}

const deleteMediaDimension = `-- name: DeleteMediaDimension :exec
DELETE FROM media_dimensions
WHERE md_id = $1
`

func (q *Queries) DeleteMediaDimension(ctx context.Context, mdID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMediaDimension, mdID)
	return err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions 
WHERE permission_id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, permissionID int32) error {
	_, err := q.db.ExecContext(ctx, deletePermission, permissionID)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE role_id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, roleID int32) error {
	_, err := q.db.ExecContext(ctx, deleteRole, roleID)
	return err
}

const deleteRoute = `-- name: DeleteRoute :exec
DELETE FROM routes
WHERE slug = $1
`

func (q *Queries) DeleteRoute(ctx context.Context, slug string) error {
	_, err := q.db.ExecContext(ctx, deleteRoute, slug)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE session_id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, sessionID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSession, sessionID)
	return err
}

const deleteTable = `-- name: DeleteTable :exec
DELETE FROM tables
WHERE id = $1
`

func (q *Queries) DeleteTable(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteTable, id)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM tokens
WHERE id = $1
`

func (q *Queries) DeleteToken(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteToken, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUser, userID)
	return err
}

const deleteUserOauth = `-- name: DeleteUserOauth :exec
DELETE FROM user_oauth
WHERE user_oauth_id = $1
`

func (q *Queries) DeleteUserOauth(ctx context.Context, userOauthID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserOauth, userOauthID)
	return err
}

const getAdminContentData = `-- name: GetAdminContentData :one
SELECT admin_content_data_id, admin_route_id, admin_datatype_id, date_created, date_modified, history FROM admin_content_data
WHERE admin_content_data_id = $1 LIMIT 1
`

func (q *Queries) GetAdminContentData(ctx context.Context, adminContentDataID int32) (AdminContentData, error) {
	row := q.db.QueryRowContext(ctx, getAdminContentData, adminContentDataID)
	var i AdminContentData
	err := row.Scan(
		&i.AdminContentDataID,
		&i.AdminRouteID,
		&i.AdminDatatypeID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminContentField = `-- name: GetAdminContentField :one
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, date_created, date_modified, history FROM admin_content_fields
WHERE admin_content_field_id = $1 LIMIT 1
`

func (q *Queries) GetAdminContentField(ctx context.Context, adminContentFieldID int32) (AdminContentFields, error) {
	row := q.db.QueryRowContext(ctx, getAdminContentField, adminContentFieldID)
	var i AdminContentFields
	err := row.Scan(
		&i.AdminContentFieldID,
		&i.AdminRouteID,
		&i.AdminContentDataID,
		&i.AdminFieldID,
		&i.AdminFieldValue,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminDatatype = `-- name: GetAdminDatatype :one
SELECT admin_datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history FROM admin_datatypes
WHERE admin_datatype_id = $1
LIMIT 1
`

func (q *Queries) GetAdminDatatype(ctx context.Context, adminDatatypeID int32) (AdminDatatypes, error) {
	row := q.db.QueryRowContext(ctx, getAdminDatatype, adminDatatypeID)
	var i AdminDatatypes
	err := row.Scan(
		&i.AdminDatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminDatatypeId = `-- name: GetAdminDatatypeId :one
SELECT admin_datatype_id FROM admin_datatypes
WHERE admin_datatype_id = $1
LIMIT 1
`

func (q *Queries) GetAdminDatatypeId(ctx context.Context, adminDatatypeID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getAdminDatatypeId, adminDatatypeID)
	var admin_datatype_id int32
	err := row.Scan(&admin_datatype_id)
	return admin_datatype_id, err
}

const getAdminField = `-- name: GetAdminField :one
SELECT admin_field_id, parent_id, label, data, type, author, author_id, date_created, date_modified, history
FROM admin_fields
WHERE admin_field_id = $1
LIMIT 1
`

func (q *Queries) GetAdminField(ctx context.Context, adminFieldID int32) (AdminFields, error) {
	row := q.db.QueryRowContext(ctx, getAdminField, adminFieldID)
	var i AdminFields
	err := row.Scan(
		&i.AdminFieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminFieldId = `-- name: GetAdminFieldId :one
SELECT admin_field_id
FROM admin_fields
WHERE admin_field_id = $1
LIMIT 1
`

func (q *Queries) GetAdminFieldId(ctx context.Context, adminFieldID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getAdminFieldId, adminFieldID)
	var admin_field_id int32
	err := row.Scan(&admin_field_id)
	return admin_field_id, err
}

const getAdminRouteById = `-- name: GetAdminRouteById :one
SELECT admin_route_id, slug, title, status, author, author_id, date_created, date_modified, history FROM admin_routes
WHERE admin_route_id = $1 LIMIT 1
`

func (q *Queries) GetAdminRouteById(ctx context.Context, adminRouteID int32) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, getAdminRouteById, adminRouteID)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminRouteBySlug = `-- name: GetAdminRouteBySlug :one
SELECT admin_route_id, slug, title, status, author, author_id, date_created, date_modified, history FROM admin_routes
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetAdminRouteBySlug(ctx context.Context, slug string) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, getAdminRouteBySlug, slug)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminRouteId = `-- name: GetAdminRouteId :one
SELECT admin_route_id FROM admin_routes
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetAdminRouteId(ctx context.Context, slug string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getAdminRouteId, slug)
	var admin_route_id int32
	err := row.Scan(&admin_route_id)
	return admin_route_id, err
}

const getContentData = `-- name: GetContentData :one
SELECT content_data_id, route_id, datatype_id, date_created, date_modified, history FROM content_data
WHERE content_data_id = $1 LIMIT 1
`

func (q *Queries) GetContentData(ctx context.Context, contentDataID int32) (ContentData, error) {
	row := q.db.QueryRowContext(ctx, getContentData, contentDataID)
	var i ContentData
	err := row.Scan(
		&i.ContentDataID,
		&i.RouteID,
		&i.DatatypeID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getContentField = `-- name: GetContentField :one
SELECT content_field_id, route_id, content_data_id, field_id, field_value, date_created, date_modified, history FROM content_fields
WHERE content_field_id = $1 LIMIT 1
`

func (q *Queries) GetContentField(ctx context.Context, contentFieldID int32) (ContentFields, error) {
	row := q.db.QueryRowContext(ctx, getContentField, contentFieldID)
	var i ContentFields
	err := row.Scan(
		&i.ContentFieldID,
		&i.RouteID,
		&i.ContentDataID,
		&i.FieldID,
		&i.FieldValue,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getDatatype = `-- name: GetDatatype :one
SELECT datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history FROM datatypes
WHERE datatype_id = $1 LIMIT 1
`

func (q *Queries) GetDatatype(ctx context.Context, datatypeID int32) (Datatypes, error) {
	row := q.db.QueryRowContext(ctx, getDatatype, datatypeID)
	var i Datatypes
	err := row.Scan(
		&i.DatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getField = `-- name: GetField :one
SELECT field_id, parent_id, label, data, type, author, author_id, date_created, date_modified, history FROM fields 
WHERE field_id = $1 LIMIT 1
`

func (q *Queries) GetField(ctx context.Context, fieldID int32) (Fields, error) {
	row := q.db.QueryRowContext(ctx, getField, fieldID)
	var i Fields
	err := row.Scan(
		&i.FieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getGlobalAdminDatatypeId = `-- name: GetGlobalAdminDatatypeId :one
SELECT admin_datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history FROM admin_datatypes
WHERE type = 'GLOBALS'
LIMIT 1
`

func (q *Queries) GetGlobalAdminDatatypeId(ctx context.Context) (AdminDatatypes, error) {
	row := q.db.QueryRowContext(ctx, getGlobalAdminDatatypeId)
	var i AdminDatatypes
	err := row.Scan(
		&i.AdminDatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getMedia = `-- name: GetMedia :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author, author_id, date_created, date_modified FROM media
WHERE media_id = $1 LIMIT 1
`

func (q *Queries) GetMedia(ctx context.Context, mediaID int32) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMedia, mediaID)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.Url,
		&i.Srcset,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaByName = `-- name: GetMediaByName :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author, author_id, date_created, date_modified FROM media
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetMediaByName(ctx context.Context, name sql.NullString) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMediaByName, name)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.Url,
		&i.Srcset,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaByUrl = `-- name: GetMediaByUrl :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author, author_id, date_created, date_modified FROM media
WHERE url = $1 LIMIT 1
`

func (q *Queries) GetMediaByUrl(ctx context.Context, url sql.NullString) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMediaByUrl, url)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.Url,
		&i.Srcset,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaDimension = `-- name: GetMediaDimension :one
SELECT md_id, label, width, height, aspect_ratio FROM media_dimensions
WHERE md_id = $1 LIMIT 1
`

func (q *Queries) GetMediaDimension(ctx context.Context, mdID int32) (MediaDimensions, error) {
	row := q.db.QueryRowContext(ctx, getMediaDimension, mdID)
	var i MediaDimensions
	err := row.Scan(
		&i.MdID,
		&i.Label,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
	)
	return i, err
}

const getPermission = `-- name: GetPermission :one
SELECT permission_id, table_id, mode, label FROM permissions 
WHERE permission_id = $1 LIMIT 1
`

func (q *Queries) GetPermission(ctx context.Context, permissionID int32) (Permissions, error) {
	row := q.db.QueryRowContext(ctx, getPermission, permissionID)
	var i Permissions
	err := row.Scan(
		&i.PermissionID,
		&i.TableID,
		&i.Mode,
		&i.Label,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT role_id, label, permissions FROM roles
WHERE role_id = $1
`

func (q *Queries) GetRole(ctx context.Context, roleID int32) (Roles, error) {
	row := q.db.QueryRowContext(ctx, getRole, roleID)
	var i Roles
	err := row.Scan(&i.RoleID, &i.Label, &i.Permissions)
	return i, err
}

const getRoute = `-- name: GetRoute :one
SELECT route_id, slug, title, status, author, author_id, date_created, date_modified, history FROM routes
WHERE slug = $1
LIMIT 1
`

func (q *Queries) GetRoute(ctx context.Context, slug string) (Routes, error) {
	row := q.db.QueryRowContext(ctx, getRoute, slug)
	var i Routes
	err := row.Scan(
		&i.RouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.Author,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getRouteID = `-- name: GetRouteID :one
SELECT route_id FROM routes
WHERE slug = $1
LIMIT 1
`

func (q *Queries) GetRouteID(ctx context.Context, slug string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getRouteID, slug)
	var route_id int32
	err := row.Scan(&route_id)
	return route_id, err
}

const getSession = `-- name: GetSession :one
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
WHERE session_id = $1 LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, sessionID int32) (Sessions, error) {
	row := q.db.QueryRowContext(ctx, getSession, sessionID)
	var i Sessions
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccess,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionData,
	)
	return i, err
}

const getSessionByUserId = `-- name: GetSessionByUserId :many
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
WHERE user_id = $1
`

func (q *Queries) GetSessionByUserId(ctx context.Context, userID int32) ([]Sessions, error) {
	rows, err := q.db.QueryContext(ctx, getSessionByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sessions
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastAccess,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTable = `-- name: GetTable :one
SELECT id, label, author_id FROM tables
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTable(ctx context.Context, id int32) (Tables, error) {
	row := q.db.QueryRowContext(ctx, getTable, id)
	var i Tables
	err := row.Scan(&i.ID, &i.Label, &i.AuthorID)
	return i, err
}

const getTableId = `-- name: GetTableId :one
SELECT id FROM tables
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTableId(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getTableId, id)
	err := row.Scan(&id)
	return id, err
}

const getToken = `-- name: GetToken :one
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetToken(ctx context.Context, id int32) (Tokens, error) {
	row := q.db.QueryRowContext(ctx, getToken, id)
	var i Tokens
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.Token,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const getTokenByUserId = `-- name: GetTokenByUserId :many
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
WHERE user_id = $1
`

func (q *Queries) GetTokenByUserId(ctx context.Context, userID int32) ([]Tokens, error) {
	rows, err := q.db.QueryContext(ctx, getTokenByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tokens
	for rows.Next() {
		var i Tokens
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenType,
			&i.Token,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, userID int32) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUser, userID)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Role,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Role,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getUserId = `-- name: GetUserId :one
SELECT user_id FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserId(ctx context.Context, email string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserId, email)
	var user_id int32
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserOauth = `-- name: GetUserOauth :one
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
WHERE user_oauth_id = $1
LIMIT 1
`

func (q *Queries) GetUserOauth(ctx context.Context, userOauthID int32) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauth, userOauthID)
	var i UserOauth
	err := row.Scan(
		&i.UserOauthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OauthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthByEmail = `-- name: GetUserOauthByEmail :one
SELECT uo.user_oauth_id, uo.user_id, uo.oauth_provider, uo.oauth_provider_user_id, uo.access_token, uo.refresh_token, uo.token_expires_at, uo.date_created
FROM user_oauth uo
JOIN users u ON uo.user_id = u.user_id
WHERE u.email = $1
LIMIT 1
`

func (q *Queries) GetUserOauthByEmail(ctx context.Context, email string) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthByEmail, email)
	var i UserOauth
	err := row.Scan(
		&i.UserOauthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OauthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthId = `-- name: GetUserOauthId :one
SELECT uo.user_id
FROM user_oauth uo
JOIN users u ON uo.user_id = u.user_id
WHERE u.email = $1
LIMIT 1
`

func (q *Queries) GetUserOauthId(ctx context.Context, email string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthId, email)
	var user_id int32
	err := row.Scan(&user_id)
	return user_id, err
}

const listAdminContentData = `-- name: ListAdminContentData :many
SELECT admin_content_data_id, admin_route_id, admin_datatype_id, date_created, date_modified, history FROM admin_content_data
ORDER BY admin_content_data_id
`

func (q *Queries) ListAdminContentData(ctx context.Context) ([]AdminContentData, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminContentData
	for rows.Next() {
		var i AdminContentData
		if err := rows.Scan(
			&i.AdminContentDataID,
			&i.AdminRouteID,
			&i.AdminDatatypeID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentDataByRoute = `-- name: ListAdminContentDataByRoute :many
SELECT admin_content_data_id, admin_route_id, admin_datatype_id, date_created, date_modified, history FROM admin_content_data
WHERE admin_route_id = $1
`

func (q *Queries) ListAdminContentDataByRoute(ctx context.Context, adminRouteID sql.NullInt32) ([]AdminContentData, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentDataByRoute, adminRouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminContentData
	for rows.Next() {
		var i AdminContentData
		if err := rows.Scan(
			&i.AdminContentDataID,
			&i.AdminRouteID,
			&i.AdminDatatypeID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentFields = `-- name: ListAdminContentFields :many
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, date_created, date_modified, history FROM admin_content_fields
ORDER BY admin_content_field_id
`

func (q *Queries) ListAdminContentFields(ctx context.Context) ([]AdminContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminContentFields
	for rows.Next() {
		var i AdminContentFields
		if err := rows.Scan(
			&i.AdminContentFieldID,
			&i.AdminRouteID,
			&i.AdminContentDataID,
			&i.AdminFieldID,
			&i.AdminFieldValue,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentFieldsByRoute = `-- name: ListAdminContentFieldsByRoute :many
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, date_created, date_modified, history FROM admin_content_fields
WHERE admin_route_id = $1
`

func (q *Queries) ListAdminContentFieldsByRoute(ctx context.Context, adminRouteID sql.NullInt32) ([]AdminContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentFieldsByRoute, adminRouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminContentFields
	for rows.Next() {
		var i AdminContentFields
		if err := rows.Scan(
			&i.AdminContentFieldID,
			&i.AdminRouteID,
			&i.AdminContentDataID,
			&i.AdminFieldID,
			&i.AdminFieldValue,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatype = `-- name: ListAdminDatatype :many
SELECT admin_datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history FROM admin_datatypes
ORDER BY admin_datatype_id
`

func (q *Queries) ListAdminDatatype(ctx context.Context) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypes
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeChildren = `-- name: ListAdminDatatypeChildren :many
SELECT admin_datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history FROM admin_datatypes
WHERE parent_id = $1
`

func (q *Queries) ListAdminDatatypeChildren(ctx context.Context, parentID sql.NullInt32) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeChildren, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypes
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeTree = `-- name: ListAdminDatatypeTree :many
SELECT 
    child.admin_datatype_id AS child_id,
    child.label AS child_label,
    parent.admin_datatype_id AS parent_id,
    parent.label AS parent_label
FROM admin_datatypes AS child
LEFT JOIN admin_datatypes AS parent 
    ON child.parent_id = parent.admin_datatype_id
`

type ListAdminDatatypeTreeRow struct {
	ChildID     int32          `json:"child_id"`
	ChildLabel  string         `json:"child_label"`
	ParentID    sql.NullInt32  `json:"parent_id"`
	ParentLabel sql.NullString `json:"parent_label"`
}

func (q *Queries) ListAdminDatatypeTree(ctx context.Context) ([]ListAdminDatatypeTreeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeTree)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAdminDatatypeTreeRow
	for rows.Next() {
		var i ListAdminDatatypeTreeRow
		if err := rows.Scan(
			&i.ChildID,
			&i.ChildLabel,
			&i.ParentID,
			&i.ParentLabel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminField = `-- name: ListAdminField :many
SELECT admin_field_id, parent_id, label, data, type, author, author_id, date_created, date_modified, history
FROM admin_fields
ORDER BY admin_field_id
`

func (q *Queries) ListAdminField(ctx context.Context) ([]AdminFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminFields
	for rows.Next() {
		var i AdminFields
		if err := rows.Scan(
			&i.AdminFieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Type,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminFieldsByDatatypeID = `-- name: ListAdminFieldsByDatatypeID :many
SELECT admin_field_id, 
       parent_id,
       label,
       data,
       type,
       history
FROM admin_fields
WHERE parent_id = $1
`

type ListAdminFieldsByDatatypeIDRow struct {
	AdminFieldID int32          `json:"admin_field_id"`
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) ListAdminFieldsByDatatypeID(ctx context.Context, parentID sql.NullInt32) ([]ListAdminFieldsByDatatypeIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listAdminFieldsByDatatypeID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAdminFieldsByDatatypeIDRow
	for rows.Next() {
		var i ListAdminFieldsByDatatypeIDRow
		if err := rows.Scan(
			&i.AdminFieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Type,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminRoute = `-- name: ListAdminRoute :many
SELECT admin_route_id, slug, title, status, author, author_id, date_created, date_modified, history FROM admin_routes
ORDER BY slug
`

func (q *Queries) ListAdminRoute(ctx context.Context) ([]AdminRoutes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminRoute)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminRoutes
	for rows.Next() {
		var i AdminRoutes
		if err := rows.Scan(
			&i.AdminRouteID,
			&i.Slug,
			&i.Title,
			&i.Status,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentData = `-- name: ListContentData :many
SELECT content_data_id, route_id, datatype_id, date_created, date_modified, history FROM content_data
ORDER BY content_data_id
`

func (q *Queries) ListContentData(ctx context.Context) ([]ContentData, error) {
	rows, err := q.db.QueryContext(ctx, listContentData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentData
	for rows.Next() {
		var i ContentData
		if err := rows.Scan(
			&i.ContentDataID,
			&i.RouteID,
			&i.DatatypeID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentDataByRoute = `-- name: ListContentDataByRoute :many
SELECT content_data_id, route_id, datatype_id, date_created, date_modified, history FROM content_data
WHERE route_id = $1
`

func (q *Queries) ListContentDataByRoute(ctx context.Context, routeID sql.NullInt32) ([]ContentData, error) {
	rows, err := q.db.QueryContext(ctx, listContentDataByRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentData
	for rows.Next() {
		var i ContentData
		if err := rows.Scan(
			&i.ContentDataID,
			&i.RouteID,
			&i.DatatypeID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentFields = `-- name: ListContentFields :many
SELECT content_field_id, route_id, content_data_id, field_id, field_value, date_created, date_modified, history FROM content_fields
ORDER BY content_field_id
`

func (q *Queries) ListContentFields(ctx context.Context) ([]ContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listContentFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentFields
	for rows.Next() {
		var i ContentFields
		if err := rows.Scan(
			&i.ContentFieldID,
			&i.RouteID,
			&i.ContentDataID,
			&i.FieldID,
			&i.FieldValue,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentFieldsByRoute = `-- name: ListContentFieldsByRoute :many
SELECT content_field_id, route_id, content_data_id, field_id, field_value, date_created, date_modified, history FROM content_fields
WHERE route_id = $1
`

func (q *Queries) ListContentFieldsByRoute(ctx context.Context, routeID sql.NullInt32) ([]ContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listContentFieldsByRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentFields
	for rows.Next() {
		var i ContentFields
		if err := rows.Scan(
			&i.ContentFieldID,
			&i.RouteID,
			&i.ContentDataID,
			&i.FieldID,
			&i.FieldValue,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatype = `-- name: ListDatatype :many
SELECT datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history FROM datatypes
ORDER BY datatype_id
`

func (q *Queries) ListDatatype(ctx context.Context) ([]Datatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datatypes
	for rows.Next() {
		var i Datatypes
		if err := rows.Scan(
			&i.DatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listField = `-- name: ListField :many
SELECT field_id, parent_id, label, data, type, author, author_id, date_created, date_modified, history FROM fields 
ORDER BY field_id
`

func (q *Queries) ListField(ctx context.Context) ([]Fields, error) {
	rows, err := q.db.QueryContext(ctx, listField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fields
	for rows.Next() {
		var i Fields
		if err := rows.Scan(
			&i.FieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Type,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFieldByDatatypeID = `-- name: ListFieldByDatatypeID :many
SELECT field_id, parent_id, label, data, type, author, author_id, date_created, date_modified, history FROM fields 
WHERE parent_id = $1
ORDER BY field_id
`

func (q *Queries) ListFieldByDatatypeID(ctx context.Context, parentID sql.NullInt32) ([]Fields, error) {
	rows, err := q.db.QueryContext(ctx, listFieldByDatatypeID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fields
	for rows.Next() {
		var i Fields
		if err := rows.Scan(
			&i.FieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Type,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMedia = `-- name: ListMedia :many
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author, author_id, date_created, date_modified FROM media
ORDER BY name
`

func (q *Queries) ListMedia(ctx context.Context) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, listMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.MediaID,
			&i.Name,
			&i.DisplayName,
			&i.Alt,
			&i.Caption,
			&i.Description,
			&i.Class,
			&i.Mimetype,
			&i.Dimensions,
			&i.Url,
			&i.Srcset,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaDimension = `-- name: ListMediaDimension :many
SELECT md_id, label, width, height, aspect_ratio FROM media_dimensions 
ORDER BY label
`

func (q *Queries) ListMediaDimension(ctx context.Context) ([]MediaDimensions, error) {
	rows, err := q.db.QueryContext(ctx, listMediaDimension)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaDimensions
	for rows.Next() {
		var i MediaDimensions
		if err := rows.Scan(
			&i.MdID,
			&i.Label,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermission = `-- name: ListPermission :many
SELECT permission_id, table_id, mode, label FROM permissions 
ORDER BY table_id
`

func (q *Queries) ListPermission(ctx context.Context) ([]Permissions, error) {
	rows, err := q.db.QueryContext(ctx, listPermission)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permissions
	for rows.Next() {
		var i Permissions
		if err := rows.Scan(
			&i.PermissionID,
			&i.TableID,
			&i.Mode,
			&i.Label,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRole = `-- name: ListRole :many
SELECT role_id, label, permissions FROM roles 
ORDER BY role_id
`

func (q *Queries) ListRole(ctx context.Context) ([]Roles, error) {
	rows, err := q.db.QueryContext(ctx, listRole)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Roles
	for rows.Next() {
		var i Roles
		if err := rows.Scan(&i.RoleID, &i.Label, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoute = `-- name: ListRoute :many
SELECT route_id, slug, title, status, author, author_id, date_created, date_modified, history FROM routes
ORDER BY slug
`

func (q *Queries) ListRoute(ctx context.Context) ([]Routes, error) {
	rows, err := q.db.QueryContext(ctx, listRoute)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Routes
	for rows.Next() {
		var i Routes
		if err := rows.Scan(
			&i.RouteID,
			&i.Slug,
			&i.Title,
			&i.Status,
			&i.Author,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSession = `-- name: ListSession :many
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
`

func (q *Queries) ListSession(ctx context.Context) ([]Sessions, error) {
	rows, err := q.db.QueryContext(ctx, listSession)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sessions
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastAccess,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTable = `-- name: ListTable :many
SELECT id, label, author_id FROM tables 
ORDER BY label
`

func (q *Queries) ListTable(ctx context.Context) ([]Tables, error) {
	rows, err := q.db.QueryContext(ctx, listTable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tables
	for rows.Next() {
		var i Tables
		if err := rows.Scan(&i.ID, &i.Label, &i.AuthorID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToken = `-- name: ListToken :many
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
`

func (q *Queries) ListToken(ctx context.Context) ([]Tokens, error) {
	rows, err := q.db.QueryContext(ctx, listToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tokens
	for rows.Next() {
		var i Tokens
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenType,
			&i.Token,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUser = `-- name: ListUser :many
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users 
ORDER BY user_id
`

func (q *Queries) ListUser(ctx context.Context) ([]Users, error) {
	rows, err := q.db.QueryContext(ctx, listUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Users
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Name,
			&i.Email,
			&i.Hash,
			&i.Role,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOauth = `-- name: ListUserOauth :many
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
ORDER BY user_oauth_id
`

func (q *Queries) ListUserOauth(ctx context.Context) ([]UserOauth, error) {
	rows, err := q.db.QueryContext(ctx, listUserOauth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserOauth
	for rows.Next() {
		var i UserOauth
		if err := rows.Scan(
			&i.UserOauthID,
			&i.UserID,
			&i.OauthProvider,
			&i.OauthProviderUserID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.TokenExpiresAt,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAdminContentData = `-- name: UpdateAdminContentData :exec
UPDATE admin_content_data
set admin_route_id = $1,
    admin_datatype_id =$2,
    history = $3,
    date_created = $4,
    date_modified = $5
    WHERE admin_content_data_id = $6
    RETURNING admin_content_data_id, admin_route_id, admin_datatype_id, date_created, date_modified, history
`

type UpdateAdminContentDataParams struct {
	AdminRouteID       sql.NullInt32  `json:"admin_route_id"`
	AdminDatatypeID    sql.NullInt32  `json:"admin_datatype_id"`
	History            sql.NullString `json:"history"`
	DateCreated        sql.NullTime   `json:"date_created"`
	DateModified       sql.NullTime   `json:"date_modified"`
	AdminContentDataID int32          `json:"admin_content_data_id"`
}

func (q *Queries) UpdateAdminContentData(ctx context.Context, arg UpdateAdminContentDataParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminContentData,
		arg.AdminRouteID,
		arg.AdminDatatypeID,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
		arg.AdminContentDataID,
	)
	return err
}

const updateAdminContentField = `-- name: UpdateAdminContentField :exec
UPDATE admin_content_fields
set  admin_content_field_id=$1,
    admin_route_id=$2,
    admin_content_data_id=$3,
    admin_field_id=$4,
    admin_field_value=$5, 
    history=$6,
    date_created=$7, 
    date_modified=$8
    WHERE admin_content_field_id = $9
    RETURNING admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, date_created, date_modified, history
`

type UpdateAdminContentFieldParams struct {
	AdminContentFieldID   int32          `json:"admin_content_field_id"`
	AdminRouteID          sql.NullInt32  `json:"admin_route_id"`
	AdminContentDataID    int32          `json:"admin_content_data_id"`
	AdminFieldID          int32          `json:"admin_field_id"`
	AdminFieldValue       string         `json:"admin_field_value"`
	History               sql.NullString `json:"history"`
	DateCreated           sql.NullTime   `json:"date_created"`
	DateModified          sql.NullTime   `json:"date_modified"`
	AdminContentFieldID_2 int32          `json:"admin_content_field_id_2"`
}

func (q *Queries) UpdateAdminContentField(ctx context.Context, arg UpdateAdminContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminContentField,
		arg.AdminContentFieldID,
		arg.AdminRouteID,
		arg.AdminContentDataID,
		arg.AdminFieldID,
		arg.AdminFieldValue,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
		arg.AdminContentFieldID_2,
	)
	return err
}

const updateAdminDatatype = `-- name: UpdateAdminDatatype :exec
UPDATE admin_datatypes
SET parent_id = $1,
    label = $2,
    type = $3,
    author = $4,
    author_id = $5,
    date_created = $6,
    date_modified = $7,
    history = $8
WHERE admin_datatype_id = $9
RETURNING admin_datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history
`

type UpdateAdminDatatypeParams struct {
	ParentID        sql.NullInt32  `json:"parent_id"`
	Label           string         `json:"label"`
	Type            string         `json:"type"`
	Author          string         `json:"author"`
	AuthorID        int32          `json:"author_id"`
	DateCreated     sql.NullTime   `json:"date_created"`
	DateModified    sql.NullTime   `json:"date_modified"`
	History         sql.NullString `json:"history"`
	AdminDatatypeID int32          `json:"admin_datatype_id"`
}

func (q *Queries) UpdateAdminDatatype(ctx context.Context, arg UpdateAdminDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.AdminDatatypeID,
	)
	return err
}

const updateAdminField = `-- name: UpdateAdminField :exec
UPDATE admin_fields
SET parent_id    = $1,
    label        = $2,
    data         = $3,
    type         = $4,
    author       = $5,
    author_id    = $6,
    date_created = $7,
    date_modified= $8,
    history      = $9
WHERE admin_field_id = $10
`

type UpdateAdminFieldParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
	History      sql.NullString `json:"history"`
	AdminFieldID int32          `json:"admin_field_id"`
}

func (q *Queries) UpdateAdminField(ctx context.Context, arg UpdateAdminFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Type,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.AdminFieldID,
	)
	return err
}

const updateAdminRoute = `-- name: UpdateAdminRoute :exec
UPDATE admin_routes
set slug = $1,
    title = $2,
    status = $3,
    author = $4,
    author_id = $5,
    date_created = $6,
    date_modified = $7,
    history = $8
    WHERE slug = $9
    RETURNING admin_route_id, slug, title, status, author, author_id, date_created, date_modified, history
`

type UpdateAdminRouteParams struct {
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	Status       int32          `json:"status"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
	History      sql.NullString `json:"history"`
	Slug_2       string         `json:"slug_2"`
}

func (q *Queries) UpdateAdminRoute(ctx context.Context, arg UpdateAdminRouteParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.Slug_2,
	)
	return err
}

const updateContentData = `-- name: UpdateContentData :exec
UPDATE content_data
set route_id = $1,
    datatype_id =$2,
    history = $3,
    date_created = $4,
    date_modified = $5
    WHERE content_data_id = $6
    RETURNING content_data_id, route_id, datatype_id, date_created, date_modified, history
`

type UpdateContentDataParams struct {
	RouteID       sql.NullInt32  `json:"route_id"`
	DatatypeID    sql.NullInt32  `json:"datatype_id"`
	History       sql.NullString `json:"history"`
	DateCreated   sql.NullTime   `json:"date_created"`
	DateModified  sql.NullTime   `json:"date_modified"`
	ContentDataID int32          `json:"content_data_id"`
}

func (q *Queries) UpdateContentData(ctx context.Context, arg UpdateContentDataParams) error {
	_, err := q.db.ExecContext(ctx, updateContentData,
		arg.RouteID,
		arg.DatatypeID,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
		arg.ContentDataID,
	)
	return err
}

const updateContentField = `-- name: UpdateContentField :exec
UPDATE content_fields
set  content_field_id=$1,
    route_id=$2,
    content_data_id=$3,
    field_id=$4,
    field_value=$5, 
    history=$6,
    date_created=$7, 
    date_modified=$8
    WHERE content_field_id = $9
    RETURNING content_field_id, route_id, content_data_id, field_id, field_value, date_created, date_modified, history
`

type UpdateContentFieldParams struct {
	ContentFieldID   int32          `json:"content_field_id"`
	RouteID          sql.NullInt32  `json:"route_id"`
	ContentDataID    int32          `json:"content_data_id"`
	FieldID          int32          `json:"field_id"`
	FieldValue       string         `json:"field_value"`
	History          sql.NullString `json:"history"`
	DateCreated      sql.NullTime   `json:"date_created"`
	DateModified     sql.NullTime   `json:"date_modified"`
	ContentFieldID_2 int32          `json:"content_field_id_2"`
}

func (q *Queries) UpdateContentField(ctx context.Context, arg UpdateContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateContentField,
		arg.ContentFieldID,
		arg.RouteID,
		arg.ContentDataID,
		arg.FieldID,
		arg.FieldValue,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
		arg.ContentFieldID_2,
	)
	return err
}

const updateDatatype = `-- name: UpdateDatatype :exec
UPDATE datatypes
set parent_id = $1,
    label = $2,
    type = $3,
    author = $4,
    author_id = $5,
    history = $6,
    date_created = $7,
    date_modified = $8
    WHERE datatype_id = $9
    RETURNING datatype_id, parent_id, label, type, author, author_id, date_created, date_modified, history
`

type UpdateDatatypeParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Type         string         `json:"type"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	History      sql.NullString `json:"history"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
	DatatypeID   int32          `json:"datatype_id"`
}

func (q *Queries) UpdateDatatype(ctx context.Context, arg UpdateDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, updateDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.Author,
		arg.AuthorID,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
		arg.DatatypeID,
	)
	return err
}

const updateField = `-- name: UpdateField :exec
UPDATE fields 
set parent_id = $1,
    label = $2,
    data = $3,
    type = $4,
    author = $5,
    author_id = $6,
    history =$7,
    date_created = $8,
    date_modified = $9
    WHERE field_id = $10
    RETURNING field_id, parent_id, label, data, type, author, author_id, date_created, date_modified, history
`

type UpdateFieldParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	History      sql.NullString `json:"history"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
	FieldID      int32          `json:"field_id"`
}

func (q *Queries) UpdateField(ctx context.Context, arg UpdateFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Type,
		arg.Author,
		arg.AuthorID,
		arg.History,
		arg.DateCreated,
		arg.DateModified,
		arg.FieldID,
	)
	return err
}

const updateMedia = `-- name: UpdateMedia :exec
UPDATE media
  set   name = $1,
        display_name = $2,
        alt = $3,
        caption = $4,
        description = $5,
        class = $6,
        url = $7,
        mimetype = $8,
        dimensions = $9,
        srcset = $10,
        author = $11,
        author_id = $12,
        date_created = $13,
        date_modified = $14
        WHERE media_id = $15
`

type UpdateMediaParams struct {
	Name         sql.NullString `json:"name"`
	DisplayName  sql.NullString `json:"display_name"`
	Alt          sql.NullString `json:"alt"`
	Caption      sql.NullString `json:"caption"`
	Description  sql.NullString `json:"description"`
	Class        sql.NullString `json:"class"`
	Url          sql.NullString `json:"url"`
	Mimetype     sql.NullString `json:"mimetype"`
	Dimensions   sql.NullString `json:"dimensions"`
	Srcset       sql.NullString `json:"srcset"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  sql.NullTime   `json:"date_created"`
	DateModified sql.NullTime   `json:"date_modified"`
	MediaID      int32          `json:"media_id"`
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) error {
	_, err := q.db.ExecContext(ctx, updateMedia,
		arg.Name,
		arg.DisplayName,
		arg.Alt,
		arg.Caption,
		arg.Description,
		arg.Class,
		arg.Url,
		arg.Mimetype,
		arg.Dimensions,
		arg.Srcset,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.MediaID,
	)
	return err
}

const updateMediaDimension = `-- name: UpdateMediaDimension :exec
UPDATE media_dimensions
set label = $1,
    width = $2,
    height = $3,
    aspect_ratio = $4
WHERE md_id = $5
`

type UpdateMediaDimensionParams struct {
	Label       sql.NullString `json:"label"`
	Width       sql.NullInt32  `json:"width"`
	Height      sql.NullInt32  `json:"height"`
	AspectRatio sql.NullString `json:"aspect_ratio"`
	MdID        int32          `json:"md_id"`
}

func (q *Queries) UpdateMediaDimension(ctx context.Context, arg UpdateMediaDimensionParams) error {
	_, err := q.db.ExecContext(ctx, updateMediaDimension,
		arg.Label,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
		arg.MdID,
	)
	return err
}

const updatePermission = `-- name: UpdatePermission :exec
UPDATE permissions
set table_id=$1,
    mode=$2,
    label=$3
WHERE permission_id = $4
`

type UpdatePermissionParams struct {
	TableID      int32  `json:"table_id"`
	Mode         int32  `json:"mode"`
	Label        string `json:"label"`
	PermissionID int32  `json:"permission_id"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) error {
	_, err := q.db.ExecContext(ctx, updatePermission,
		arg.TableID,
		arg.Mode,
		arg.Label,
		arg.PermissionID,
	)
	return err
}

const updateRole = `-- name: UpdateRole :exec
UPDATE roles
SET label = $1,
    permissions = $2
WHERE role_id = $3
`

type UpdateRoleParams struct {
	Label       string                `json:"label"`
	Permissions pqtype.NullRawMessage `json:"permissions"`
	RoleID      int32                 `json:"role_id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateRole, arg.Label, arg.Permissions, arg.RoleID)
	return err
}

const updateRoute = `-- name: UpdateRoute :exec
UPDATE routes
SET slug = $1,
    title = $2,
    status = $3,
    history = $4,
    author = $5,
    author_id = $6,
    date_created = $7,
    date_modified = $8
WHERE slug = $9
RETURNING route_id, slug, title, status, author, author_id, date_created, date_modified, history
`

type UpdateRouteParams struct {
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	Status       int32          `json:"status"`
	History      sql.NullString `json:"history"`
	Author       string         `json:"author"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  sql.NullString `json:"date_created"`
	DateModified sql.NullString `json:"date_modified"`
	Slug_2       string         `json:"slug_2"`
}

func (q *Queries) UpdateRoute(ctx context.Context, arg UpdateRouteParams) error {
	_, err := q.db.ExecContext(ctx, updateRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.History,
		arg.Author,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.Slug_2,
	)
	return err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE sessions
    SET user_id=$1,
    created_at=$2,
    expires_at=$3,
    last_access=$4,
    ip_address=$5,
    user_agent=$6,
    session_data=$7
WHERE session_id = $8
`

type UpdateSessionParams struct {
	UserID      int32          `json:"user_id"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	ExpiresAt   sql.NullTime   `json:"expires_at"`
	LastAccess  sql.NullTime   `json:"last_access"`
	IpAddress   sql.NullString `json:"ip_address"`
	UserAgent   sql.NullString `json:"user_agent"`
	SessionData sql.NullString `json:"session_data"`
	SessionID   int32          `json:"session_id"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateSession,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastAccess,
		arg.IpAddress,
		arg.UserAgent,
		arg.SessionData,
		arg.SessionID,
	)
	return err
}

const updateTable = `-- name: UpdateTable :exec
UPDATE tables
SET label = $1
WHERE id = $2
`

type UpdateTableParams struct {
	Label sql.NullString `json:"label"`
	ID    int32          `json:"id"`
}

func (q *Queries) UpdateTable(ctx context.Context, arg UpdateTableParams) error {
	_, err := q.db.ExecContext(ctx, updateTable, arg.Label, arg.ID)
	return err
}

const updateToken = `-- name: UpdateToken :exec
UPDATE tokens
set token = $1,
issued_at = $2,
expires_at = $3,
revoked = $4
WHERE id = $5
`

type UpdateTokenParams struct {
	Token     string       `json:"token"`
	IssuedAt  time.Time    `json:"issued_at"`
	ExpiresAt time.Time    `json:"expires_at"`
	Revoked   sql.NullBool `json:"revoked"`
	ID        int32        `json:"id"`
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateToken,
		arg.Token,
		arg.IssuedAt,
		arg.ExpiresAt,
		arg.Revoked,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
set date_created = $1,
    date_modified = $2,
    username = $3,
    name = $4,
    email = $5,
    hash = $6,
    role = $7
WHERE user_id = $8
`

type UpdateUserParams struct {
	DateCreated  sql.NullTime  `json:"date_created"`
	DateModified sql.NullTime  `json:"date_modified"`
	Username     string        `json:"username"`
	Name         string        `json:"name"`
	Email        string        `json:"email"`
	Hash         string        `json:"hash"`
	Role         sql.NullInt32 `json:"role"`
	UserID       int32         `json:"user_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.DateCreated,
		arg.DateModified,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.Hash,
		arg.Role,
		arg.UserID,
	)
	return err
}

const updateUserOauth = `-- name: UpdateUserOauth :exec
UPDATE user_oauth
SET access_token = $1,
    refresh_token = $2,
    token_expires_at = $3
WHERE user_oauth_id = $4
`

type UpdateUserOauthParams struct {
	AccessToken    sql.NullString `json:"access_token"`
	RefreshToken   sql.NullString `json:"refresh_token"`
	TokenExpiresAt sql.NullTime   `json:"token_expires_at"`
	UserOauthID    int32          `json:"user_oauth_id"`
}

func (q *Queries) UpdateUserOauth(ctx context.Context, arg UpdateUserOauthParams) error {
	_, err := q.db.ExecContext(ctx, updateUserOauth,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenExpiresAt,
		arg.UserOauthID,
	)
	return err
}
