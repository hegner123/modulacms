// Code generated by tools/dbgen; DO NOT EDIT.
package db

import (
	"context"
	"database/sql"
	"fmt"

	mdbm "github.com/hegner123/modulacms/internal/db-mysql"
	mdbp "github.com/hegner123/modulacms/internal/db-psql"
	mdb "github.com/hegner123/modulacms/internal/db-sqlite"
	"github.com/hegner123/modulacms/internal/db/audited"
	"github.com/hegner123/modulacms/internal/db/types"
)

///////////////////////////////
// STRUCTS
//////////////////////////////

// Datatypes represents a datatype record in the database.
type Datatypes struct {
	DatatypeID   types.DatatypeID         `json:"datatype_id"`
	ParentID     types.NullableDatatypeID `json:"parent_id"`
	Label        string                   `json:"label"`
	Type         string                   `json:"type"`
	AuthorID     types.UserID             `json:"author_id"`
	DateCreated  types.Timestamp          `json:"date_created"`
	DateModified types.Timestamp          `json:"date_modified"`
}

// CreateDatatypeParams contains parameters for creating a new datatype.
type CreateDatatypeParams struct {
	DatatypeID   types.DatatypeID         `json:"datatype_id"`
	ParentID     types.NullableDatatypeID `json:"parent_id"`
	Label        string                   `json:"label"`
	Type         string                   `json:"type"`
	AuthorID     types.UserID             `json:"author_id"`
	DateCreated  types.Timestamp          `json:"date_created"`
	DateModified types.Timestamp          `json:"date_modified"`
}

// UpdateDatatypeParams contains parameters for updating an existing datatype.
type UpdateDatatypeParams struct {
	ParentID     types.NullableDatatypeID `json:"parent_id"`
	Label        string                   `json:"label"`
	Type         string                   `json:"type"`
	AuthorID     types.UserID             `json:"author_id"`
	DateCreated  types.Timestamp          `json:"date_created"`
	DateModified types.Timestamp          `json:"date_modified"`
	DatatypeID   types.DatatypeID         `json:"datatype_id"`
}

// ListDatatypeChildrenPaginatedParams holds parameters for a filtered paginated query.
type ListDatatypeChildrenPaginatedParams struct {
	ParentID types.DatatypeID
	Limit    int64
	Offset   int64
}

// MapStringDatatype converts Datatypes to StringDatatypes for TUI display.
func MapStringDatatype(a Datatypes) StringDatatypes {
	return StringDatatypes{
		DatatypeID:   a.DatatypeID.String(),
		ParentID:     a.ParentID.String(),
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID.String(),
		DateCreated:  a.DateCreated.String(),
		DateModified: a.DateModified.String(),
		History:      "",
	}
}

///////////////////////////////
// SQLITE
//////////////////////////////

// MAPS

// MapDatatype converts a sqlc-generated SQLite datatype to the wrapper type.
func (d Database) MapDatatype(a mdb.Datatypes) Datatypes {
	return Datatypes{
		DatatypeID:   a.DatatypeID,
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
	}
}

// MapCreateDatatypeParams converts wrapper params to sqlc-generated SQLite params.
func (d Database) MapCreateDatatypeParams(a CreateDatatypeParams) mdb.CreateDatatypeParams {
	id := a.DatatypeID
	if id.IsZero() {
		id = types.NewDatatypeID()
	}
	return mdb.CreateDatatypeParams{
		DatatypeID:   id,
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
	}
}

// MapUpdateDatatypeParams converts wrapper params to sqlc-generated SQLite params.
func (d Database) MapUpdateDatatypeParams(a UpdateDatatypeParams) mdb.UpdateDatatypeParams {
	return mdb.UpdateDatatypeParams{
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
		DatatypeID:   a.DatatypeID,
	}
}

// QUERIES

// CountDatatypes returns the total number of datatypes in the database.
func (d Database) CountDatatypes() (*int64, error) {
	queries := mdb.New(d.Connection)
	c, err := queries.CountDatatype(d.Context)
	if err != nil {
		return nil, fmt.Errorf("%v", err)
	}
	return &c, nil
}

// CreateDatatypeTable creates the datatypes table in the database.
func (d Database) CreateDatatypeTable() error {
	queries := mdb.New(d.Connection)
	err := queries.CreateDatatypeTable(d.Context)
	return err
}

// CreateDatatype inserts a new datatype and records an audit event.
func (d Database) CreateDatatype(ctx context.Context, ac audited.AuditContext, s CreateDatatypeParams) (*Datatypes, error) {
	cmd := d.NewDatatypeCmd(ctx, ac, s)
	result, err := audited.Create(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to create datatype: %w", err)
	}
	r := d.MapDatatype(result)
	return &r, nil
}

// DeleteDatatype removes a datatype and records an audit event.
func (d Database) DeleteDatatype(ctx context.Context, ac audited.AuditContext, id types.DatatypeID) error {
	cmd := d.DeleteDatatypeCmd(ctx, ac, id)
	return audited.Delete(cmd)
}

// GetDatatype retrieves a datatype by ID.
func (d Database) GetDatatype(id types.DatatypeID) (*Datatypes, error) {
	queries := mdb.New(d.Connection)
	row, err := queries.GetDatatype(d.Context, mdb.GetDatatypeParams{DatatypeID: id})
	if err != nil {
		return nil, err
	}
	res := d.MapDatatype(row)
	return &res, nil
}

// ListDatatypes retrieves all datatypes in the database.
func (d Database) ListDatatypes() (*[]Datatypes, error) {
	queries := mdb.New(d.Connection)
	rows, err := queries.ListDatatype(d.Context)
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes: %v\n", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

// UpdateDatatype modifies an existing datatype and records an audit event.
func (d Database) UpdateDatatype(ctx context.Context, ac audited.AuditContext, s UpdateDatatypeParams) (*string, error) {
	cmd := d.UpdateDatatypeCmd(ctx, ac, s)
	if err := audited.Update(cmd); err != nil {
		return nil, fmt.Errorf("failed to update datatype: %w", err)
	}
	msg := fmt.Sprintf("Successfully updated %v\n", s.Label)
	return &msg, nil
}

// ListDatatypeChildren retrieves datatypes by parentID.
func (d Database) ListDatatypeChildren(parentID types.DatatypeID) (*[]Datatypes, error) {
	queries := mdb.New(d.Connection)
	rows, err := queries.ListDatatypeChildren(d.Context, mdb.ListDatatypeChildrenParams{ParentID: types.NullableDatatypeID{ID: parentID, Valid: true}})
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes by parentID: %v\n", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

// ListDatatypeChildrenPaginated retrieves a paginated list of datatypes filtered by ParentID.
func (d Database) ListDatatypeChildrenPaginated(params ListDatatypeChildrenPaginatedParams) (*[]Datatypes, error) {
	queries := mdb.New(d.Connection)
	rows, err := queries.ListDatatypeChildrenPaginated(d.Context, mdb.ListDatatypeChildrenPaginatedParams{
		ParentID: types.NullableDatatypeID{ID: params.ParentID, Valid: true},
		Limit:    params.Limit,
		Offset:   params.Offset,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes paginated: %v", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

///////////////////////////////
// MYSQL
//////////////////////////////

// MAPS

// MapDatatype converts a sqlc-generated MySQL datatype to the wrapper type.
func (d MysqlDatabase) MapDatatype(a mdbm.Datatypes) Datatypes {
	return Datatypes{
		DatatypeID:   a.DatatypeID,
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
	}
}

// MapCreateDatatypeParams converts wrapper params to sqlc-generated MySQL params.
func (d MysqlDatabase) MapCreateDatatypeParams(a CreateDatatypeParams) mdbm.CreateDatatypeParams {
	id := a.DatatypeID
	if id.IsZero() {
		id = types.NewDatatypeID()
	}
	return mdbm.CreateDatatypeParams{
		DatatypeID:   id,
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
	}
}

// MapUpdateDatatypeParams converts wrapper params to sqlc-generated MySQL params.
func (d MysqlDatabase) MapUpdateDatatypeParams(a UpdateDatatypeParams) mdbm.UpdateDatatypeParams {
	return mdbm.UpdateDatatypeParams{
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
		DatatypeID:   a.DatatypeID,
	}
}

// QUERIES

// CountDatatypes returns the total number of datatypes in the database.
func (d MysqlDatabase) CountDatatypes() (*int64, error) {
	queries := mdbm.New(d.Connection)
	c, err := queries.CountDatatype(d.Context)
	if err != nil {
		return nil, fmt.Errorf("%v", err)
	}
	return &c, nil
}

// CreateDatatypeTable creates the datatypes table in the database.
func (d MysqlDatabase) CreateDatatypeTable() error {
	queries := mdbm.New(d.Connection)
	err := queries.CreateDatatypeTable(d.Context)
	return err
}

// CreateDatatype inserts a new datatype and records an audit event.
func (d MysqlDatabase) CreateDatatype(ctx context.Context, ac audited.AuditContext, s CreateDatatypeParams) (*Datatypes, error) {
	cmd := d.NewDatatypeCmd(ctx, ac, s)
	result, err := audited.Create(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to create datatype: %w", err)
	}
	r := d.MapDatatype(result)
	return &r, nil
}

// DeleteDatatype removes a datatype and records an audit event.
func (d MysqlDatabase) DeleteDatatype(ctx context.Context, ac audited.AuditContext, id types.DatatypeID) error {
	cmd := d.DeleteDatatypeCmd(ctx, ac, id)
	return audited.Delete(cmd)
}

// GetDatatype retrieves a datatype by ID.
func (d MysqlDatabase) GetDatatype(id types.DatatypeID) (*Datatypes, error) {
	queries := mdbm.New(d.Connection)
	row, err := queries.GetDatatype(d.Context, mdbm.GetDatatypeParams{DatatypeID: id})
	if err != nil {
		return nil, err
	}
	res := d.MapDatatype(row)
	return &res, nil
}

// ListDatatypes retrieves all datatypes in the database.
func (d MysqlDatabase) ListDatatypes() (*[]Datatypes, error) {
	queries := mdbm.New(d.Connection)
	rows, err := queries.ListDatatype(d.Context)
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes: %v\n", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

// UpdateDatatype modifies an existing datatype and records an audit event.
func (d MysqlDatabase) UpdateDatatype(ctx context.Context, ac audited.AuditContext, s UpdateDatatypeParams) (*string, error) {
	cmd := d.UpdateDatatypeCmd(ctx, ac, s)
	if err := audited.Update(cmd); err != nil {
		return nil, fmt.Errorf("failed to update datatype: %w", err)
	}
	msg := fmt.Sprintf("Successfully updated %v\n", s.Label)
	return &msg, nil
}

// ListDatatypeChildren retrieves datatypes by parentID.
func (d MysqlDatabase) ListDatatypeChildren(parentID types.DatatypeID) (*[]Datatypes, error) {
	queries := mdbm.New(d.Connection)
	rows, err := queries.ListDatatypeChildren(d.Context, mdbm.ListDatatypeChildrenParams{ParentID: types.NullableDatatypeID{ID: parentID, Valid: true}})
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes by parentID: %v\n", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

// ListDatatypeChildrenPaginated retrieves a paginated list of datatypes filtered by ParentID.
func (d MysqlDatabase) ListDatatypeChildrenPaginated(params ListDatatypeChildrenPaginatedParams) (*[]Datatypes, error) {
	queries := mdbm.New(d.Connection)
	rows, err := queries.ListDatatypeChildrenPaginated(d.Context, mdbm.ListDatatypeChildrenPaginatedParams{
		ParentID: types.NullableDatatypeID{ID: params.ParentID, Valid: true},
		Limit:    int32(params.Limit),
		Offset:   int32(params.Offset),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes paginated: %v", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

///////////////////////////////
// POSTGRES
//////////////////////////////

// MAPS

// MapDatatype converts a sqlc-generated PostgreSQL datatype to the wrapper type.
func (d PsqlDatabase) MapDatatype(a mdbp.Datatypes) Datatypes {
	return Datatypes{
		DatatypeID:   a.DatatypeID,
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
	}
}

// MapCreateDatatypeParams converts wrapper params to sqlc-generated PostgreSQL params.
func (d PsqlDatabase) MapCreateDatatypeParams(a CreateDatatypeParams) mdbp.CreateDatatypeParams {
	id := a.DatatypeID
	if id.IsZero() {
		id = types.NewDatatypeID()
	}
	return mdbp.CreateDatatypeParams{
		DatatypeID:   id,
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
	}
}

// MapUpdateDatatypeParams converts wrapper params to sqlc-generated PostgreSQL params.
func (d PsqlDatabase) MapUpdateDatatypeParams(a UpdateDatatypeParams) mdbp.UpdateDatatypeParams {
	return mdbp.UpdateDatatypeParams{
		ParentID:     a.ParentID,
		Label:        a.Label,
		Type:         a.Type,
		AuthorID:     a.AuthorID,
		DateCreated:  a.DateCreated,
		DateModified: a.DateModified,
		DatatypeID:   a.DatatypeID,
	}
}

// QUERIES

// CountDatatypes returns the total number of datatypes in the database.
func (d PsqlDatabase) CountDatatypes() (*int64, error) {
	queries := mdbp.New(d.Connection)
	c, err := queries.CountDatatype(d.Context)
	if err != nil {
		return nil, fmt.Errorf("%v", err)
	}
	return &c, nil
}

// CreateDatatypeTable creates the datatypes table in the database.
func (d PsqlDatabase) CreateDatatypeTable() error {
	queries := mdbp.New(d.Connection)
	err := queries.CreateDatatypeTable(d.Context)
	return err
}

// CreateDatatype inserts a new datatype and records an audit event.
func (d PsqlDatabase) CreateDatatype(ctx context.Context, ac audited.AuditContext, s CreateDatatypeParams) (*Datatypes, error) {
	cmd := d.NewDatatypeCmd(ctx, ac, s)
	result, err := audited.Create(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to create datatype: %w", err)
	}
	r := d.MapDatatype(result)
	return &r, nil
}

// DeleteDatatype removes a datatype and records an audit event.
func (d PsqlDatabase) DeleteDatatype(ctx context.Context, ac audited.AuditContext, id types.DatatypeID) error {
	cmd := d.DeleteDatatypeCmd(ctx, ac, id)
	return audited.Delete(cmd)
}

// GetDatatype retrieves a datatype by ID.
func (d PsqlDatabase) GetDatatype(id types.DatatypeID) (*Datatypes, error) {
	queries := mdbp.New(d.Connection)
	row, err := queries.GetDatatype(d.Context, mdbp.GetDatatypeParams{DatatypeID: id})
	if err != nil {
		return nil, err
	}
	res := d.MapDatatype(row)
	return &res, nil
}

// ListDatatypes retrieves all datatypes in the database.
func (d PsqlDatabase) ListDatatypes() (*[]Datatypes, error) {
	queries := mdbp.New(d.Connection)
	rows, err := queries.ListDatatype(d.Context)
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes: %v\n", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

// UpdateDatatype modifies an existing datatype and records an audit event.
func (d PsqlDatabase) UpdateDatatype(ctx context.Context, ac audited.AuditContext, s UpdateDatatypeParams) (*string, error) {
	cmd := d.UpdateDatatypeCmd(ctx, ac, s)
	if err := audited.Update(cmd); err != nil {
		return nil, fmt.Errorf("failed to update datatype: %w", err)
	}
	msg := fmt.Sprintf("Successfully updated %v\n", s.Label)
	return &msg, nil
}

// ListDatatypeChildren retrieves datatypes by parentID.
func (d PsqlDatabase) ListDatatypeChildren(parentID types.DatatypeID) (*[]Datatypes, error) {
	queries := mdbp.New(d.Connection)
	rows, err := queries.ListDatatypeChildren(d.Context, mdbp.ListDatatypeChildrenParams{ParentID: types.NullableDatatypeID{ID: parentID, Valid: true}})
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes by parentID: %v\n", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

// ListDatatypeChildrenPaginated retrieves a paginated list of datatypes filtered by ParentID.
func (d PsqlDatabase) ListDatatypeChildrenPaginated(params ListDatatypeChildrenPaginatedParams) (*[]Datatypes, error) {
	queries := mdbp.New(d.Connection)
	rows, err := queries.ListDatatypeChildrenPaginated(d.Context, mdbp.ListDatatypeChildrenPaginatedParams{
		ParentID: types.NullableDatatypeID{ID: params.ParentID, Valid: true},
		Limit:    int32(params.Limit),
		Offset:   int32(params.Offset),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get Datatypes paginated: %v", err)
	}
	res := []Datatypes{}
	for _, v := range rows {
		m := d.MapDatatype(v)
		res = append(res, m)
	}
	return &res, nil
}

// ========== AUDITED COMMAND TYPES ==========

// ----- SQLite CREATE -----

// NewDatatypeCmd is an audited command for creating datatypes.
type NewDatatypeCmd struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	params   CreateDatatypeParams
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c NewDatatypeCmd) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c NewDatatypeCmd) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c NewDatatypeCmd) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c NewDatatypeCmd) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c NewDatatypeCmd) TableName() string { return "datatypes" }

// Params returns the parameters for this command.
func (c NewDatatypeCmd) Params() any { return c.params }

// GetID extracts the ID from a datatype record.
func (c NewDatatypeCmd) GetID(u mdb.Datatypes) string { return string(u.DatatypeID) }

// Execute creates the datatype in the database.
func (c NewDatatypeCmd) Execute(ctx context.Context, tx audited.DBTX) (mdb.Datatypes, error) {
	id := c.params.DatatypeID
	if id.IsZero() {
		id = types.NewDatatypeID()
	}
	queries := mdb.New(tx)
	return queries.CreateDatatype(ctx, mdb.CreateDatatypeParams{
		DatatypeID:   id,
		ParentID:     c.params.ParentID,
		Label:        c.params.Label,
		Type:         c.params.Type,
		AuthorID:     c.params.AuthorID,
		DateCreated:  c.params.DateCreated,
		DateModified: c.params.DateModified,
	})
}

// NewDatatypeCmd creates a command for inserting a datatype.
func (d Database) NewDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, params CreateDatatypeParams) NewDatatypeCmd {
	return NewDatatypeCmd{ctx: ctx, auditCtx: auditCtx, params: params, conn: d.Connection, recorder: SQLiteRecorder}
}

// ----- SQLite UPDATE -----

// UpdateDatatypeCmd is an audited command for updating datatypes.
type UpdateDatatypeCmd struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	params   UpdateDatatypeParams
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c UpdateDatatypeCmd) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c UpdateDatatypeCmd) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c UpdateDatatypeCmd) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c UpdateDatatypeCmd) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c UpdateDatatypeCmd) TableName() string { return "datatypes" }

// Params returns the parameters for this command.
func (c UpdateDatatypeCmd) Params() any { return c.params }

// GetID returns the datatype ID for this command.
func (c UpdateDatatypeCmd) GetID() string { return string(c.params.DatatypeID) }

// GetBefore retrieves the datatype before the update.
func (c UpdateDatatypeCmd) GetBefore(ctx context.Context, tx audited.DBTX) (mdb.Datatypes, error) {
	queries := mdb.New(tx)
	return queries.GetDatatype(ctx, mdb.GetDatatypeParams{DatatypeID: c.params.DatatypeID})
}

// Execute updates the datatype in the database.
func (c UpdateDatatypeCmd) Execute(ctx context.Context, tx audited.DBTX) error {
	queries := mdb.New(tx)
	return queries.UpdateDatatype(ctx, mdb.UpdateDatatypeParams{
		ParentID:     c.params.ParentID,
		Label:        c.params.Label,
		Type:         c.params.Type,
		AuthorID:     c.params.AuthorID,
		DateCreated:  c.params.DateCreated,
		DateModified: c.params.DateModified,
		DatatypeID:   c.params.DatatypeID,
	})
}

// UpdateDatatypeCmd creates a command for updating a datatype.
func (d Database) UpdateDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, params UpdateDatatypeParams) UpdateDatatypeCmd {
	return UpdateDatatypeCmd{ctx: ctx, auditCtx: auditCtx, params: params, conn: d.Connection, recorder: SQLiteRecorder}
}

// ----- SQLite DELETE -----

// DeleteDatatypeCmd is an audited command for deleting datatypes.
type DeleteDatatypeCmd struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	id       types.DatatypeID
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c DeleteDatatypeCmd) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c DeleteDatatypeCmd) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c DeleteDatatypeCmd) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c DeleteDatatypeCmd) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c DeleteDatatypeCmd) TableName() string { return "datatypes" }

// GetID returns the datatype ID for this command.
func (c DeleteDatatypeCmd) GetID() string { return string(c.id) }

// GetBefore retrieves the datatype before the delete.
func (c DeleteDatatypeCmd) GetBefore(ctx context.Context, tx audited.DBTX) (mdb.Datatypes, error) {
	queries := mdb.New(tx)
	return queries.GetDatatype(ctx, mdb.GetDatatypeParams{DatatypeID: c.id})
}

// Execute deletes the datatype from the database.
func (c DeleteDatatypeCmd) Execute(ctx context.Context, tx audited.DBTX) error {
	queries := mdb.New(tx)
	return queries.DeleteDatatype(ctx, mdb.DeleteDatatypeParams{DatatypeID: c.id})
}

// DeleteDatatypeCmd creates a command for deleting a datatype.
func (d Database) DeleteDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, id types.DatatypeID) DeleteDatatypeCmd {
	return DeleteDatatypeCmd{ctx: ctx, auditCtx: auditCtx, id: id, conn: d.Connection, recorder: SQLiteRecorder}
}

// ----- MySQL CREATE -----

// NewDatatypeCmdMysql is an audited command for creating datatypes in MySQL.
type NewDatatypeCmdMysql struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	params   CreateDatatypeParams
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c NewDatatypeCmdMysql) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c NewDatatypeCmdMysql) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c NewDatatypeCmdMysql) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c NewDatatypeCmdMysql) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c NewDatatypeCmdMysql) TableName() string { return "datatypes" }

// Params returns the parameters for this command.
func (c NewDatatypeCmdMysql) Params() any { return c.params }

// GetID extracts the ID from a datatype record.
func (c NewDatatypeCmdMysql) GetID(u mdbm.Datatypes) string { return string(u.DatatypeID) }

// Execute creates the datatype in the database.
func (c NewDatatypeCmdMysql) Execute(ctx context.Context, tx audited.DBTX) (mdbm.Datatypes, error) {
	id := c.params.DatatypeID
	if id.IsZero() {
		id = types.NewDatatypeID()
	}
	queries := mdbm.New(tx)
	params := mdbm.CreateDatatypeParams{
		DatatypeID:   id,
		ParentID:     c.params.ParentID,
		Label:        c.params.Label,
		Type:         c.params.Type,
		AuthorID:     c.params.AuthorID,
		DateCreated:  c.params.DateCreated,
		DateModified: c.params.DateModified,
	}
	if err := queries.CreateDatatype(ctx, params); err != nil {
		return mdbm.Datatypes{}, err
	}
	return queries.GetDatatype(ctx, mdbm.GetDatatypeParams{DatatypeID: params.DatatypeID})
}

// NewDatatypeCmd creates a command for inserting a datatype.
func (d MysqlDatabase) NewDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, params CreateDatatypeParams) NewDatatypeCmdMysql {
	return NewDatatypeCmdMysql{ctx: ctx, auditCtx: auditCtx, params: params, conn: d.Connection, recorder: MysqlRecorder}
}

// ----- MySQL UPDATE -----

// UpdateDatatypeCmdMysql is an audited command for updating datatypes in MySQL.
type UpdateDatatypeCmdMysql struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	params   UpdateDatatypeParams
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c UpdateDatatypeCmdMysql) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c UpdateDatatypeCmdMysql) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c UpdateDatatypeCmdMysql) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c UpdateDatatypeCmdMysql) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c UpdateDatatypeCmdMysql) TableName() string { return "datatypes" }

// Params returns the parameters for this command.
func (c UpdateDatatypeCmdMysql) Params() any { return c.params }

// GetID returns the datatype ID for this command.
func (c UpdateDatatypeCmdMysql) GetID() string { return string(c.params.DatatypeID) }

// GetBefore retrieves the datatype before the update.
func (c UpdateDatatypeCmdMysql) GetBefore(ctx context.Context, tx audited.DBTX) (mdbm.Datatypes, error) {
	queries := mdbm.New(tx)
	return queries.GetDatatype(ctx, mdbm.GetDatatypeParams{DatatypeID: c.params.DatatypeID})
}

// Execute updates the datatype in the database.
func (c UpdateDatatypeCmdMysql) Execute(ctx context.Context, tx audited.DBTX) error {
	queries := mdbm.New(tx)
	return queries.UpdateDatatype(ctx, mdbm.UpdateDatatypeParams{
		ParentID:     c.params.ParentID,
		Label:        c.params.Label,
		Type:         c.params.Type,
		AuthorID:     c.params.AuthorID,
		DateCreated:  c.params.DateCreated,
		DateModified: c.params.DateModified,
		DatatypeID:   c.params.DatatypeID,
	})
}

// UpdateDatatypeCmd creates a command for updating a datatype.
func (d MysqlDatabase) UpdateDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, params UpdateDatatypeParams) UpdateDatatypeCmdMysql {
	return UpdateDatatypeCmdMysql{ctx: ctx, auditCtx: auditCtx, params: params, conn: d.Connection, recorder: MysqlRecorder}
}

// ----- MySQL DELETE -----

// DeleteDatatypeCmdMysql is an audited command for deleting datatypes in MySQL.
type DeleteDatatypeCmdMysql struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	id       types.DatatypeID
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c DeleteDatatypeCmdMysql) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c DeleteDatatypeCmdMysql) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c DeleteDatatypeCmdMysql) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c DeleteDatatypeCmdMysql) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c DeleteDatatypeCmdMysql) TableName() string { return "datatypes" }

// GetID returns the datatype ID for this command.
func (c DeleteDatatypeCmdMysql) GetID() string { return string(c.id) }

// GetBefore retrieves the datatype before the delete.
func (c DeleteDatatypeCmdMysql) GetBefore(ctx context.Context, tx audited.DBTX) (mdbm.Datatypes, error) {
	queries := mdbm.New(tx)
	return queries.GetDatatype(ctx, mdbm.GetDatatypeParams{DatatypeID: c.id})
}

// Execute deletes the datatype from the database.
func (c DeleteDatatypeCmdMysql) Execute(ctx context.Context, tx audited.DBTX) error {
	queries := mdbm.New(tx)
	return queries.DeleteDatatype(ctx, mdbm.DeleteDatatypeParams{DatatypeID: c.id})
}

// DeleteDatatypeCmd creates a command for deleting a datatype.
func (d MysqlDatabase) DeleteDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, id types.DatatypeID) DeleteDatatypeCmdMysql {
	return DeleteDatatypeCmdMysql{ctx: ctx, auditCtx: auditCtx, id: id, conn: d.Connection, recorder: MysqlRecorder}
}

// ----- PostgreSQL CREATE -----

// NewDatatypeCmdPsql is an audited command for creating datatypes in PostgreSQL.
type NewDatatypeCmdPsql struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	params   CreateDatatypeParams
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c NewDatatypeCmdPsql) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c NewDatatypeCmdPsql) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c NewDatatypeCmdPsql) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c NewDatatypeCmdPsql) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c NewDatatypeCmdPsql) TableName() string { return "datatypes" }

// Params returns the parameters for this command.
func (c NewDatatypeCmdPsql) Params() any { return c.params }

// GetID extracts the ID from a datatype record.
func (c NewDatatypeCmdPsql) GetID(u mdbp.Datatypes) string { return string(u.DatatypeID) }

// Execute creates the datatype in the database.
func (c NewDatatypeCmdPsql) Execute(ctx context.Context, tx audited.DBTX) (mdbp.Datatypes, error) {
	id := c.params.DatatypeID
	if id.IsZero() {
		id = types.NewDatatypeID()
	}
	queries := mdbp.New(tx)
	return queries.CreateDatatype(ctx, mdbp.CreateDatatypeParams{
		DatatypeID:   id,
		ParentID:     c.params.ParentID,
		Label:        c.params.Label,
		Type:         c.params.Type,
		AuthorID:     c.params.AuthorID,
		DateCreated:  c.params.DateCreated,
		DateModified: c.params.DateModified,
	})
}

// NewDatatypeCmd creates a command for inserting a datatype.
func (d PsqlDatabase) NewDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, params CreateDatatypeParams) NewDatatypeCmdPsql {
	return NewDatatypeCmdPsql{ctx: ctx, auditCtx: auditCtx, params: params, conn: d.Connection, recorder: PsqlRecorder}
}

// ----- PostgreSQL UPDATE -----

// UpdateDatatypeCmdPsql is an audited command for updating datatypes in PostgreSQL.
type UpdateDatatypeCmdPsql struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	params   UpdateDatatypeParams
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c UpdateDatatypeCmdPsql) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c UpdateDatatypeCmdPsql) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c UpdateDatatypeCmdPsql) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c UpdateDatatypeCmdPsql) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c UpdateDatatypeCmdPsql) TableName() string { return "datatypes" }

// Params returns the parameters for this command.
func (c UpdateDatatypeCmdPsql) Params() any { return c.params }

// GetID returns the datatype ID for this command.
func (c UpdateDatatypeCmdPsql) GetID() string { return string(c.params.DatatypeID) }

// GetBefore retrieves the datatype before the update.
func (c UpdateDatatypeCmdPsql) GetBefore(ctx context.Context, tx audited.DBTX) (mdbp.Datatypes, error) {
	queries := mdbp.New(tx)
	return queries.GetDatatype(ctx, mdbp.GetDatatypeParams{DatatypeID: c.params.DatatypeID})
}

// Execute updates the datatype in the database.
func (c UpdateDatatypeCmdPsql) Execute(ctx context.Context, tx audited.DBTX) error {
	queries := mdbp.New(tx)
	return queries.UpdateDatatype(ctx, mdbp.UpdateDatatypeParams{
		ParentID:     c.params.ParentID,
		Label:        c.params.Label,
		Type:         c.params.Type,
		AuthorID:     c.params.AuthorID,
		DateCreated:  c.params.DateCreated,
		DateModified: c.params.DateModified,
		DatatypeID:   c.params.DatatypeID,
	})
}

// UpdateDatatypeCmd creates a command for updating a datatype.
func (d PsqlDatabase) UpdateDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, params UpdateDatatypeParams) UpdateDatatypeCmdPsql {
	return UpdateDatatypeCmdPsql{ctx: ctx, auditCtx: auditCtx, params: params, conn: d.Connection, recorder: PsqlRecorder}
}

// ----- PostgreSQL DELETE -----

// DeleteDatatypeCmdPsql is an audited command for deleting datatypes in PostgreSQL.
type DeleteDatatypeCmdPsql struct {
	ctx      context.Context
	auditCtx audited.AuditContext
	id       types.DatatypeID
	conn     *sql.DB
	recorder audited.ChangeEventRecorder
}

// Context returns the command context.
func (c DeleteDatatypeCmdPsql) Context() context.Context { return c.ctx }

// AuditContext returns the audit context.
func (c DeleteDatatypeCmdPsql) AuditContext() audited.AuditContext { return c.auditCtx }

// Connection returns the database connection.
func (c DeleteDatatypeCmdPsql) Connection() *sql.DB { return c.conn }

// Recorder returns the change event recorder.
func (c DeleteDatatypeCmdPsql) Recorder() audited.ChangeEventRecorder { return c.recorder }

// TableName returns the table name for this command.
func (c DeleteDatatypeCmdPsql) TableName() string { return "datatypes" }

// GetID returns the datatype ID for this command.
func (c DeleteDatatypeCmdPsql) GetID() string { return string(c.id) }

// GetBefore retrieves the datatype before the delete.
func (c DeleteDatatypeCmdPsql) GetBefore(ctx context.Context, tx audited.DBTX) (mdbp.Datatypes, error) {
	queries := mdbp.New(tx)
	return queries.GetDatatype(ctx, mdbp.GetDatatypeParams{DatatypeID: c.id})
}

// Execute deletes the datatype from the database.
func (c DeleteDatatypeCmdPsql) Execute(ctx context.Context, tx audited.DBTX) error {
	queries := mdbp.New(tx)
	return queries.DeleteDatatype(ctx, mdbp.DeleteDatatypeParams{DatatypeID: c.id})
}

// DeleteDatatypeCmd creates a command for deleting a datatype.
func (d PsqlDatabase) DeleteDatatypeCmd(ctx context.Context, auditCtx audited.AuditContext, id types.DatatypeID) DeleteDatatypeCmdPsql {
	return DeleteDatatypeCmdPsql{ctx: ctx, auditCtx: auditCtx, id: id, conn: d.Connection, recorder: PsqlRecorder}
}
