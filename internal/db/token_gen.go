// Code generated by tools/dbgen; DO NOT EDIT.
package db

import (
	"fmt"

	mdbm "github.com/hegner123/modulacms/internal/db-mysql"
	mdbp "github.com/hegner123/modulacms/internal/db-psql"
	mdb "github.com/hegner123/modulacms/internal/db-sqlite"
	"github.com/hegner123/modulacms/internal/db/types"
)

///////////////////////////////
// STRUCTS
//////////////////////////////

// Tokens represents a token record in the database.
type Tokens struct {
	ID        string               `json:"id"`
	UserID    types.NullableUserID `json:"user_id"`
	TokenType string               `json:"token_type"`
	Token     string               `json:"token"`
	IssuedAt  string               `json:"issued_at"`
	ExpiresAt types.Timestamp      `json:"expires_at"`
	Revoked   bool                 `json:"revoked"`
}

// CreateTokenParams contains parameters for creating a new token.
type CreateTokenParams struct {
	UserID    types.NullableUserID `json:"user_id"`
	TokenType string               `json:"token_type"`
	Token     string               `json:"token"`
	IssuedAt  string               `json:"issued_at"`
	ExpiresAt types.Timestamp      `json:"expires_at"`
	Revoked   bool                 `json:"revoked"`
}

// UpdateTokenParams contains parameters for updating an existing token.
type UpdateTokenParams struct {
	Token     string          `json:"token"`
	IssuedAt  string          `json:"issued_at"`
	ExpiresAt types.Timestamp `json:"expires_at"`
	Revoked   bool            `json:"revoked"`
	ID        string          `json:"id"`
}

// MapStringToken converts Tokens to StringTokens for TUI display.
func MapStringToken(a Tokens) StringTokens {
	return StringTokens{
		ID:        a.ID,
		UserID:    a.UserID.String(),
		TokenType: a.TokenType,
		Token:     a.Token,
		IssuedAt:  a.IssuedAt,
		ExpiresAt: a.ExpiresAt.String(),
		Revoked:   fmt.Sprintf("%t", a.Revoked),
	}
}

///////////////////////////////
// SQLITE
//////////////////////////////

// QUERIES

// CountTokens returns the total number of tokens in the database.
func (d Database) CountTokens() (*int64, error) {
	queries := mdb.New(d.Connection)
	c, err := queries.CountToken(d.Context)
	if err != nil {
		return nil, fmt.Errorf("%v", err)
	}
	return &c, nil
}

// CreateTokenTable creates the tokens table in the database.
func (d Database) CreateTokenTable() error {
	queries := mdb.New(d.Connection)
	err := queries.CreateTokenTable(d.Context)
	return err
}

// GetToken retrieves a token by ID.
func (d Database) GetToken(id string) (*Tokens, error) {
	queries := mdb.New(d.Connection)
	row, err := queries.GetToken(d.Context, mdb.GetTokenParams{ID: id})
	if err != nil {
		return nil, err
	}
	res := d.MapToken(row)
	return &res, nil
}

// ListTokens retrieves all tokens in the database.
func (d Database) ListTokens() (*[]Tokens, error) {
	queries := mdb.New(d.Connection)
	rows, err := queries.ListToken(d.Context)
	if err != nil {
		return nil, fmt.Errorf("failed to get Tokens: %v\n", err)
	}
	res := []Tokens{}
	for _, v := range rows {
		m := d.MapToken(v)
		res = append(res, m)
	}
	return &res, nil
}

// GetTokenByTokenValue retrieves a token by tokenValue.
func (d Database) GetTokenByTokenValue(tokenValue string) (*Tokens, error) {
	queries := mdb.New(d.Connection)
	row, err := queries.GetTokenByTokenValue(d.Context, mdb.GetTokenByTokenValueParams{Tokens: tokenValue})
	if err != nil {
		return nil, err
	}
	res := d.MapToken(row)
	return &res, nil
}

// GetTokenByUserId retrieves tokens by userID.
func (d Database) GetTokenByUserId(userID types.NullableUserID) (*[]Tokens, error) {
	queries := mdb.New(d.Connection)
	rows, err := queries.GetTokenByUserId(d.Context, mdb.GetTokenByUserIdParams{UserID: userID})
	if err != nil {
		return nil, fmt.Errorf("failed to get Tokens by userID: %v\n", err)
	}
	res := []Tokens{}
	for _, v := range rows {
		m := d.MapToken(v)
		res = append(res, m)
	}
	return &res, nil
}

///////////////////////////////
// MYSQL
//////////////////////////////

// QUERIES

// CountTokens returns the total number of tokens in the database.
func (d MysqlDatabase) CountTokens() (*int64, error) {
	queries := mdbm.New(d.Connection)
	c, err := queries.CountToken(d.Context)
	if err != nil {
		return nil, fmt.Errorf("%v", err)
	}
	return &c, nil
}

// CreateTokenTable creates the tokens table in the database.
func (d MysqlDatabase) CreateTokenTable() error {
	queries := mdbm.New(d.Connection)
	err := queries.CreateTokenTable(d.Context)
	return err
}

// GetToken retrieves a token by ID.
func (d MysqlDatabase) GetToken(id string) (*Tokens, error) {
	queries := mdbm.New(d.Connection)
	row, err := queries.GetToken(d.Context, mdbm.GetTokenParams{ID: id})
	if err != nil {
		return nil, err
	}
	res := d.MapToken(row)
	return &res, nil
}

// ListTokens retrieves all tokens in the database.
func (d MysqlDatabase) ListTokens() (*[]Tokens, error) {
	queries := mdbm.New(d.Connection)
	rows, err := queries.ListToken(d.Context)
	if err != nil {
		return nil, fmt.Errorf("failed to get Tokens: %v\n", err)
	}
	res := []Tokens{}
	for _, v := range rows {
		m := d.MapToken(v)
		res = append(res, m)
	}
	return &res, nil
}

// GetTokenByTokenValue retrieves a token by tokenValue.
func (d MysqlDatabase) GetTokenByTokenValue(tokenValue string) (*Tokens, error) {
	queries := mdbm.New(d.Connection)
	row, err := queries.GetTokenByTokenValue(d.Context, mdbm.GetTokenByTokenValueParams{Tokens: tokenValue})
	if err != nil {
		return nil, err
	}
	res := d.MapToken(row)
	return &res, nil
}

// GetTokenByUserId retrieves tokens by userID.
func (d MysqlDatabase) GetTokenByUserId(userID types.NullableUserID) (*[]Tokens, error) {
	queries := mdbm.New(d.Connection)
	rows, err := queries.GetTokenByUserId(d.Context, mdbm.GetTokenByUserIdParams{UserID: userID})
	if err != nil {
		return nil, fmt.Errorf("failed to get Tokens by userID: %v\n", err)
	}
	res := []Tokens{}
	for _, v := range rows {
		m := d.MapToken(v)
		res = append(res, m)
	}
	return &res, nil
}

///////////////////////////////
// POSTGRES
//////////////////////////////

// QUERIES

// CountTokens returns the total number of tokens in the database.
func (d PsqlDatabase) CountTokens() (*int64, error) {
	queries := mdbp.New(d.Connection)
	c, err := queries.CountToken(d.Context)
	if err != nil {
		return nil, fmt.Errorf("%v", err)
	}
	return &c, nil
}

// CreateTokenTable creates the tokens table in the database.
func (d PsqlDatabase) CreateTokenTable() error {
	queries := mdbp.New(d.Connection)
	err := queries.CreateTokenTable(d.Context)
	return err
}

// GetToken retrieves a token by ID.
func (d PsqlDatabase) GetToken(id string) (*Tokens, error) {
	queries := mdbp.New(d.Connection)
	row, err := queries.GetToken(d.Context, mdbp.GetTokenParams{ID: id})
	if err != nil {
		return nil, err
	}
	res := d.MapToken(row)
	return &res, nil
}

// ListTokens retrieves all tokens in the database.
func (d PsqlDatabase) ListTokens() (*[]Tokens, error) {
	queries := mdbp.New(d.Connection)
	rows, err := queries.ListToken(d.Context)
	if err != nil {
		return nil, fmt.Errorf("failed to get Tokens: %v\n", err)
	}
	res := []Tokens{}
	for _, v := range rows {
		m := d.MapToken(v)
		res = append(res, m)
	}
	return &res, nil
}

// GetTokenByTokenValue retrieves a token by tokenValue.
func (d PsqlDatabase) GetTokenByTokenValue(tokenValue string) (*Tokens, error) {
	queries := mdbp.New(d.Connection)
	row, err := queries.GetTokenByTokenValue(d.Context, mdbp.GetTokenByTokenValueParams{Tokens: tokenValue})
	if err != nil {
		return nil, err
	}
	res := d.MapToken(row)
	return &res, nil
}

// GetTokenByUserId retrieves tokens by userID.
func (d PsqlDatabase) GetTokenByUserId(userID types.NullableUserID) (*[]Tokens, error) {
	queries := mdbp.New(d.Connection)
	rows, err := queries.GetTokenByUserId(d.Context, mdbp.GetTokenByUserIdParams{UserID: userID})
	if err != nil {
		return nil, fmt.Errorf("failed to get Tokens by userID: %v\n", err)
	}
	res := []Tokens{}
	for _, v := range rows {
		m := d.MapToken(v)
		res = append(res, m)
	}
	return &res, nil
}
