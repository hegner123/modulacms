package plugin

import (
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"strings"

	"github.com/hegner123/modulacms/internal/middleware"
	"github.com/hegner123/modulacms/internal/utility"
	lua "github.com/yuin/gopher-lua"
)

// PluginErrorResponse is the top-level JSON envelope for all HTTP error
// responses generated by the plugin bridge. Plugin consumers are external
// developers who need machine-readable errors, so every error uses this
// schema rather than plain text.
type PluginErrorResponse struct {
	Error PluginErrorDetail `json:"error"`
}

// PluginErrorDetail contains the code, message, and optional request ID
// for correlation with server-side logs.
type PluginErrorDetail struct {
	Code      string `json:"code"`
	Message   string `json:"message"`
	RequestID string `json:"request_id,omitempty"`
}

// LuaRequest represents the Go-side structure of an HTTP request before
// conversion to a Lua table. It is not directly passed to Lua; BuildLuaRequest
// handles the conversion. This type exists for documentation and testing clarity.
type LuaRequest struct {
	Method   string
	Path     string
	Body     string
	ClientIP string            // proxy-aware IP, no port
	Headers  map[string]string // lowercase keys
	Query    map[string]string
	Params   map[string]string // path params from {id} via r.PathValue()
	JSON     any               // parsed JSON body when Content-Type is application/json
}

// LuaResponse represents the Go-side structure of a Lua handler's response
// table after conversion from Lua values. WriteLuaResponse reads the Lua table
// directly rather than constructing this struct, but the type documents the
// expected shape.
type LuaResponse struct {
	Status  int
	Headers map[string]string
	Body    string
	JSON    any
}

// blockedResponseHeaders cannot be set by Lua plugins. This prevents CORS
// bypass, session fixation, response smuggling, and cache poisoning.
var blockedResponseHeaders = map[string]bool{
	"access-control-allow-origin":      true,
	"access-control-allow-credentials": true,
	"access-control-allow-methods":     true,
	"access-control-allow-headers":     true,
	"access-control-expose-headers":    true,
	"set-cookie":                       true,
	"transfer-encoding":               true,
	"content-length":                  true,
	"host":                            true,
	"connection":                      true,
	"cache-control":                   true,
}

// writePluginError writes a JSON error response using the PluginErrorResponse
// schema. The requestID is extracted from context by the caller and passed in.
// HANDLER_ERROR responses should use a generic message for clients; the full
// Lua error is logged server-side with the request ID for operator correlation.
func writePluginError(w http.ResponseWriter, status int, code string, message string, requestID string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)

	resp := PluginErrorResponse{
		Error: PluginErrorDetail{
			Code:      code,
			Message:   message,
			RequestID: requestID,
		},
	}

	// Encoding errors here are best-effort; the status code and Content-Type
	// are already written. If encoding fails, the client gets an empty body
	// with the correct status code, which is still useful.
	encErr := json.NewEncoder(w).Encode(resp)
	if encErr != nil {
		utility.DefaultLogger.Warn("failed to encode plugin error response", encErr)
	}
}

// BuildLuaRequest converts an *http.Request into a Lua table suitable for
// passing to a plugin handler function. The clientIP parameter is the
// proxy-aware IP extracted by extractClientIP (no port).
//
// The returned table has these fields:
//   - method (string)
//   - path (string) -- r.URL.Path
//   - body (string) -- raw body bytes as string, always set regardless of Content-Type
//   - client_ip (string) -- the provided clientIP parameter
//   - headers (table) -- all request headers, keys normalized to lowercase
//   - query (table) -- r.URL.Query() flattened (first value per key)
//   - params (table) -- path parameters extracted from r.Pattern via r.PathValue()
//   - json -- parsed JSON body ONLY when Content-Type starts with "application/json"
//
// Returns nil and an error if the body cannot be read (e.g., *http.MaxBytesError
// from body size enforcement). The caller is responsible for writing a 400 response.
func BuildLuaRequest(L *lua.LState, r *http.Request, clientIP string) (*lua.LTable, error) {
	tbl := L.NewTable()

	// method
	tbl.RawSetString("method", lua.LString(r.Method))

	// path
	tbl.RawSetString("path", lua.LString(r.URL.Path))

	// client_ip
	tbl.RawSetString("client_ip", lua.LString(clientIP))

	// body -- always read, regardless of Content-Type
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		// Check for MaxBytesError to signal body-too-large to the caller.
		// The caller decides the HTTP status and error code.
		return nil, fmt.Errorf("reading request body: %w", err)
	}
	bodyStr := string(bodyBytes)
	tbl.RawSetString("body", lua.LString(bodyStr))

	// headers -- all request headers, keys normalized to lowercase
	headersTbl := L.NewTable()
	for name, values := range r.Header {
		if len(values) > 0 {
			headersTbl.RawSetString(strings.ToLower(name), lua.LString(values[0]))
		}
	}
	tbl.RawSetString("headers", headersTbl)

	// query -- r.URL.Query() flattened (first value per key)
	queryTbl := L.NewTable()
	for key, values := range r.URL.Query() {
		if len(values) > 0 {
			queryTbl.RawSetString(key, lua.LString(values[0]))
		}
	}
	tbl.RawSetString("query", queryTbl)

	// params -- path parameters from Go 1.22+ ServeMux pattern matching.
	// Extract {param} names from r.Pattern and call r.PathValue() for each.
	paramsTbl := L.NewTable()
	paramNames := extractPatternParams(r.Pattern)
	for _, name := range paramNames {
		val := r.PathValue(name)
		if val != "" {
			paramsTbl.RawSetString(name, lua.LString(val))
		}
	}
	tbl.RawSetString("params", paramsTbl)

	// json -- parsed ONLY when Content-Type starts with "application/json"
	// (case-insensitive, charset parameters ignored)
	contentType := r.Header.Get("Content-Type")
	if strings.HasPrefix(strings.ToLower(contentType), "application/json") && len(bodyStr) > 0 {
		var parsed any
		if jsonErr := json.Unmarshal([]byte(bodyStr), &parsed); jsonErr != nil {
			// Malformed JSON: set json to nil, body still contains the raw string.
			// The caller can check this and return 400 INVALID_REQUEST if desired,
			// but per error convention, the body is still available for inspection.
			tbl.RawSetString("json", lua.LNil)
		} else {
			tbl.RawSetString("json", goValueToLua(L, parsed))
		}
	} else {
		tbl.RawSetString("json", lua.LNil)
	}

	return tbl, nil
}

// extractPatternParams extracts parameter names from a Go 1.22+ ServeMux
// pattern. For example, "GET /api/v1/plugins/task_tracker/tasks/{id}" yields
// ["id"]. This uses string scanning (no regex).
func extractPatternParams(pattern string) []string {
	var params []string
	rest := pattern
	for {
		openIdx := strings.Index(rest, "{")
		if openIdx == -1 {
			break
		}
		closeIdx := strings.Index(rest[openIdx:], "}")
		if closeIdx == -1 {
			break
		}
		name := rest[openIdx+1 : openIdx+closeIdx]
		// Handle wildcard params like {id...} by stripping trailing "..."
		name = strings.TrimSuffix(name, "...")
		if name != "" {
			params = append(params, name)
		}
		rest = rest[openIdx+closeIdx+1:]
	}
	return params
}

// goValueToLua recursively converts Go values to Lua values. This is used
// for JSON-parsed request bodies where json.Unmarshal produces float64 for
// numbers, []any for arrays, and map[string]any for objects.
//
// This is distinct from the package-level GoValueToLua in lua_helpers.go
// because it handles the specific type set produced by encoding/json:
//   - nil -> LNil
//   - bool -> LBool
//   - float64 -> LNumber (JSON numbers)
//   - string -> LString
//   - []any -> LTable (array)
//   - map[string]any -> LTable
//   - int, int32, int64 -> LNumber (defensive; not produced by json.Unmarshal)
func goValueToLua(L *lua.LState, val any) lua.LValue {
	if val == nil {
		return lua.LNil
	}

	switch v := val.(type) {
	case bool:
		return lua.LBool(v)
	case float64:
		return lua.LNumber(v)
	case string:
		return lua.LString(v)
	case []any:
		tbl := L.NewTable()
		for _, item := range v {
			tbl.Append(goValueToLua(L, item))
		}
		return tbl
	case map[string]any:
		tbl := L.NewTable()
		for k, item := range v {
			tbl.RawSetString(k, goValueToLua(L, item))
		}
		return tbl
	case int:
		return lua.LNumber(v)
	case int32:
		return lua.LNumber(v)
	case int64:
		return lua.LNumber(v)
	default:
		return lua.LNil
	}
}

// WriteLuaResponse reads a Lua response table and writes the HTTP response.
// The response table is expected to have:
//   - status (number, default 200)
//   - headers (table, optional)
//   - body (string, optional)
//   - json (any, optional -- takes priority over body if both present)
//
// It enforces response size limits, filters blocked headers, and sets default
// security headers. Returns an error if the response exceeds maxRespSize.
func WriteLuaResponse(w http.ResponseWriter, L *lua.LState, responseTbl *lua.LTable, maxRespSize int64, requestID string) error {
	// Read status (default 200).
	status := 200
	statusVal := L.GetField(responseTbl, "status")
	if num, ok := statusVal.(lua.LNumber); ok {
		status = int(num)
	}

	// Read optional headers table.
	var pluginHeaders map[string]string
	headersVal := L.GetField(responseTbl, "headers")
	if headersTbl, ok := headersVal.(*lua.LTable); ok {
		pluginHeaders = make(map[string]string)
		headersTbl.ForEach(func(key, value lua.LValue) {
			if k, ok := key.(lua.LString); ok {
				if v, ok := value.(lua.LString); ok {
					pluginHeaders[string(k)] = string(v)
				}
			}
		})
	}

	// Read body and json fields.
	bodyVal := L.GetField(responseTbl, "body")
	jsonVal := L.GetField(responseTbl, "json")

	hasBody := bodyVal != lua.LNil && bodyVal.Type() == lua.LTString
	hasJSON := jsonVal != lua.LNil

	// Determine the response bytes.
	var responseBytes []byte
	isJSON := false

	if hasJSON {
		if hasBody {
			utility.DefaultLogger.Warn("plugin handler returned both body and json; using json", nil)
		}
		// Use the package-level LuaValueToGo from lua_helpers.go for Lua->Go
		// conversion. This reuses the existing, tested conversion logic rather
		// than duplicating it.
		goVal := LuaValueToGo(jsonVal)
		marshaled, marshalErr := json.Marshal(goVal)
		if marshalErr != nil {
			writePluginError(w, http.StatusInternalServerError, "HANDLER_ERROR", "internal plugin error", requestID)
			return fmt.Errorf("marshaling json response: %w", marshalErr)
		}
		responseBytes = marshaled
		isJSON = true
	} else if hasBody {
		responseBytes = []byte(bodyVal.String())
	}

	// Enforce response size limit.
	if maxRespSize > 0 && int64(len(responseBytes)) > maxRespSize {
		writePluginError(w, http.StatusInternalServerError, "RESPONSE_TOO_LARGE",
			"response body exceeds size limit", requestID)
		return fmt.Errorf("response size %d exceeds limit %d", len(responseBytes), maxRespSize)
	}

	// Set default security headers BEFORE plugin headers. These are always
	// present and cannot be overridden by plugins (Cache-Control is in
	// blockedResponseHeaders).
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.Header().Set("X-Frame-Options", "DENY")
	w.Header().Set("Cache-Control", "no-store")

	// Write plugin headers, filtering blocked ones.
	for k, v := range pluginHeaders {
		lowerKey := strings.ToLower(k)
		if blockedResponseHeaders[lowerKey] {
			utility.DefaultLogger.Warn(
				fmt.Sprintf("plugin attempted to set blocked response header %q, skipping", k), nil)
			continue
		}
		w.Header().Set(k, v)
	}

	// Set Content-Type for JSON responses.
	if isJSON {
		w.Header().Set("Content-Type", "application/json")
	}

	// Write status and body.
	w.WriteHeader(status)
	if len(responseBytes) > 0 {
		_, writeErr := w.Write(responseBytes)
		if writeErr != nil {
			return fmt.Errorf("writing response body: %w", writeErr)
		}
	}

	return nil
}

// extractClientIP extracts the real client IP address using a proxy-aware
// algorithm. This is a NEW function (not a reuse of middleware.getIP) because
// the existing getIP blindly trusts X-Forwarded-For, which allows spoofing.
//
// Behavior:
//   - If trustedProxies is empty/nil: use r.RemoteAddr only, strip port.
//     X-Forwarded-For and X-Real-IP are completely ignored. This is the safe
//     default for deployments without a reverse proxy.
//   - If trustedProxies is set: parse X-Forwarded-For from right to left,
//     skip entries matching trusted proxy CIDRs, return the first non-trusted
//     IP. This prevents spoofing because the rightmost entry is set by the
//     closest proxy.
//
// Always strips the port from the returned IP string.
func extractClientIP(r *http.Request, trustedProxies []*net.IPNet) string {
	if len(trustedProxies) == 0 {
		// No trusted proxies: use RemoteAddr only, ignore all headers.
		return stripPort(r.RemoteAddr)
	}

	// Parse X-Forwarded-For header, iterate from right to left.
	xff := r.Header.Get("X-Forwarded-For")
	if xff != "" {
		parts := strings.Split(xff, ",")
		// Iterate from right to left. The rightmost entry is set by the
		// closest proxy (most trustworthy position).
		for i := len(parts) - 1; i >= 0; i-- {
			candidate := strings.TrimSpace(parts[i])
			candidate = stripPort(candidate)

			ip := net.ParseIP(candidate)
			if ip == nil {
				continue
			}

			if !isIPTrusted(ip, trustedProxies) {
				return candidate
			}
		}
	}

	// All XFF entries are trusted (or XFF is empty/absent): fall back to RemoteAddr.
	return stripPort(r.RemoteAddr)
}

// stripPort removes the port from an address string. Handles both IPv4
// ("192.168.1.1:8080" -> "192.168.1.1") and IPv6 ("[::1]:8080" -> "::1").
// If no port is present, returns the address as-is.
func stripPort(addr string) string {
	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		// No port present, or unparseable. Return as-is, which covers
		// bare IPs like "192.168.1.1" or "::1".
		return addr
	}
	return host
}

// isIPTrusted checks whether an IP falls within any of the trusted proxy CIDRs.
func isIPTrusted(ip net.IP, trustedProxies []*net.IPNet) bool {
	for _, cidr := range trustedProxies {
		if cidr.Contains(ip) {
			return true
		}
	}
	return false
}

// RequestIDFromContext is a convenience re-export of middleware.RequestIDFromContext
// for use within the plugin package. This avoids importing the middleware package
// in every file that needs the request ID.
func RequestIDFromContext(r *http.Request) string {
	return middleware.RequestIDFromContext(r.Context())
}
