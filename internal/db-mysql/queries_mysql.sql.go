// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries_mysql.sql

package mdbm

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"
	"time"
)

const checkAdminParentExists = `-- name: CheckAdminParentExists :one
SELECT EXISTS(SELECT 1 FROM admin_datatypes WHERE admin_datatype_id =?)
`

func (q *Queries) CheckAdminParentExists(ctx context.Context, adminDatatypeID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAdminParentExists, adminDatatypeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAdminRouteExists = `-- name: CheckAdminRouteExists :one
SELECT EXISTS(SELECT 1 FROM admin_routes WHERE admin_route_id=?)
`

func (q *Queries) CheckAdminRouteExists(ctx context.Context, adminRouteID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAdminRouteExists, adminRouteID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAuthorExists = `-- name: CheckAuthorExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE username=?)
`

func (q *Queries) CheckAuthorExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAuthorExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAuthorIdExists = `-- name: CheckAuthorIdExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE user_id=?)
`

func (q *Queries) CheckAuthorIdExists(ctx context.Context, userID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAuthorIdExists, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkParentExists = `-- name: CheckParentExists :one
SELECT EXISTS(SELECT 1 FROM datatypes WHERE datatype_id =?)
`

func (q *Queries) CheckParentExists(ctx context.Context, datatypeID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkParentExists, datatypeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkRouteExists = `-- name: CheckRouteExists :one
SELECT EXISTS(SELECT 1 FROM routes WHERE route_id=?)
`

func (q *Queries) CheckRouteExists(ctx context.Context, routeID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkRouteExists, routeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAdminContentData = `-- name: CountAdminContentData :one
SELECT COUNT(*)
FROM admin_content_data
`

func (q *Queries) CountAdminContentData(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminContentData)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminContentField = `-- name: CountAdminContentField :one
SELECT COUNT(*)
FROM admin_content_fields
`

func (q *Queries) CountAdminContentField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminContentField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminDatatype = `-- name: CountAdminDatatype :one
SELECT COUNT(*)
FROM admin_datatypes
`

func (q *Queries) CountAdminDatatype(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminDatatype)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminDatatypeField = `-- name: CountAdminDatatypeField :one
SELECT COUNT(*)
FROM admin_datatypes_fields
`

func (q *Queries) CountAdminDatatypeField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminDatatypeField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminField = `-- name: CountAdminField :one
SELECT COUNT(*) FROM admin_fields
`

func (q *Queries) CountAdminField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminroute = `-- name: CountAdminroute :one
SELECT COUNT(*) FROM admin_routes
`

func (q *Queries) CountAdminroute(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminroute)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChangeEvents = `-- name: CountChangeEvents :one
SELECT COUNT(*) FROM change_events
`

func (q *Queries) CountChangeEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChangeEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChangeEventsByRecord = `-- name: CountChangeEventsByRecord :one
SELECT COUNT(*) FROM change_events
WHERE table_name = ? AND record_id = ?
`

type CountChangeEventsByRecordParams struct {
	TableName string `json:"table_name"`
	RecordID  string `json:"record_id"`
}

func (q *Queries) CountChangeEventsByRecord(ctx context.Context, arg CountChangeEventsByRecordParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChangeEventsByRecord, arg.TableName, arg.RecordID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContentData = `-- name: CountContentData :one
SELECT COUNT(*)
FROM content_data
`

func (q *Queries) CountContentData(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContentData)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContentField = `-- name: CountContentField :one
SELECT COUNT(*)
FROM content_fields
`

func (q *Queries) CountContentField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContentField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDatatype = `-- name: CountDatatype :one
SELECT COUNT(*)
FROM datatypes
`

func (q *Queries) CountDatatype(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDatatype)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDatatypeField = `-- name: CountDatatypeField :one
SELECT COUNT(*)
FROM datatypes_fields
`

func (q *Queries) CountDatatypeField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDatatypeField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countField = `-- name: CountField :one
SELECT COUNT(*)
FROM fields
`

func (q *Queries) CountField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*)
FROM media
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMediaDimension = `-- name: CountMediaDimension :one
SELECT COUNT(*)
FROM media_dimensions
`

func (q *Queries) CountMediaDimension(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMediaDimension)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPermission = `-- name: CountPermission :one
SELECT COUNT(*)
FROM permissions
`

func (q *Queries) CountPermission(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPermission)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRole = `-- name: CountRole :one
SELECT COUNT(*)
FROM roles
`

func (q *Queries) CountRole(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRole)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRoute = `-- name: CountRoute :one
SELECT COUNT(*) 
FROM routes
`

func (q *Queries) CountRoute(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRoute)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSession = `-- name: CountSession :one
SELECT COUNT(*)
FROM sessions
`

func (q *Queries) CountSession(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSession)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTables = `-- name: CountTables :one
SELECT COUNT(*)
FROM tables
`

func (q *Queries) CountTables(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTables)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countToken = `-- name: CountToken :one
SELECT COUNT(*)
FROM tokens
`

func (q *Queries) CountToken(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countToken)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUser = `-- name: CountUser :one
SELECT COUNT(*)
FROM users
`

func (q *Queries) CountUser(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUser)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserOauths = `-- name: CountUserOauths :one
SELECT COUNT(*)
FROM user_oauth
`

func (q *Queries) CountUserOauths(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserOauths)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserSshKeys = `-- name: CountUserSshKeys :one
SELECT COUNT(*) FROM user_ssh_keys
`

func (q *Queries) CountUserSshKeys(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserSshKeys)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAdminContentData = `-- name: CreateAdminContentData :exec
INSERT INTO admin_content_data (
    parent_id,
    admin_route_id,
    admin_datatype_id,
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateAdminContentDataParams struct {
	ParentID        sql.NullInt32  `json:"parent_id"`
	AdminRouteID    int32          `json:"admin_route_id"`
	AdminDatatypeID int32          `json:"admin_datatype_id"`
	AuthorID        int32          `json:"author_id"`
	DateCreated     time.Time      `json:"date_created"`
	DateModified    time.Time      `json:"date_modified"`
	History         sql.NullString `json:"history"`
}

func (q *Queries) CreateAdminContentData(ctx context.Context, arg CreateAdminContentDataParams) error {
	_, err := q.db.ExecContext(ctx, createAdminContentData,
		arg.ParentID,
		arg.AdminRouteID,
		arg.AdminDatatypeID,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	return err
}

const createAdminContentDataTable = `-- name: CreateAdminContentDataTable :exec
CREATE TABLE IF NOT EXISTS admin_content_data (
    admin_content_data_id INT AUTO_INCREMENT
        PRIMARY KEY,
    parent_id INT NULL,
    first_child_id INT NULL,
    next_sibling_id INT NULL,
    prev_sibling_id INT NULL,
    admin_route_id INT NOT NULL,
    admin_datatype_id INT NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    history TEXT NULL,
    CONSTRAINT fk_admin_content_data_parent_id
        FOREIGN KEY (parent_id) REFERENCES admin_content_data (admin_content_data_id)
             ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_content_data_first_child_id
        FOREIGN KEY (first_child_id) REFERENCES admin_content_data (admin_content_data_id)
             ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_content_data_next_sibling_id
        FOREIGN KEY (next_sibling_id) REFERENCES admin_content_data (admin_content_data_id)
             ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_content_data_prev_sibling_id
        FOREIGN KEY (prev_sibling_id) REFERENCES admin_content_data (admin_content_data_id)
             ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_content_data_admin_datatypes
        FOREIGN KEY (admin_datatype_id) REFERENCES admin_datatypes (admin_datatype_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_content_data_admin_route_id
        FOREIGN KEY (admin_route_id) REFERENCES admin_routes (admin_route_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_content_data_author_users_user_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateAdminContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminContentDataTable)
	return err
}

const createAdminContentField = `-- name: CreateAdminContentField :exec
INSERT INTO admin_content_fields (
    admin_route_id,
    admin_content_data_id,
    admin_field_id,
    admin_field_value, 
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateAdminContentFieldParams struct {
	AdminRouteID       sql.NullInt32  `json:"admin_route_id"`
	AdminContentDataID int32          `json:"admin_content_data_id"`
	AdminFieldID       int32          `json:"admin_field_id"`
	AdminFieldValue    string         `json:"admin_field_value"`
	AuthorID           int32          `json:"author_id"`
	DateCreated        time.Time      `json:"date_created"`
	DateModified       time.Time      `json:"date_modified"`
	History            sql.NullString `json:"history"`
}

func (q *Queries) CreateAdminContentField(ctx context.Context, arg CreateAdminContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, createAdminContentField,
		arg.AdminRouteID,
		arg.AdminContentDataID,
		arg.AdminFieldID,
		arg.AdminFieldValue,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	return err
}

const createAdminContentFieldTable = `-- name: CreateAdminContentFieldTable :exec
CREATE TABLE IF NOT EXISTS admin_content_fields (
    admin_content_field_id INT AUTO_INCREMENT
        PRIMARY KEY,
    admin_route_id INT NULL,
    admin_content_data_id INT NOT NULL,
    admin_field_id INT NOT NULL,
    admin_field_value TEXT NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    history TEXT NULL,
    CONSTRAINT fk_admin_content_field_admin_content_data
        FOREIGN KEY (admin_content_data_id) REFERENCES admin_content_data (admin_content_data_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_content_field_admin_route_id
        FOREIGN KEY (admin_route_id) REFERENCES admin_routes (admin_route_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_admin_content_field_fields
        FOREIGN KEY (admin_field_id) REFERENCES admin_fields (admin_field_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_admin_content_field_author_users_user_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateAdminContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminContentFieldTable)
	return err
}

const createAdminDatatype = `-- name: CreateAdminDatatype :exec
INSERT INTO admin_datatypes (
    parent_id,
    label,
    type,
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateAdminDatatypeParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Type         string         `json:"type"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateAdminDatatype(ctx context.Context, arg CreateAdminDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, createAdminDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	return err
}

const createAdminDatatypeField = `-- name: CreateAdminDatatypeField :exec
INSERT INTO admin_datatypes_fields (
    admin_datatype_id,
    admin_field_id
) VALUES (
    ?,
    ?
)
`

type CreateAdminDatatypeFieldParams struct {
	AdminDatatypeID int32 `json:"admin_datatype_id"`
	AdminFieldID    int32 `json:"admin_field_id"`
}

func (q *Queries) CreateAdminDatatypeField(ctx context.Context, arg CreateAdminDatatypeFieldParams) error {
	_, err := q.db.ExecContext(ctx, createAdminDatatypeField, arg.AdminDatatypeID, arg.AdminFieldID)
	return err
}

const createAdminDatatypeTable = `-- name: CreateAdminDatatypeTable :exec
CREATE TABLE IF NOT EXISTS admin_datatypes (
    admin_datatype_id INT AUTO_INCREMENT
        PRIMARY KEY,
    parent_id INT NULL,
    label TEXT NOT NULL,
    type TEXT NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    history TEXT NULL,
    CONSTRAINT fk_admin_datatypes_author_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE,
    CONSTRAINT fk_admin_datatypes_parent_id
        FOREIGN KEY (parent_id) REFERENCES admin_datatypes (admin_datatype_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateAdminDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminDatatypeTable)
	return err
}

const createAdminDatatypesFieldsTable = `-- name: CreateAdminDatatypesFieldsTable :exec
CREATE TABLE IF NOT EXISTS admin_datatypes_fields (
    id INT NOT NULL
        PRIMARY KEY,
    admin_datatype_id INT NOT NULL,
    admin_field_id INT NOT NULL,
    CONSTRAINT fk_df_admin_datatype
        FOREIGN KEY (admin_datatype_id) REFERENCES admin_datatypes (admin_datatype_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_df_admin_field
        FOREIGN KEY (admin_field_id) REFERENCES admin_fields (admin_field_id)
            ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateAdminDatatypesFieldsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminDatatypesFieldsTable)
	return err
}

const createAdminField = `-- name: CreateAdminField :exec
INSERT INTO admin_fields (    
    parent_id,
    label,
    data,
    type,
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateAdminFieldParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateAdminField(ctx context.Context, arg CreateAdminFieldParams) error {
	_, err := q.db.ExecContext(ctx, createAdminField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	return err
}

const createAdminFieldTable = `-- name: CreateAdminFieldTable :exec
CREATE TABLE IF NOT EXISTS admin_fields (
    admin_field_id INT AUTO_INCREMENT
        PRIMARY KEY,
    parent_id INT NULL,
    label VARCHAR(255) DEFAULT 'unlabeled' NOT NULL,
    data TEXT NOT NULL,
    type VARCHAR(255) DEFAULT 'text' NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    history TEXT NULL,
    CONSTRAINT fk_admin_fields_admin_datatypes
        FOREIGN KEY (parent_id) REFERENCES admin_datatypes (admin_datatype_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_admin_fields_users_user_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateAdminFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminFieldTable)
	return err
}

const createAdminRoute = `-- name: CreateAdminRoute :exec
INSERT INTO admin_routes (
    slug,
    title,
    status,
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateAdminRouteParams struct {
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	Status       int32          `json:"status"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateAdminRoute(ctx context.Context, arg CreateAdminRouteParams) error {
	_, err := q.db.ExecContext(ctx, createAdminRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	return err
}

const createAdminRouteTable = `-- name: CreateAdminRouteTable :exec
CREATE TABLE admin_routes (
    admin_route_id INT AUTO_INCREMENT
        PRIMARY KEY,
    slug VARCHAR(255) NOT NULL,
    title VARCHAR(255) NOT NULL,
    status INT NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL ON UPDATE CURRENT_TIMESTAMP(),
    history TEXT NULL,
    CONSTRAINT slug
        UNIQUE (slug),
    CONSTRAINT fk_admin_routes_users_user_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateAdminRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminRouteTable)
	return err
}

const createChangeEventsTable = `-- name: CreateChangeEventsTable :exec
CREATE TABLE IF NOT EXISTS change_events (
    event_id CHAR(26) PRIMARY KEY,
    hlc_timestamp BIGINT NOT NULL,
    wall_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    node_id CHAR(26) NOT NULL,
    table_name VARCHAR(64) NOT NULL,
    record_id CHAR(26) NOT NULL,
    operation VARCHAR(20) NOT NULL,
    action VARCHAR(20),
    user_id CHAR(26),
    old_values JSON,
    new_values JSON,
    metadata JSON,
    synced_at TIMESTAMP NULL,
    consumed_at TIMESTAMP NULL,
    CONSTRAINT chk_operation CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE'))
)
`

func (q *Queries) CreateChangeEventsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createChangeEventsTable)
	return err
}

const createContentData = `-- name: CreateContentData :exec
INSERT INTO content_data (
    route_id,
    parent_id,
    first_child_id,
    next_sibling_id,
    prev_sibling_id,
    datatype_id,
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateContentDataParams struct {
	RouteID       sql.NullInt32  `json:"route_id"`
	ParentID      sql.NullInt32  `json:"parent_id"`
	FirstChildID  sql.NullInt32  `json:"first_child_id"`
	NextSiblingID sql.NullInt32  `json:"next_sibling_id"`
	PrevSiblingID sql.NullInt32  `json:"prev_sibling_id"`
	DatatypeID    sql.NullInt32  `json:"datatype_id"`
	AuthorID      int32          `json:"author_id"`
	DateCreated   time.Time      `json:"date_created"`
	DateModified  time.Time      `json:"date_modified"`
	History       sql.NullString `json:"history"`
}

func (q *Queries) CreateContentData(ctx context.Context, arg CreateContentDataParams) error {
	_, err := q.db.ExecContext(ctx, createContentData,
		arg.RouteID,
		arg.ParentID,
		arg.FirstChildID,
		arg.NextSiblingID,
		arg.PrevSiblingID,
		arg.DatatypeID,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	return err
}

const createContentDataTable = `-- name: CreateContentDataTable :exec
CREATE TABLE IF NOT EXISTS content_data (
    content_data_id INT AUTO_INCREMENT
        PRIMARY KEY,
    parent_id INT NULL,
    first_child_id INT NULL,
    next_sibling_id INT NULL,
    prev_sibling_id  INT NULL,
    route_id INT NULL,
    datatype_id INT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    history TEXT NULL,
    CONSTRAINT fk_content_data_datatypes
        FOREIGN KEY (datatype_id) REFERENCES datatypes (datatype_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_content_data_parent_id
        FOREIGN KEY (parent_id) REFERENCES content_data (content_data_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_content_data_first_child_id
        FOREIGN KEY (first_child_id) REFERENCES content_data (content_data_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_content_data_next_sibling_id
        FOREIGN KEY (next_sibling_id) REFERENCES content_data (content_data_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_content_data_prev_sibling_id
        FOREIGN KEY (prev_sibling_id) REFERENCES content_data (content_data_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_content_data_route_id
        FOREIGN KEY (route_id) REFERENCES routes (route_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_content_data_users_author_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createContentDataTable)
	return err
}

const createContentField = `-- name: CreateContentField :exec
INSERT INTO content_fields (
    route_id,
    content_data_id,
    field_id,
    field_value, 
    author_id,
    history
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateContentFieldParams struct {
	RouteID       sql.NullInt32  `json:"route_id"`
	ContentDataID int32          `json:"content_data_id"`
	FieldID       int32          `json:"field_id"`
	FieldValue    string         `json:"field_value"`
	AuthorID      int32          `json:"author_id"`
	History       sql.NullString `json:"history"`
}

func (q *Queries) CreateContentField(ctx context.Context, arg CreateContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, createContentField,
		arg.RouteID,
		arg.ContentDataID,
		arg.FieldID,
		arg.FieldValue,
		arg.AuthorID,
		arg.History,
	)
	return err
}

const createContentFieldTable = `-- name: CreateContentFieldTable :exec
CREATE TABLE content_fields (
    content_field_id INT AUTO_INCREMENT
        PRIMARY KEY,
    route_id INT NULL,
    content_data_id INT NOT NULL,
    field_id INT NOT NULL,
    field_value TEXT NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    history TEXT NULL,
    CONSTRAINT fk_content_field_content_data
        FOREIGN KEY (content_data_id) REFERENCES content_data (content_data_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_content_field_fields
        FOREIGN KEY (field_id) REFERENCES fields (field_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_content_field_route_id
        FOREIGN KEY (route_id) REFERENCES routes (route_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_content_field_users_author_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createContentFieldTable)
	return err
}

const createDatatype = `-- name: CreateDatatype :exec
INSERT INTO datatypes (    
    parent_id,
    label,
    type,
    author_id,
    history
    ) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
    )
`

type CreateDatatypeParams struct {
	ParentID sql.NullInt32  `json:"parent_id"`
	Label    string         `json:"label"`
	Type     string         `json:"type"`
	AuthorID int32          `json:"author_id"`
	History  sql.NullString `json:"history"`
}

func (q *Queries) CreateDatatype(ctx context.Context, arg CreateDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, createDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.AuthorID,
		arg.History,
	)
	return err
}

const createDatatypeField = `-- name: CreateDatatypeField :exec
INSERT INTO datatypes_fields (
    datatype_id,
    field_id
) VALUES (
    ?,
    ?
)
`

type CreateDatatypeFieldParams struct {
	DatatypeID int32 `json:"datatype_id"`
	FieldID    int32 `json:"field_id"`
}

func (q *Queries) CreateDatatypeField(ctx context.Context, arg CreateDatatypeFieldParams) error {
	_, err := q.db.ExecContext(ctx, createDatatypeField, arg.DatatypeID, arg.FieldID)
	return err
}

const createDatatypeTable = `-- name: CreateDatatypeTable :exec
CREATE TABLE IF NOT EXISTS datatypes (
    datatype_id INT AUTO_INCREMENT
        PRIMARY KEY,
    parent_id INT NULL,
    label TEXT NOT NULL,
    type TEXT NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    history TEXT NULL,
    CONSTRAINT fk_dt_datatypes_parent
        FOREIGN KEY (parent_id) REFERENCES datatypes (datatype_id)
            ON UPDATE CASCADE,
    CONSTRAINT fk_dt_users_author_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createDatatypeTable)
	return err
}

const createDatatypesFieldsTable = `-- name: CreateDatatypesFieldsTable :exec
CREATE TABLE IF NOT EXISTS datatypes_fields (
    id INT NOT NULL
        PRIMARY KEY,
    datatype_id INT NOT NULL,
    field_id INT NOT NULL,
    CONSTRAINT fk_df_datatype
        FOREIGN KEY (datatype_id) REFERENCES datatypes (datatype_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_df_field
        FOREIGN KEY (field_id) REFERENCES fields (field_id)
            ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateDatatypesFieldsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createDatatypesFieldsTable)
	return err
}

const createField = `-- name: CreateField :exec
INSERT INTO fields  (    
    parent_id,
    label,
    data,
    type,
    author_id,
    date_created,
    date_modified,
    history
    ) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateFieldParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateField(ctx context.Context, arg CreateFieldParams) error {
	_, err := q.db.ExecContext(ctx, createField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	return err
}

const createFieldTable = `-- name: CreateFieldTable :exec
CREATE TABLE IF NOT EXISTS fields (
    field_id INT AUTO_INCREMENT
        PRIMARY KEY,
    parent_id INT NULL,
    label VARCHAR(255) DEFAULT 'unlabeled' NOT NULL,
    data TEXT NOT NULL,
    type TEXT NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    history TEXT NULL,
    CONSTRAINT fk_fields_datatypes
        FOREIGN KEY (parent_id) REFERENCES datatypes (datatype_id)
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT fk_fields_users_author_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createFieldTable)
	return err
}

const createMedia = `-- name: CreateMedia :exec
INSERT INTO media (
    name,
    display_name,
    alt,
    caption,
    description,
    class,
    url,
    mimetype,
    dimensions,
    srcset,
    author_id,
    date_created,
    date_modified
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateMediaParams struct {
	Name         sql.NullString `json:"name"`
	DisplayName  sql.NullString `json:"display_name"`
	Alt          sql.NullString `json:"alt"`
	Caption      sql.NullString `json:"caption"`
	Description  sql.NullString `json:"description"`
	Class        sql.NullString `json:"class"`
	Url          sql.NullString `json:"url"`
	Mimetype     sql.NullString `json:"mimetype"`
	Dimensions   sql.NullString `json:"dimensions"`
	Srcset       sql.NullString `json:"srcset"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) error {
	_, err := q.db.ExecContext(ctx, createMedia,
		arg.Name,
		arg.DisplayName,
		arg.Alt,
		arg.Caption,
		arg.Description,
		arg.Class,
		arg.Url,
		arg.Mimetype,
		arg.Dimensions,
		arg.Srcset,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	return err
}

const createMediaDimension = `-- name: CreateMediaDimension :exec
INSERT INTO media_dimensions(
    label,
    width,
    height,
    aspect_ratio
) VALUES (
    ?,
    ?,
    ?,
    ?
)
`

type CreateMediaDimensionParams struct {
	Label       sql.NullString `json:"label"`
	Width       sql.NullInt32  `json:"width"`
	Height      sql.NullInt32  `json:"height"`
	AspectRatio sql.NullString `json:"aspect_ratio"`
}

func (q *Queries) CreateMediaDimension(ctx context.Context, arg CreateMediaDimensionParams) error {
	_, err := q.db.ExecContext(ctx, createMediaDimension,
		arg.Label,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
	)
	return err
}

const createMediaDimensionTable = `-- name: CreateMediaDimensionTable :exec
CREATE TABLE IF NOT EXISTS media_dimensions (
    md_id INT AUTO_INCREMENT
        PRIMARY KEY,
    label VARCHAR(255) NULL,
    width INT NULL,
    height INT NULL,
    aspect_ratio TEXT NULL,
    CONSTRAINT label
        UNIQUE (label)
    )
`

func (q *Queries) CreateMediaDimensionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createMediaDimensionTable)
	return err
}

const createMediaTable = `-- name: CreateMediaTable :exec
CREATE TABLE IF NOT EXISTS media (
    media_id INT AUTO_INCREMENT
        PRIMARY KEY,
    name TEXT NULL,
    display_name TEXT NULL,
    alt TEXT NULL,
    caption TEXT NULL,
    description TEXT NULL,
    class TEXT NULL,
    mimetype TEXT NULL,
    dimensions TEXT NULL,
    url VARCHAR(255) NULL,
    srcset TEXT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT url
        UNIQUE (url),
    CONSTRAINT fk_media_users_author_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateMediaTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createMediaTable)
	return err
}

const createPermission = `-- name: CreatePermission :exec
INSERT INTO permissions(
    table_id,
    mode,
    label
) VALUES (
    ?,
    ?,
    ?
)
`

type CreatePermissionParams struct {
	TableID int32  `json:"table_id"`
	Mode    int32  `json:"mode"`
	Label   string `json:"label"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) error {
	_, err := q.db.ExecContext(ctx, createPermission, arg.TableID, arg.Mode, arg.Label)
	return err
}

const createPermissionTable = `-- name: CreatePermissionTable :exec
CREATE TABLE IF NOT EXISTS permissions (
    permission_id INT AUTO_INCREMENT
        PRIMARY KEY,
    table_id INT NOT NULL,
    mode INT NOT NULL,
    label VARCHAR(255) NOT NULL
)
`

func (q *Queries) CreatePermissionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createPermissionTable)
	return err
}

const createRole = `-- name: CreateRole :exec
INSERT INTO roles (label, permissions) VALUES (?,?)
`

type CreateRoleParams struct {
	Label       string         `json:"label"`
	Permissions sql.NullString `json:"permissions"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) error {
	_, err := q.db.ExecContext(ctx, createRole, arg.Label, arg.Permissions)
	return err
}

const createRoleTable = `-- name: CreateRoleTable :exec
CREATE TABLE IF NOT EXISTS roles (
    role_id INT AUTO_INCREMENT
        PRIMARY KEY,
    label VARCHAR(255) NOT NULL,
    permissions LONGTEXT COLLATE utf8mb4_bin NULL
        CHECK (JSON_VALID(` + "`" + `permissions` + "`" + `)),
    CONSTRAINT label
        UNIQUE (label)
)
`

func (q *Queries) CreateRoleTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createRoleTable)
	return err
}

const createRoute = `-- name: CreateRoute :exec
INSERT INTO routes (
    slug,
    title,
    status,
    author_id,
    date_created,
    date_modified,
    history
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
 )
`

type CreateRouteParams struct {
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	Status       int32          `json:"status"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	History      sql.NullString `json:"history"`
}

func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) error {
	_, err := q.db.ExecContext(ctx, createRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
	)
	return err
}

const createRouteTable = `-- name: CreateRouteTable :exec
CREATE TABLE IF NOT EXISTS routes (
    route_id INT AUTO_INCREMENT
        PRIMARY KEY,
    slug VARCHAR(255) NOT NULL,
    title VARCHAR(255) NOT NULL,
    status INT NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    history TEXT NULL,
    CONSTRAINT unique_slug
        UNIQUE (slug),
    CONSTRAINT fk_routes_routes_author_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createRouteTable)
	return err
}

const createSession = `-- name: CreateSession :exec
INSERT INTO sessions (
    user_id,
    created_at,
    expires_at,
    last_access,
    ip_address,
    user_agent,
    session_data
) VALUES( 
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateSessionParams struct {
	UserID      int32          `json:"user_id"`
	CreatedAt   time.Time      `json:"created_at"`
	ExpiresAt   time.Time      `json:"expires_at"`
	LastAccess  time.Time      `json:"last_access"`
	IpAddress   sql.NullString `json:"ip_address"`
	UserAgent   sql.NullString `json:"user_agent"`
	SessionData sql.NullString `json:"session_data"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastAccess,
		arg.IpAddress,
		arg.UserAgent,
		arg.SessionData,
	)
	return err
}

const createSessionTable = `-- name: CreateSessionTable :exec
CREATE TABLE sessions (
    session_id INT AUTO_INCREMENT
        PRIMARY KEY,
    user_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    expires_at TIMESTAMP DEFAULT '0000-00-00 00:00:00' NOT NULL,
    last_access TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    ip_address VARCHAR(45) NULL,
    user_agent TEXT NULL,
    session_data TEXT NULL,
    CONSTRAINT fk_sessions_user_id
        FOREIGN KEY (user_id) REFERENCES users (user_id)
            ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateSessionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createSessionTable)
	return err
}

const createTable = `-- name: CreateTable :exec
INSERT INTO tables (
    label
) VALUES (
    ?
)
`

func (q *Queries) CreateTable(ctx context.Context, label string) error {
	_, err := q.db.ExecContext(ctx, createTable, label)
	return err
}

const createTablesTable = `-- name: CreateTablesTable :exec
CREATE TABLE IF NOT EXISTS tables (
    id INT AUTO_INCREMENT
        PRIMARY KEY,
    label VARCHAR(255) NOT NULL,
    author_id INT DEFAULT 1 NOT NULL,
    CONSTRAINT label
        UNIQUE (label),
    CONSTRAINT fk_tables_author_id
        FOREIGN KEY (author_id) REFERENCES users (user_id)
            ON UPDATE CASCADE
)
`

func (q *Queries) CreateTablesTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTablesTable)
	return err
}

const createToken = `-- name: CreateToken :exec
INSERT INTO tokens (
    user_id,
    token_type,
    token,
    issued_at,
    expires_at,
    revoked
) VALUES( 
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateTokenParams struct {
	UserID    int32     `json:"user_id"`
	TokenType string    `json:"token_type"`
	Token     string    `json:"token"`
	IssuedAt  time.Time `json:"issued_at"`
	ExpiresAt time.Time `json:"expires_at"`
	Revoked   bool      `json:"revoked"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) error {
	_, err := q.db.ExecContext(ctx, createToken,
		arg.UserID,
		arg.TokenType,
		arg.Token,
		arg.IssuedAt,
		arg.ExpiresAt,
		arg.Revoked,
	)
	return err
}

const createTokenTable = `-- name: CreateTokenTable :exec
CREATE TABLE IF NOT EXISTS tokens (
    id INT AUTO_INCREMENT
        PRIMARY KEY,
    user_id INT NOT NULL,
    token_type VARCHAR(255) NOT NULL,
    token VARCHAR(255) NOT NULL,
    issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP,
    expires_at TIMESTAMP DEFAULT '0000-00-00 00:00:00' NOT NULL,
    revoked TINYINT(1) DEFAULT 0 NOT NULL,
    CONSTRAINT token
        UNIQUE (token),
    CONSTRAINT fk_tokens_users
        FOREIGN KEY (user_id) REFERENCES users (user_id)
            ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateTokenTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTokenTable)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (
    username,
    name,
    email,
    hash,
    role,
    date_created,
    date_modified
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateUserParams struct {
	Username     string    `json:"username"`
	Name         string    `json:"name"`
	Email        string    `json:"email"`
	Hash         string    `json:"hash"`
	Role         int32     `json:"role"`
	DateCreated  time.Time `json:"date_created"`
	DateModified time.Time `json:"date_modified"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.Hash,
		arg.Role,
		arg.DateCreated,
		arg.DateModified,
	)
	return err
}

const createUserOauth = `-- name: CreateUserOauth :exec
INSERT INTO user_oauth (
    user_id,
    oauth_provider,
    oauth_provider_user_id,
    access_token,
    refresh_token,
    token_expires_at,
    date_created
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateUserOauthParams struct {
	UserID              int32     `json:"user_id"`
	OauthProvider       string    `json:"oauth_provider"`
	OauthProviderUserID string    `json:"oauth_provider_user_id"`
	AccessToken         string    `json:"access_token"`
	RefreshToken        string    `json:"refresh_token"`
	TokenExpiresAt      time.Time `json:"token_expires_at"`
	DateCreated         time.Time `json:"date_created"`
}

func (q *Queries) CreateUserOauth(ctx context.Context, arg CreateUserOauthParams) error {
	_, err := q.db.ExecContext(ctx, createUserOauth,
		arg.UserID,
		arg.OauthProvider,
		arg.OauthProviderUserID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenExpiresAt,
		arg.DateCreated,
	)
	return err
}

const createUserOauthTable = `-- name: CreateUserOauthTable :exec
CREATE TABLE IF NOT EXISTS user_oauth (
    user_oauth_id INT AUTO_INCREMENT
        PRIMARY KEY,
    user_id INT NOT NULL,
    oauth_provider VARCHAR(255) NOT NULL,
    oauth_provider_user_id VARCHAR(255) NOT NULL,
    access_token TEXT NOT NULL,
    refresh_token TEXT NOT NULL,
    token_expires_at TIMESTAMP NOT NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT user_oauth_ibfk_1
        FOREIGN KEY (user_id) REFERENCES users (user_id)
            ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateUserOauthTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUserOauthTable)
	return err
}

const createUserSshKey = `-- name: CreateUserSshKey :execresult
INSERT INTO user_ssh_keys (
    user_id,
    public_key,
    key_type,
    fingerprint,
    label,
    date_created
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateUserSshKeyParams struct {
	UserID      int32          `json:"user_id"`
	PublicKey   string         `json:"public_key"`
	KeyType     string         `json:"key_type"`
	Fingerprint string         `json:"fingerprint"`
	Label       sql.NullString `json:"label"`
	DateCreated time.Time      `json:"date_created"`
}

func (q *Queries) CreateUserSshKey(ctx context.Context, arg CreateUserSshKeyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserSshKey,
		arg.UserID,
		arg.PublicKey,
		arg.KeyType,
		arg.Fingerprint,
		arg.Label,
		arg.DateCreated,
	)
}

const createUserSshKeyTable = `-- name: CreateUserSshKeyTable :exec
CREATE TABLE IF NOT EXISTS user_ssh_keys (
    ssh_key_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    public_key TEXT NOT NULL,
    key_type VARCHAR(50) NOT NULL,
    fingerprint VARCHAR(255) NOT NULL UNIQUE,
    label VARCHAR(255),
    date_created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_used TIMESTAMP NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
`

func (q *Queries) CreateUserSshKeyTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUserSshKeyTable)
	return err
}

const createUserTable = `-- name: CreateUserTable :exec
CREATE TABLE IF NOT EXISTS users (
    user_id INT AUTO_INCREMENT
        PRIMARY KEY,
    username VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    hash TEXT NOT NULL,
    role INT NOT NULL DEFAULT 4,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP(),
    CONSTRAINT username
        UNIQUE (username),
    CONSTRAINT fk_users_role
        FOREIGN KEY (role) REFERENCES roles (role_id)
            ON UPDATE CASCADE ON DELETE SET DEFAULT
)
`

func (q *Queries) CreateUserTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUserTable)
	return err
}

const deleteAdminContentData = `-- name: DeleteAdminContentData :exec
DELETE FROM admin_content_data
WHERE admin_content_data_id = ?
`

func (q *Queries) DeleteAdminContentData(ctx context.Context, adminContentDataID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminContentData, adminContentDataID)
	return err
}

const deleteAdminContentField = `-- name: DeleteAdminContentField :exec
DELETE FROM admin_content_fields
WHERE admin_content_field_id = ?
`

func (q *Queries) DeleteAdminContentField(ctx context.Context, adminContentFieldID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminContentField, adminContentFieldID)
	return err
}

const deleteAdminDatatype = `-- name: DeleteAdminDatatype :exec
DELETE FROM admin_datatypes
WHERE admin_datatype_id = ?
`

func (q *Queries) DeleteAdminDatatype(ctx context.Context, adminDatatypeID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminDatatype, adminDatatypeID)
	return err
}

const deleteAdminDatatypeField = `-- name: DeleteAdminDatatypeField :exec
DELETE FROM admin_datatypes_fields
WHERE id = ?
`

func (q *Queries) DeleteAdminDatatypeField(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminDatatypeField, id)
	return err
}

const deleteAdminField = `-- name: DeleteAdminField :exec
DELETE FROM admin_fields
WHERE admin_field_id = ?
`

func (q *Queries) DeleteAdminField(ctx context.Context, adminFieldID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminField, adminFieldID)
	return err
}

const deleteAdminRoute = `-- name: DeleteAdminRoute :exec
DELETE FROM admin_routes
WHERE admin_route_id = ?
`

func (q *Queries) DeleteAdminRoute(ctx context.Context, adminRouteID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdminRoute, adminRouteID)
	return err
}

const deleteChangeEvent = `-- name: DeleteChangeEvent :exec
DELETE FROM change_events
WHERE event_id = ?
`

func (q *Queries) DeleteChangeEvent(ctx context.Context, eventID string) error {
	_, err := q.db.ExecContext(ctx, deleteChangeEvent, eventID)
	return err
}

const deleteChangeEventsOlderThan = `-- name: DeleteChangeEventsOlderThan :exec
DELETE FROM change_events
WHERE wall_timestamp < ?
AND synced_at IS NOT NULL
AND consumed_at IS NOT NULL
`

func (q *Queries) DeleteChangeEventsOlderThan(ctx context.Context, wallTimestamp time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteChangeEventsOlderThan, wallTimestamp)
	return err
}

const deleteContentData = `-- name: DeleteContentData :exec
DELETE FROM content_data
WHERE content_data_id = ?
`

func (q *Queries) DeleteContentData(ctx context.Context, contentDataID int32) error {
	_, err := q.db.ExecContext(ctx, deleteContentData, contentDataID)
	return err
}

const deleteContentField = `-- name: DeleteContentField :exec
DELETE FROM content_fields
WHERE content_field_id = ?
`

func (q *Queries) DeleteContentField(ctx context.Context, contentFieldID int32) error {
	_, err := q.db.ExecContext(ctx, deleteContentField, contentFieldID)
	return err
}

const deleteDatatype = `-- name: DeleteDatatype :exec
DELETE FROM datatypes
WHERE datatype_id = ?
`

func (q *Queries) DeleteDatatype(ctx context.Context, datatypeID int32) error {
	_, err := q.db.ExecContext(ctx, deleteDatatype, datatypeID)
	return err
}

const deleteDatatypeField = `-- name: DeleteDatatypeField :exec
DELETE FROM datatypes_fields
WHERE id = ?
`

func (q *Queries) DeleteDatatypeField(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteDatatypeField, id)
	return err
}

const deleteField = `-- name: DeleteField :exec
DELETE FROM fields 
WHERE field_id = ?
`

func (q *Queries) DeleteField(ctx context.Context, fieldID int32) error {
	_, err := q.db.ExecContext(ctx, deleteField, fieldID)
	return err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media
WHERE media_id = ?
`

func (q *Queries) DeleteMedia(ctx context.Context, mediaID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMedia, mediaID)
	return err
}

const deleteMediaDimension = `-- name: DeleteMediaDimension :exec
DELETE FROM media_dimensions
WHERE md_id = ?
`

func (q *Queries) DeleteMediaDimension(ctx context.Context, mdID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMediaDimension, mdID)
	return err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions 
WHERE permission_id = ?
`

func (q *Queries) DeletePermission(ctx context.Context, permissionID int32) error {
	_, err := q.db.ExecContext(ctx, deletePermission, permissionID)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE role_id = ?
`

func (q *Queries) DeleteRole(ctx context.Context, roleID int32) error {
	_, err := q.db.ExecContext(ctx, deleteRole, roleID)
	return err
}

const deleteRoute = `-- name: DeleteRoute :exec
DELETE FROM routes
WHERE route_id = ?
`

func (q *Queries) DeleteRoute(ctx context.Context, routeID int32) error {
	_, err := q.db.ExecContext(ctx, deleteRoute, routeID)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE session_id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, sessionID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSession, sessionID)
	return err
}

const deleteTable = `-- name: DeleteTable :exec

DELETE FROM tables
WHERE id = ?
`

// If needed, run a separate SELECT to fetch the updated row.
func (q *Queries) DeleteTable(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteTable, id)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM tokens
WHERE id = ?
`

func (q *Queries) DeleteToken(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteToken, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUser, userID)
	return err
}

const deleteUserOauth = `-- name: DeleteUserOauth :exec
DELETE FROM user_oauth
WHERE user_oauth_id = ?
`

func (q *Queries) DeleteUserOauth(ctx context.Context, userOauthID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserOauth, userOauthID)
	return err
}

const deleteUserSshKey = `-- name: DeleteUserSshKey :exec
DELETE FROM user_ssh_keys
WHERE ssh_key_id = ?
`

func (q *Queries) DeleteUserSshKey(ctx context.Context, sshKeyID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserSshKey, sshKeyID)
	return err
}

const dropAdminContentData = `-- name: DropAdminContentData :exec
DROP TABLE admin_content_data
`

func (q *Queries) DropAdminContentData(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminContentData)
	return err
}

const dropAdminContentFieldTable = `-- name: DropAdminContentFieldTable :exec
DROP TABLE admin_content_fields
`

func (q *Queries) DropAdminContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminContentFieldTable)
	return err
}

const dropAdminDatatypeTable = `-- name: DropAdminDatatypeTable :exec
DROP TABLE admin_datatypes
`

func (q *Queries) DropAdminDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminDatatypeTable)
	return err
}

const dropAdminDatatypesFieldsTable = `-- name: DropAdminDatatypesFieldsTable :exec
DROP TABLE admin_datatypes_fields
`

func (q *Queries) DropAdminDatatypesFieldsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminDatatypesFieldsTable)
	return err
}

const dropAdminFieldTable = `-- name: DropAdminFieldTable :exec
DROP TABLE admin_fields
`

func (q *Queries) DropAdminFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminFieldTable)
	return err
}

const dropAdminRouteTable = `-- name: DropAdminRouteTable :exec
DROP TABLE admin_routes
`

func (q *Queries) DropAdminRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminRouteTable)
	return err
}

const dropChangeEventsTable = `-- name: DropChangeEventsTable :exec
DROP TABLE IF EXISTS change_events
`

func (q *Queries) DropChangeEventsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropChangeEventsTable)
	return err
}

const dropContentDataTable = `-- name: DropContentDataTable :exec
DROP TABLE content_data
`

func (q *Queries) DropContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropContentDataTable)
	return err
}

const dropContentFieldTable = `-- name: DropContentFieldTable :exec
DROP TABLE content_fields
`

func (q *Queries) DropContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropContentFieldTable)
	return err
}

const dropDatatypeTable = `-- name: DropDatatypeTable :exec
DROP TABLE datatypes
`

func (q *Queries) DropDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropDatatypeTable)
	return err
}

const dropDatatypesFieldsTable = `-- name: DropDatatypesFieldsTable :exec
DROP TABLE datatypes_fields
`

func (q *Queries) DropDatatypesFieldsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropDatatypesFieldsTable)
	return err
}

const dropFieldTable = `-- name: DropFieldTable :exec
DROP TABLE fields
`

func (q *Queries) DropFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropFieldTable)
	return err
}

const dropMediaDimensionTable = `-- name: DropMediaDimensionTable :exec
DROP TABLE media_dimensions
`

func (q *Queries) DropMediaDimensionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropMediaDimensionTable)
	return err
}

const dropMediaTable = `-- name: DropMediaTable :exec
DROP TABLE media
`

func (q *Queries) DropMediaTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropMediaTable)
	return err
}

const dropPermissionTable = `-- name: DropPermissionTable :exec
DROP TABLE permissions
`

func (q *Queries) DropPermissionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropPermissionTable)
	return err
}

const dropRoleTable = `-- name: DropRoleTable :exec
DROP TABLE roles
`

func (q *Queries) DropRoleTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropRoleTable)
	return err
}

const dropRouteTable = `-- name: DropRouteTable :exec
DROP TABLE routes
`

func (q *Queries) DropRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropRouteTable)
	return err
}

const dropSessionTable = `-- name: DropSessionTable :exec
DROP TABLE sessions
`

func (q *Queries) DropSessionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropSessionTable)
	return err
}

const dropTableTable = `-- name: DropTableTable :exec
DROP TABLE tables
`

func (q *Queries) DropTableTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropTableTable)
	return err
}

const dropTokenTable = `-- name: DropTokenTable :exec
DROP TABLE tokens
`

func (q *Queries) DropTokenTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropTokenTable)
	return err
}

const dropUserOauthTable = `-- name: DropUserOauthTable :exec
DROP TABLE user_oauth
`

func (q *Queries) DropUserOauthTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropUserOauthTable)
	return err
}

const dropUserSshKeyTable = `-- name: DropUserSshKeyTable :exec
DROP TABLE user_ssh_keys
`

func (q *Queries) DropUserSshKeyTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropUserSshKeyTable)
	return err
}

const dropUserTable = `-- name: DropUserTable :exec
DROP TABLE users
`

func (q *Queries) DropUserTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropUserTable)
	return err
}

const getAdminContentData = `-- name: GetAdminContentData :one
SELECT admin_content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, admin_route_id, admin_datatype_id, author_id, date_created, date_modified, history FROM admin_content_data
WHERE admin_content_data_id = ? LIMIT 1
`

func (q *Queries) GetAdminContentData(ctx context.Context, adminContentDataID int32) (AdminContentData, error) {
	row := q.db.QueryRowContext(ctx, getAdminContentData, adminContentDataID)
	var i AdminContentData
	err := row.Scan(
		&i.AdminContentDataID,
		&i.ParentID,
		&i.FirstChildID,
		&i.NextSiblingID,
		&i.PrevSiblingID,
		&i.AdminRouteID,
		&i.AdminDatatypeID,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminContentField = `-- name: GetAdminContentField :one
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, author_id, date_created, date_modified, history FROM admin_content_fields
WHERE admin_content_field_id = ? LIMIT 1
`

func (q *Queries) GetAdminContentField(ctx context.Context, adminContentFieldID int32) (AdminContentFields, error) {
	row := q.db.QueryRowContext(ctx, getAdminContentField, adminContentFieldID)
	var i AdminContentFields
	err := row.Scan(
		&i.AdminContentFieldID,
		&i.AdminRouteID,
		&i.AdminContentDataID,
		&i.AdminFieldID,
		&i.AdminFieldValue,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminDatatype = `-- name: GetAdminDatatype :one
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM admin_datatypes
WHERE admin_datatype_id = ? 
LIMIT 1
`

func (q *Queries) GetAdminDatatype(ctx context.Context, adminDatatypeID int32) (AdminDatatypes, error) {
	row := q.db.QueryRowContext(ctx, getAdminDatatype, adminDatatypeID)
	var i AdminDatatypes
	err := row.Scan(
		&i.AdminDatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminField = `-- name: GetAdminField :one
SELECT admin_field_id, parent_id, label, data, type, author_id, date_created, date_modified, history FROM admin_fields
WHERE admin_field_id = ? LIMIT 1
`

func (q *Queries) GetAdminField(ctx context.Context, adminFieldID int32) (AdminFields, error) {
	row := q.db.QueryRowContext(ctx, getAdminField, adminFieldID)
	var i AdminFields
	err := row.Scan(
		&i.AdminFieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminRouteById = `-- name: GetAdminRouteById :one
SELECT admin_route_id, slug, title, status, author_id, date_created, date_modified, history FROM admin_routes
WHERE admin_route_id = ? LIMIT 1
`

func (q *Queries) GetAdminRouteById(ctx context.Context, adminRouteID int32) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, getAdminRouteById, adminRouteID)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminRouteBySlug = `-- name: GetAdminRouteBySlug :one
SELECT admin_route_id, slug, title, status, author_id, date_created, date_modified, history FROM admin_routes
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetAdminRouteBySlug(ctx context.Context, slug string) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, getAdminRouteBySlug, slug)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getAdminRouteIdBySlug = `-- name: GetAdminRouteIdBySlug :one
SELECT admin_route_id FROM admin_routes
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetAdminRouteIdBySlug(ctx context.Context, slug string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getAdminRouteIdBySlug, slug)
	var admin_route_id int32
	err := row.Scan(&admin_route_id)
	return admin_route_id, err
}

const getChangeEvent = `-- name: GetChangeEvent :one
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
WHERE event_id = ? LIMIT 1
`

func (q *Queries) GetChangeEvent(ctx context.Context, eventID string) (ChangeEvents, error) {
	row := q.db.QueryRowContext(ctx, getChangeEvent, eventID)
	var i ChangeEvents
	err := row.Scan(
		&i.EventID,
		&i.HlcTimestamp,
		&i.WallTimestamp,
		&i.NodeID,
		&i.TableName,
		&i.RecordID,
		&i.Operation,
		&i.Action,
		&i.UserID,
		&i.OldValues,
		&i.NewValues,
		&i.Metadata,
		&i.SyncedAt,
		&i.ConsumedAt,
	)
	return i, err
}

const getChangeEventsByRecord = `-- name: GetChangeEventsByRecord :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
WHERE table_name = ? AND record_id = ?
ORDER BY hlc_timestamp DESC
`

type GetChangeEventsByRecordParams struct {
	TableName string `json:"table_name"`
	RecordID  string `json:"record_id"`
}

func (q *Queries) GetChangeEventsByRecord(ctx context.Context, arg GetChangeEventsByRecordParams) ([]ChangeEvents, error) {
	rows, err := q.db.QueryContext(ctx, getChangeEventsByRecord, arg.TableName, arg.RecordID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeEvents
	for rows.Next() {
		var i ChangeEvents
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangeEventsByRecordPaginated = `-- name: GetChangeEventsByRecordPaginated :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
WHERE table_name = ? AND record_id = ?
ORDER BY hlc_timestamp DESC
LIMIT ? OFFSET ?
`

type GetChangeEventsByRecordPaginatedParams struct {
	TableName string `json:"table_name"`
	RecordID  string `json:"record_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) GetChangeEventsByRecordPaginated(ctx context.Context, arg GetChangeEventsByRecordPaginatedParams) ([]ChangeEvents, error) {
	rows, err := q.db.QueryContext(ctx, getChangeEventsByRecordPaginated,
		arg.TableName,
		arg.RecordID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeEvents
	for rows.Next() {
		var i ChangeEvents
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentData = `-- name: GetContentData :one
SELECT content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, route_id, datatype_id, author_id, date_created, date_modified, history FROM content_data
WHERE content_data_id = ? LIMIT 1
`

func (q *Queries) GetContentData(ctx context.Context, contentDataID int32) (ContentData, error) {
	row := q.db.QueryRowContext(ctx, getContentData, contentDataID)
	var i ContentData
	err := row.Scan(
		&i.ContentDataID,
		&i.ParentID,
		&i.FirstChildID,
		&i.NextSiblingID,
		&i.PrevSiblingID,
		&i.RouteID,
		&i.DatatypeID,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getContentField = `-- name: GetContentField :one
SELECT content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified, history FROM content_fields
WHERE content_field_id = ? LIMIT 1
`

func (q *Queries) GetContentField(ctx context.Context, contentFieldID int32) (ContentFields, error) {
	row := q.db.QueryRowContext(ctx, getContentField, contentFieldID)
	var i ContentFields
	err := row.Scan(
		&i.ContentFieldID,
		&i.RouteID,
		&i.ContentDataID,
		&i.FieldID,
		&i.FieldValue,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getContentFieldsByRoute = `-- name: GetContentFieldsByRoute :many
SELECT cf.content_data_id, cf.field_id, cf.field_value
FROM content_data cd
JOIN content_fields cf ON cd.content_data_id = cf.content_data_id
WHERE cd.route_id = ?
ORDER BY cf.content_data_id, cf.field_id
`

type GetContentFieldsByRouteRow struct {
	ContentDataID int32  `json:"content_data_id"`
	FieldID       int32  `json:"field_id"`
	FieldValue    string `json:"field_value"`
}

func (q *Queries) GetContentFieldsByRoute(ctx context.Context, routeID sql.NullInt32) ([]GetContentFieldsByRouteRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentFieldsByRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContentFieldsByRouteRow
	for rows.Next() {
		var i GetContentFieldsByRouteRow
		if err := rows.Scan(&i.ContentDataID, &i.FieldID, &i.FieldValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentTreeByRoute = `-- name: GetContentTreeByRoute :many
SELECT cd.content_data_id, 
        cd.parent_id, 
        cd.first_child_id,
        cd.next_sibling_id,
        cd.prev_sibling_id,
        cd.datatype_id, 
        cd.route_id, 
        cd.author_id, 
        cd.date_created, 
        cd.date_modified,
       dt.label as datatype_label, dt.type as datatype_type
FROM content_data cd 
JOIN datatypes dt ON cd.datatype_id = dt.datatype_id
WHERE cd.route_id = ?
ORDER BY cd.parent_id IS NULL DESC, cd.parent_id, cd.content_data_id
`

type GetContentTreeByRouteRow struct {
	ContentDataID int32         `json:"content_data_id"`
	ParentID      sql.NullInt32 `json:"parent_id"`
	FirstChildID  sql.NullInt32 `json:"first_child_id"`
	NextSiblingID sql.NullInt32 `json:"next_sibling_id"`
	PrevSiblingID sql.NullInt32 `json:"prev_sibling_id"`
	DatatypeID    sql.NullInt32 `json:"datatype_id"`
	RouteID       sql.NullInt32 `json:"route_id"`
	AuthorID      int32         `json:"author_id"`
	DateCreated   time.Time     `json:"date_created"`
	DateModified  time.Time     `json:"date_modified"`
	DatatypeLabel string        `json:"datatype_label"`
	DatatypeType  string        `json:"datatype_type"`
}

func (q *Queries) GetContentTreeByRoute(ctx context.Context, routeID sql.NullInt32) ([]GetContentTreeByRouteRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentTreeByRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContentTreeByRouteRow
	for rows.Next() {
		var i GetContentTreeByRouteRow
		if err := rows.Scan(
			&i.ContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.DatatypeID,
			&i.RouteID,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.DatatypeLabel,
			&i.DatatypeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatatype = `-- name: GetDatatype :one
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM datatypes
WHERE datatype_id = ? LIMIT 1
`

func (q *Queries) GetDatatype(ctx context.Context, datatypeID int32) (Datatypes, error) {
	row := q.db.QueryRowContext(ctx, getDatatype, datatypeID)
	var i Datatypes
	err := row.Scan(
		&i.DatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getField = `-- name: GetField :one
SELECT field_id, parent_id, label, data, type, author_id, date_created, date_modified, history FROM fields 
WHERE field_id = ? LIMIT 1
`

func (q *Queries) GetField(ctx context.Context, fieldID int32) (Fields, error) {
	row := q.db.QueryRowContext(ctx, getField, fieldID)
	var i Fields
	err := row.Scan(
		&i.FieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getFieldDefinitionsByRoute = `-- name: GetFieldDefinitionsByRoute :many
SELECT DISTINCT f.field_id, f.label, f.type, df.datatype_id
FROM content_data cd
JOIN datatypes_fields df ON cd.datatype_id = df.datatype_id
JOIN fields f ON df.field_id = f.field_id  
WHERE cd.route_id = ?
ORDER BY df.datatype_id, f.field_id
`

type GetFieldDefinitionsByRouteRow struct {
	FieldID    int32  `json:"field_id"`
	Label      string `json:"label"`
	Type       string `json:"type"`
	DatatypeID int32  `json:"datatype_id"`
}

func (q *Queries) GetFieldDefinitionsByRoute(ctx context.Context, routeID sql.NullInt32) ([]GetFieldDefinitionsByRouteRow, error) {
	rows, err := q.db.QueryContext(ctx, getFieldDefinitionsByRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFieldDefinitionsByRouteRow
	for rows.Next() {
		var i GetFieldDefinitionsByRouteRow
		if err := rows.Scan(
			&i.FieldID,
			&i.Label,
			&i.Type,
			&i.DatatypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastAdminContentData = `-- name: GetLastAdminContentData :one
SELECT admin_content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, admin_route_id, admin_datatype_id, author_id, date_created, date_modified, history FROM admin_content_data WHERE content_data_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastAdminContentData(ctx context.Context) (AdminContentData, error) {
	row := q.db.QueryRowContext(ctx, getLastAdminContentData)
	var i AdminContentData
	err := row.Scan(
		&i.AdminContentDataID,
		&i.ParentID,
		&i.FirstChildID,
		&i.NextSiblingID,
		&i.PrevSiblingID,
		&i.AdminRouteID,
		&i.AdminDatatypeID,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastAdminContentField = `-- name: GetLastAdminContentField :one
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, author_id, date_created, date_modified, history FROM admin_content_fields WHERE admin_content_field_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastAdminContentField(ctx context.Context) (AdminContentFields, error) {
	row := q.db.QueryRowContext(ctx, getLastAdminContentField)
	var i AdminContentFields
	err := row.Scan(
		&i.AdminContentFieldID,
		&i.AdminRouteID,
		&i.AdminContentDataID,
		&i.AdminFieldID,
		&i.AdminFieldValue,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastAdminDatatype = `-- name: GetLastAdminDatatype :one
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM admin_datatypes WHERE admin_datatype_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastAdminDatatype(ctx context.Context) (AdminDatatypes, error) {
	row := q.db.QueryRowContext(ctx, getLastAdminDatatype)
	var i AdminDatatypes
	err := row.Scan(
		&i.AdminDatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastAdminDatatypeField = `-- name: GetLastAdminDatatypeField :one
SELECT id, admin_datatype_id, admin_field_id FROM admin_datatypes_fields WHERE id = LAST_INSERT_ID()
`

func (q *Queries) GetLastAdminDatatypeField(ctx context.Context) (AdminDatatypesFields, error) {
	row := q.db.QueryRowContext(ctx, getLastAdminDatatypeField)
	var i AdminDatatypesFields
	err := row.Scan(&i.ID, &i.AdminDatatypeID, &i.AdminFieldID)
	return i, err
}

const getLastAdminField = `-- name: GetLastAdminField :one
SELECT admin_field_id, parent_id, label, data, type, author_id, date_created, date_modified, history FROM admin_fields WHERE admin_field_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastAdminField(ctx context.Context) (AdminFields, error) {
	row := q.db.QueryRowContext(ctx, getLastAdminField)
	var i AdminFields
	err := row.Scan(
		&i.AdminFieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastAdminRoute = `-- name: GetLastAdminRoute :one
SELECT admin_route_id, slug, title, status, author_id, date_created, date_modified, history FROM admin_routes WHERE admin_route_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastAdminRoute(ctx context.Context) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, getLastAdminRoute)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastContentData = `-- name: GetLastContentData :one
SELECT content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, route_id, datatype_id, author_id, date_created, date_modified, history FROM content_data WHERE content_data_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastContentData(ctx context.Context) (ContentData, error) {
	row := q.db.QueryRowContext(ctx, getLastContentData)
	var i ContentData
	err := row.Scan(
		&i.ContentDataID,
		&i.ParentID,
		&i.FirstChildID,
		&i.NextSiblingID,
		&i.PrevSiblingID,
		&i.RouteID,
		&i.DatatypeID,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastContentField = `-- name: GetLastContentField :one
SELECT content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified, history FROM content_fields WHERE content_field_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastContentField(ctx context.Context) (ContentFields, error) {
	row := q.db.QueryRowContext(ctx, getLastContentField)
	var i ContentFields
	err := row.Scan(
		&i.ContentFieldID,
		&i.RouteID,
		&i.ContentDataID,
		&i.FieldID,
		&i.FieldValue,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastDatatype = `-- name: GetLastDatatype :one
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM datatypes WHERE datatype_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastDatatype(ctx context.Context) (Datatypes, error) {
	row := q.db.QueryRowContext(ctx, getLastDatatype)
	var i Datatypes
	err := row.Scan(
		&i.DatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastDatatypeField = `-- name: GetLastDatatypeField :one
SELECT id, datatype_id, field_id FROM datatypes_fields WHERE id = LAST_INSERT_ID()
`

func (q *Queries) GetLastDatatypeField(ctx context.Context) (DatatypesFields, error) {
	row := q.db.QueryRowContext(ctx, getLastDatatypeField)
	var i DatatypesFields
	err := row.Scan(&i.ID, &i.DatatypeID, &i.FieldID)
	return i, err
}

const getLastField = `-- name: GetLastField :one
SELECT field_id, parent_id, label, data, type, author_id, date_created, date_modified, history FROM fields WHERE field_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastField(ctx context.Context) (Fields, error) {
	row := q.db.QueryRowContext(ctx, getLastField)
	var i Fields
	err := row.Scan(
		&i.FieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastMedia = `-- name: GetLastMedia :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media WHERE media_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastMedia(ctx context.Context) (Media, error) {
	row := q.db.QueryRowContext(ctx, getLastMedia)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.Url,
		&i.Srcset,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getLastMediaDimension = `-- name: GetLastMediaDimension :one
SELECT md_id, label, width, height, aspect_ratio FROM media_dimensions WHERE md_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastMediaDimension(ctx context.Context) (MediaDimensions, error) {
	row := q.db.QueryRowContext(ctx, getLastMediaDimension)
	var i MediaDimensions
	err := row.Scan(
		&i.MdID,
		&i.Label,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
	)
	return i, err
}

const getLastPermission = `-- name: GetLastPermission :one
SELECT permission_id, table_id, mode, label FROM permissions WHERE permission_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastPermission(ctx context.Context) (Permissions, error) {
	row := q.db.QueryRowContext(ctx, getLastPermission)
	var i Permissions
	err := row.Scan(
		&i.PermissionID,
		&i.TableID,
		&i.Mode,
		&i.Label,
	)
	return i, err
}

const getLastRole = `-- name: GetLastRole :one
SELECT role_id, label, permissions FROM roles WHERE role_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastRole(ctx context.Context) (Roles, error) {
	row := q.db.QueryRowContext(ctx, getLastRole)
	var i Roles
	err := row.Scan(&i.RoleID, &i.Label, &i.Permissions)
	return i, err
}

const getLastRoute = `-- name: GetLastRoute :one
SELECT route_id, slug, title, status, author_id, date_created, date_modified, history FROM routes WHERE route_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastRoute(ctx context.Context) (Routes, error) {
	row := q.db.QueryRowContext(ctx, getLastRoute)
	var i Routes
	err := row.Scan(
		&i.RouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getLastSession = `-- name: GetLastSession :one
 SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions WHERE session_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastSession(ctx context.Context) (Sessions, error) {
	row := q.db.QueryRowContext(ctx, getLastSession)
	var i Sessions
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccess,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionData,
	)
	return i, err
}

const getLastTable = `-- name: GetLastTable :one
 SELECT id, label, author_id FROM tables WHERE id = LAST_INSERT_ID()
`

func (q *Queries) GetLastTable(ctx context.Context) (Tables, error) {
	row := q.db.QueryRowContext(ctx, getLastTable)
	var i Tables
	err := row.Scan(&i.ID, &i.Label, &i.AuthorID)
	return i, err
}

const getLastToken = `-- name: GetLastToken :one
 SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens WHERE id = LAST_INSERT_ID()
`

func (q *Queries) GetLastToken(ctx context.Context) (Tokens, error) {
	row := q.db.QueryRowContext(ctx, getLastToken)
	var i Tokens
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.Token,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const getLastUser = `-- name: GetLastUser :one
 SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users WHERE user_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastUser(ctx context.Context) (Users, error) {
	row := q.db.QueryRowContext(ctx, getLastUser)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Role,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getLastUserOauth = `-- name: GetLastUserOauth :one
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
WHERE user_oauth_id = LAST_INSERT_ID()
`

func (q *Queries) GetLastUserOauth(ctx context.Context) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getLastUserOauth)
	var i UserOauth
	err := row.Scan(
		&i.UserOauthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OauthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getMedia = `-- name: GetMedia :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media
WHERE media_id = ? LIMIT 1
`

func (q *Queries) GetMedia(ctx context.Context, mediaID int32) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMedia, mediaID)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.Url,
		&i.Srcset,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaByName = `-- name: GetMediaByName :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media
WHERE name = ? LIMIT 1
`

func (q *Queries) GetMediaByName(ctx context.Context, name sql.NullString) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMediaByName, name)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.Url,
		&i.Srcset,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaByUrl = `-- name: GetMediaByUrl :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media
WHERE url = ? LIMIT 1
`

func (q *Queries) GetMediaByUrl(ctx context.Context, url sql.NullString) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMediaByUrl, url)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.Url,
		&i.Srcset,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaDimension = `-- name: GetMediaDimension :one
SELECT md_id, label, width, height, aspect_ratio FROM media_dimensions
WHERE md_id = ? LIMIT 1
`

func (q *Queries) GetMediaDimension(ctx context.Context, mdID int32) (MediaDimensions, error) {
	row := q.db.QueryRowContext(ctx, getMediaDimension, mdID)
	var i MediaDimensions
	err := row.Scan(
		&i.MdID,
		&i.Label,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
	)
	return i, err
}

const getPermission = `-- name: GetPermission :one
SELECT permission_id, table_id, mode, label FROM permissions 
WHERE permission_id = ? LIMIT 1
`

func (q *Queries) GetPermission(ctx context.Context, permissionID int32) (Permissions, error) {
	row := q.db.QueryRowContext(ctx, getPermission, permissionID)
	var i Permissions
	err := row.Scan(
		&i.PermissionID,
		&i.TableID,
		&i.Mode,
		&i.Label,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT role_id, label, permissions FROM roles
WHERE role_id = ? LIMIT 1
`

func (q *Queries) GetRole(ctx context.Context, roleID int32) (Roles, error) {
	row := q.db.QueryRowContext(ctx, getRole, roleID)
	var i Roles
	err := row.Scan(&i.RoleID, &i.Label, &i.Permissions)
	return i, err
}

const getRoute = `-- name: GetRoute :one
SELECT route_id, slug, title, status, author_id, date_created, date_modified, history FROM routes
WHERE route_id = ? 
LIMIT 1
`

func (q *Queries) GetRoute(ctx context.Context, routeID int32) (Routes, error) {
	row := q.db.QueryRowContext(ctx, getRoute, routeID)
	var i Routes
	err := row.Scan(
		&i.RouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
		&i.History,
	)
	return i, err
}

const getRouteIDBySlug = `-- name: GetRouteIDBySlug :one
SELECT route_id 
FROM routes
WHERE slug = ? 
LIMIT 1
`

func (q *Queries) GetRouteIDBySlug(ctx context.Context, slug string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getRouteIDBySlug, slug)
	var route_id int32
	err := row.Scan(&route_id)
	return route_id, err
}

const getRouteTreeByRouteID = `-- name: GetRouteTreeByRouteID :many
SELECT 
    cd.content_data_id,
    cd.parent_id,
    cd.first_child_id,
    cd.next_sibling_id,
    cd.prev_sibling_id,
    dt.label AS datatype_label,
    dt.type AS datatype_type,
    f.label AS field_label,
    f.type AS field_type,
    cf.field_value
FROM content_data cd
    INNER JOIN datatypes dt ON cd.datatype_id = dt.datatype_id
    INNER JOIN datatypes_fields df ON dt.datatype_id = df.datatype_id
    INNER JOIN fields f ON df.field_id = f.field_id
    LEFT JOIN content_fields cf ON cd.content_data_id = cf.content_data_id 
        AND f.field_id = cf.field_id
WHERE cd.route_id = ?
ORDER BY cd.content_data_id, f.field_id
`

type GetRouteTreeByRouteIDRow struct {
	ContentDataID int32          `json:"content_data_id"`
	ParentID      sql.NullInt32  `json:"parent_id"`
	FirstChildID  sql.NullInt32  `json:"first_child_id"`
	NextSiblingID sql.NullInt32  `json:"next_sibling_id"`
	PrevSiblingID sql.NullInt32  `json:"prev_sibling_id"`
	DatatypeLabel string         `json:"datatype_label"`
	DatatypeType  string         `json:"datatype_type"`
	FieldLabel    string         `json:"field_label"`
	FieldType     string         `json:"field_type"`
	FieldValue    sql.NullString `json:"field_value"`
}

func (q *Queries) GetRouteTreeByRouteID(ctx context.Context, routeID sql.NullInt32) ([]GetRouteTreeByRouteIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRouteTreeByRouteID, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRouteTreeByRouteIDRow
	for rows.Next() {
		var i GetRouteTreeByRouteIDRow
		if err := rows.Scan(
			&i.ContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.DatatypeLabel,
			&i.DatatypeType,
			&i.FieldLabel,
			&i.FieldType,
			&i.FieldValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
WHERE session_id = ? LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, sessionID int32) (Sessions, error) {
	row := q.db.QueryRowContext(ctx, getSession, sessionID)
	var i Sessions
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccess,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionData,
	)
	return i, err
}

const getSessionByUserId = `-- name: GetSessionByUserId :one
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
WHERE user_id = ?
ORDER BY session_id DESC
LIMIT 1
`

func (q *Queries) GetSessionByUserId(ctx context.Context, userID int32) (Sessions, error) {
	row := q.db.QueryRowContext(ctx, getSessionByUserId, userID)
	var i Sessions
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccess,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionData,
	)
	return i, err
}

const getTable = `-- name: GetTable :one
SELECT id, label, author_id FROM tables
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetTable(ctx context.Context, id int32) (Tables, error) {
	row := q.db.QueryRowContext(ctx, getTable, id)
	var i Tables
	err := row.Scan(&i.ID, &i.Label, &i.AuthorID)
	return i, err
}

const getTableId = `-- name: GetTableId :one
SELECT id FROM tables
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetTableId(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getTableId, id)
	err := row.Scan(&id)
	return id, err
}

const getToken = `-- name: GetToken :one
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
WHERE id = ? LIMIT 1
`

func (q *Queries) GetToken(ctx context.Context, id int32) (Tokens, error) {
	row := q.db.QueryRowContext(ctx, getToken, id)
	var i Tokens
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.Token,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const getTokenByUserId = `-- name: GetTokenByUserId :many
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
WHERE user_id = ?
`

func (q *Queries) GetTokenByUserId(ctx context.Context, userID int32) ([]Tokens, error) {
	rows, err := q.db.QueryContext(ctx, getTokenByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tokens
	for rows.Next() {
		var i Tokens
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenType,
			&i.Token,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnconsumedEvents = `-- name: GetUnconsumedEvents :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
WHERE consumed_at IS NULL
ORDER BY hlc_timestamp ASC
LIMIT ?
`

func (q *Queries) GetUnconsumedEvents(ctx context.Context, limit int32) ([]ChangeEvents, error) {
	rows, err := q.db.QueryContext(ctx, getUnconsumedEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeEvents
	for rows.Next() {
		var i ChangeEvents
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnsyncedEvents = `-- name: GetUnsyncedEvents :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
WHERE synced_at IS NULL
ORDER BY hlc_timestamp ASC
LIMIT ?
`

func (q *Queries) GetUnsyncedEvents(ctx context.Context, limit int32) ([]ChangeEvents, error) {
	rows, err := q.db.QueryContext(ctx, getUnsyncedEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeEvents
	for rows.Next() {
		var i ChangeEvents
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnsyncedEventsByNode = `-- name: GetUnsyncedEventsByNode :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
WHERE synced_at IS NULL AND node_id = ?
ORDER BY hlc_timestamp ASC
LIMIT ?
`

type GetUnsyncedEventsByNodeParams struct {
	NodeID string `json:"node_id"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetUnsyncedEventsByNode(ctx context.Context, arg GetUnsyncedEventsByNodeParams) ([]ChangeEvents, error) {
	rows, err := q.db.QueryContext(ctx, getUnsyncedEventsByNode, arg.NodeID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeEvents
	for rows.Next() {
		var i ChangeEvents
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users
WHERE user_id = ? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, userID int32) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUser, userID)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Role,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users
WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Role,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getUserBySSHFingerprint = `-- name: GetUserBySSHFingerprint :one
SELECT u.user_id, u.username, u.name, u.email, u.hash, u.role, u.date_created, u.date_modified FROM users u
INNER JOIN user_ssh_keys k ON u.user_id = k.user_id
WHERE k.fingerprint = ?
LIMIT 1
`

func (q *Queries) GetUserBySSHFingerprint(ctx context.Context, fingerprint string) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUserBySSHFingerprint, fingerprint)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Role,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getUserId = `-- name: GetUserId :one
SELECT user_id FROM users
WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserId(ctx context.Context, email string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserId, email)
	var user_id int32
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserOauth = `-- name: GetUserOauth :one
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
WHERE user_oauth_id = ?
LIMIT 1
`

func (q *Queries) GetUserOauth(ctx context.Context, userOauthID int32) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauth, userOauthID)
	var i UserOauth
	err := row.Scan(
		&i.UserOauthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OauthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthByEmail = `-- name: GetUserOauthByEmail :one
SELECT uo.user_oauth_id, uo.user_id, uo.oauth_provider, uo.oauth_provider_user_id, uo.access_token, uo.refresh_token, uo.token_expires_at, uo.date_created
FROM user_oauth uo
JOIN users u ON uo.user_id = u.user_id
WHERE u.email = ?
LIMIT 1
`

func (q *Queries) GetUserOauthByEmail(ctx context.Context, email string) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthByEmail, email)
	var i UserOauth
	err := row.Scan(
		&i.UserOauthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OauthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthByProviderID = `-- name: GetUserOauthByProviderID :one
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
WHERE oauth_provider = ? AND oauth_provider_user_id = ?
LIMIT 1
`

type GetUserOauthByProviderIDParams struct {
	OauthProvider       string `json:"oauth_provider"`
	OauthProviderUserID string `json:"oauth_provider_user_id"`
}

func (q *Queries) GetUserOauthByProviderID(ctx context.Context, arg GetUserOauthByProviderIDParams) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthByProviderID, arg.OauthProvider, arg.OauthProviderUserID)
	var i UserOauth
	err := row.Scan(
		&i.UserOauthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OauthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthByUserId = `-- name: GetUserOauthByUserId :one
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
WHERE user_id = ?
LIMIT 1
`

func (q *Queries) GetUserOauthByUserId(ctx context.Context, userID int32) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthByUserId, userID)
	var i UserOauth
	err := row.Scan(
		&i.UserOauthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OauthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthId = `-- name: GetUserOauthId :one
SELECT uo.user_id
FROM user_oauth uo
JOIN users u ON uo.user_id = u.user_id
WHERE u.email = ?
LIMIT 1
`

func (q *Queries) GetUserOauthId(ctx context.Context, email string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthId, email)
	var user_id int32
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserSshKey = `-- name: GetUserSshKey :one
SELECT ssh_key_id, user_id, public_key, key_type, fingerprint, label, date_created, last_used FROM user_ssh_keys
WHERE ssh_key_id = ?
LIMIT 1
`

func (q *Queries) GetUserSshKey(ctx context.Context, sshKeyID int32) (UserSshKeys, error) {
	row := q.db.QueryRowContext(ctx, getUserSshKey, sshKeyID)
	var i UserSshKeys
	err := row.Scan(
		&i.SshKeyID,
		&i.UserID,
		&i.PublicKey,
		&i.KeyType,
		&i.Fingerprint,
		&i.Label,
		&i.DateCreated,
		&i.LastUsed,
	)
	return i, err
}

const getUserSshKeyByFingerprint = `-- name: GetUserSshKeyByFingerprint :one
SELECT ssh_key_id, user_id, public_key, key_type, fingerprint, label, date_created, last_used FROM user_ssh_keys
WHERE fingerprint = ?
LIMIT 1
`

func (q *Queries) GetUserSshKeyByFingerprint(ctx context.Context, fingerprint string) (UserSshKeys, error) {
	row := q.db.QueryRowContext(ctx, getUserSshKeyByFingerprint, fingerprint)
	var i UserSshKeys
	err := row.Scan(
		&i.SshKeyID,
		&i.UserID,
		&i.PublicKey,
		&i.KeyType,
		&i.Fingerprint,
		&i.Label,
		&i.DateCreated,
		&i.LastUsed,
	)
	return i, err
}

const listAdminContentData = `-- name: ListAdminContentData :many
SELECT admin_content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, admin_route_id, admin_datatype_id, author_id, date_created, date_modified, history FROM admin_content_data
ORDER BY admin_content_data_id
`

func (q *Queries) ListAdminContentData(ctx context.Context) ([]AdminContentData, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminContentData
	for rows.Next() {
		var i AdminContentData
		if err := rows.Scan(
			&i.AdminContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.AdminRouteID,
			&i.AdminDatatypeID,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentDataByRoute = `-- name: ListAdminContentDataByRoute :many
SELECT admin_content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, admin_route_id, admin_datatype_id, author_id, date_created, date_modified, history FROM admin_content_data
WHERE admin_route_id = ?
ORDER BY admin_content_data_id
`

func (q *Queries) ListAdminContentDataByRoute(ctx context.Context, adminRouteID int32) ([]AdminContentData, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentDataByRoute, adminRouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminContentData
	for rows.Next() {
		var i AdminContentData
		if err := rows.Scan(
			&i.AdminContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.AdminRouteID,
			&i.AdminDatatypeID,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentFields = `-- name: ListAdminContentFields :many
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, author_id, date_created, date_modified, history FROM admin_content_fields
ORDER BY admin_content_field_id
`

func (q *Queries) ListAdminContentFields(ctx context.Context) ([]AdminContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminContentFields
	for rows.Next() {
		var i AdminContentFields
		if err := rows.Scan(
			&i.AdminContentFieldID,
			&i.AdminRouteID,
			&i.AdminContentDataID,
			&i.AdminFieldID,
			&i.AdminFieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentFieldsByRoute = `-- name: ListAdminContentFieldsByRoute :many
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, author_id, date_created, date_modified, history FROM admin_content_fields
WHERE admin_route_id = ?
ORDER BY admin_content_field_id
`

func (q *Queries) ListAdminContentFieldsByRoute(ctx context.Context, adminRouteID sql.NullInt32) ([]AdminContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentFieldsByRoute, adminRouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminContentFields
	for rows.Next() {
		var i AdminContentFields
		if err := rows.Scan(
			&i.AdminContentFieldID,
			&i.AdminRouteID,
			&i.AdminContentDataID,
			&i.AdminFieldID,
			&i.AdminFieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatype = `-- name: ListAdminDatatype :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM admin_datatypes
ORDER BY admin_datatype_id
`

func (q *Queries) ListAdminDatatype(ctx context.Context) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypes
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeChildren = `-- name: ListAdminDatatypeChildren :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM admin_datatypes
WHERE parent_id = ?
`

func (q *Queries) ListAdminDatatypeChildren(ctx context.Context, parentID sql.NullInt32) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeChildren, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypes
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeField = `-- name: ListAdminDatatypeField :many
SELECT id, admin_datatype_id, admin_field_id FROM admin_datatypes_fields
ORDER BY id
`

func (q *Queries) ListAdminDatatypeField(ctx context.Context) ([]AdminDatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypesFields
	for rows.Next() {
		var i AdminDatatypesFields
		if err := rows.Scan(&i.ID, &i.AdminDatatypeID, &i.AdminFieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeFieldByDatatypeID = `-- name: ListAdminDatatypeFieldByDatatypeID :many
SELECT id, admin_datatype_id, admin_field_id FROM admin_datatypes_fields
WHERE admin_datatype_id = ?
ORDER BY id
`

func (q *Queries) ListAdminDatatypeFieldByDatatypeID(ctx context.Context, adminDatatypeID int32) ([]AdminDatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeFieldByDatatypeID, adminDatatypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypesFields
	for rows.Next() {
		var i AdminDatatypesFields
		if err := rows.Scan(&i.ID, &i.AdminDatatypeID, &i.AdminFieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeFieldByFieldID = `-- name: ListAdminDatatypeFieldByFieldID :many
SELECT id, admin_datatype_id, admin_field_id FROM admin_datatypes_fields
WHERE admin_field_id = ?
ORDER BY id
`

func (q *Queries) ListAdminDatatypeFieldByFieldID(ctx context.Context, adminFieldID int32) ([]AdminDatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeFieldByFieldID, adminFieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypesFields
	for rows.Next() {
		var i AdminDatatypesFields
		if err := rows.Scan(&i.ID, &i.AdminDatatypeID, &i.AdminFieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeGlobal = `-- name: ListAdminDatatypeGlobal :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM admin_datatypes
WHERE type = 'GLOBAL' LIMIT 1
`

func (q *Queries) ListAdminDatatypeGlobal(ctx context.Context) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeGlobal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypes
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeRoot = `-- name: ListAdminDatatypeRoot :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM admin_datatypes
WHERE type = 'ROOT' LIMIT 1
`

func (q *Queries) ListAdminDatatypeRoot(ctx context.Context) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeRoot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypes
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminField = `-- name: ListAdminField :many
SELECT admin_field_id, parent_id, label, data, type, author_id, date_created, date_modified, history FROM admin_fields
ORDER BY admin_field_id
`

func (q *Queries) ListAdminField(ctx context.Context) ([]AdminFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminFields
	for rows.Next() {
		var i AdminFields
		if err := rows.Scan(
			&i.AdminFieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminFieldByParentID = `-- name: ListAdminFieldByParentID :many
SELECT admin_field_id, parent_id, label, data, type, author_id, date_created, date_modified, history FROM admin_fields
WHERE parent_id = ?
ORDER BY admin_field_id
`

func (q *Queries) ListAdminFieldByParentID(ctx context.Context, parentID sql.NullInt32) ([]AdminFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminFieldByParentID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminFields
	for rows.Next() {
		var i AdminFields
		if err := rows.Scan(
			&i.AdminFieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminRoute = `-- name: ListAdminRoute :many
SELECT admin_route_id, slug, title, status, author_id, date_created, date_modified, history FROM admin_routes
ORDER BY slug
`

func (q *Queries) ListAdminRoute(ctx context.Context) ([]AdminRoutes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminRoute)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminRoutes
	for rows.Next() {
		var i AdminRoutes
		if err := rows.Scan(
			&i.AdminRouteID,
			&i.Slug,
			&i.Title,
			&i.Status,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChangeEvents = `-- name: ListChangeEvents :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
ORDER BY hlc_timestamp DESC
LIMIT ? OFFSET ?
`

type ListChangeEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListChangeEvents(ctx context.Context, arg ListChangeEventsParams) ([]ChangeEvents, error) {
	rows, err := q.db.QueryContext(ctx, listChangeEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeEvents
	for rows.Next() {
		var i ChangeEvents
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChangeEventsByAction = `-- name: ListChangeEventsByAction :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
WHERE action = ?
ORDER BY hlc_timestamp DESC
LIMIT ? OFFSET ?
`

type ListChangeEventsByActionParams struct {
	Action sql.NullString `json:"action"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

func (q *Queries) ListChangeEventsByAction(ctx context.Context, arg ListChangeEventsByActionParams) ([]ChangeEvents, error) {
	rows, err := q.db.QueryContext(ctx, listChangeEventsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeEvents
	for rows.Next() {
		var i ChangeEvents
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChangeEventsByUser = `-- name: ListChangeEventsByUser :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, synced_at, consumed_at FROM change_events
WHERE user_id = ?
ORDER BY hlc_timestamp DESC
LIMIT ? OFFSET ?
`

type ListChangeEventsByUserParams struct {
	UserID sql.NullString `json:"user_id"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

func (q *Queries) ListChangeEventsByUser(ctx context.Context, arg ListChangeEventsByUserParams) ([]ChangeEvents, error) {
	rows, err := q.db.QueryContext(ctx, listChangeEventsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeEvents
	for rows.Next() {
		var i ChangeEvents
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentData = `-- name: ListContentData :many
SELECT content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, route_id, datatype_id, author_id, date_created, date_modified, history FROM content_data
ORDER BY content_data_id
`

func (q *Queries) ListContentData(ctx context.Context) ([]ContentData, error) {
	rows, err := q.db.QueryContext(ctx, listContentData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentData
	for rows.Next() {
		var i ContentData
		if err := rows.Scan(
			&i.ContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.RouteID,
			&i.DatatypeID,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentDataByRoute = `-- name: ListContentDataByRoute :many
SELECT content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, route_id, datatype_id, author_id, date_created, date_modified, history FROM content_data
WHERE route_id = ?
ORDER BY content_data_id
`

func (q *Queries) ListContentDataByRoute(ctx context.Context, routeID sql.NullInt32) ([]ContentData, error) {
	rows, err := q.db.QueryContext(ctx, listContentDataByRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentData
	for rows.Next() {
		var i ContentData
		if err := rows.Scan(
			&i.ContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.RouteID,
			&i.DatatypeID,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentFields = `-- name: ListContentFields :many
SELECT content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified, history FROM content_fields
ORDER BY content_field_id
`

func (q *Queries) ListContentFields(ctx context.Context) ([]ContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listContentFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentFields
	for rows.Next() {
		var i ContentFields
		if err := rows.Scan(
			&i.ContentFieldID,
			&i.RouteID,
			&i.ContentDataID,
			&i.FieldID,
			&i.FieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentFieldsByRoute = `-- name: ListContentFieldsByRoute :many
SELECT content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified, history FROM content_fields
WHERE route_id = ?
ORDER BY content_field_id
`

func (q *Queries) ListContentFieldsByRoute(ctx context.Context, routeID sql.NullInt32) ([]ContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listContentFieldsByRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContentFields
	for rows.Next() {
		var i ContentFields
		if err := rows.Scan(
			&i.ContentFieldID,
			&i.RouteID,
			&i.ContentDataID,
			&i.FieldID,
			&i.FieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatype = `-- name: ListDatatype :many
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM datatypes
ORDER BY datatype_id
`

func (q *Queries) ListDatatype(ctx context.Context) ([]Datatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datatypes
	for rows.Next() {
		var i Datatypes
		if err := rows.Scan(
			&i.DatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeChildren = `-- name: ListDatatypeChildren :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM admin_datatypes
WHERE parent_id = ?
ORDER BY datatype_id
`

func (q *Queries) ListDatatypeChildren(ctx context.Context, parentID sql.NullInt32) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeChildren, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminDatatypes
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeField = `-- name: ListDatatypeField :many
SELECT id, datatype_id, field_id FROM datatypes_fields
ORDER BY id
`

func (q *Queries) ListDatatypeField(ctx context.Context) ([]DatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DatatypesFields
	for rows.Next() {
		var i DatatypesFields
		if err := rows.Scan(&i.ID, &i.DatatypeID, &i.FieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeFieldByDatatypeID = `-- name: ListDatatypeFieldByDatatypeID :many
SELECT id, datatype_id, field_id FROM datatypes_fields
WHERE datatype_id = ?
ORDER BY id
`

func (q *Queries) ListDatatypeFieldByDatatypeID(ctx context.Context, datatypeID int32) ([]DatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeFieldByDatatypeID, datatypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DatatypesFields
	for rows.Next() {
		var i DatatypesFields
		if err := rows.Scan(&i.ID, &i.DatatypeID, &i.FieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeFieldByFieldID = `-- name: ListDatatypeFieldByFieldID :many
SELECT id, datatype_id, field_id FROM datatypes_fields
WHERE field_id = ?
ORDER BY id
`

func (q *Queries) ListDatatypeFieldByFieldID(ctx context.Context, fieldID int32) ([]DatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeFieldByFieldID, fieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DatatypesFields
	for rows.Next() {
		var i DatatypesFields
		if err := rows.Scan(&i.ID, &i.DatatypeID, &i.FieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeGlobal = `-- name: ListDatatypeGlobal :many
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM datatypes
WHERE type = 'GLOBAL'
ORDER BY datatype_id
`

func (q *Queries) ListDatatypeGlobal(ctx context.Context) ([]Datatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeGlobal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datatypes
	for rows.Next() {
		var i Datatypes
		if err := rows.Scan(
			&i.DatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeRoot = `-- name: ListDatatypeRoot :many
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified, history FROM datatypes
WHERE type = 'ROOT'
ORDER BY datatype_id
`

func (q *Queries) ListDatatypeRoot(ctx context.Context) ([]Datatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeRoot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datatypes
	for rows.Next() {
		var i Datatypes
		if err := rows.Scan(
			&i.DatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listField = `-- name: ListField :many
SELECT field_id, parent_id, label, data, type, author_id, date_created, date_modified, history FROM fields 
ORDER BY field_id
`

func (q *Queries) ListField(ctx context.Context) ([]Fields, error) {
	rows, err := q.db.QueryContext(ctx, listField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fields
	for rows.Next() {
		var i Fields
		if err := rows.Scan(
			&i.FieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFieldByDatatypeID = `-- name: ListFieldByDatatypeID :many
SELECT field_id, parent_id, label, data, type, author_id, date_created, date_modified, history FROM fields 
WHERE parent_id = ?
ORDER BY field_id
`

func (q *Queries) ListFieldByDatatypeID(ctx context.Context, parentID sql.NullInt32) ([]Fields, error) {
	rows, err := q.db.QueryContext(ctx, listFieldByDatatypeID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fields
	for rows.Next() {
		var i Fields
		if err := rows.Scan(
			&i.FieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMedia = `-- name: ListMedia :many
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media
ORDER BY name
`

func (q *Queries) ListMedia(ctx context.Context) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, listMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.MediaID,
			&i.Name,
			&i.DisplayName,
			&i.Alt,
			&i.Caption,
			&i.Description,
			&i.Class,
			&i.Mimetype,
			&i.Dimensions,
			&i.Url,
			&i.Srcset,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaDimension = `-- name: ListMediaDimension :many
SELECT md_id, label, width, height, aspect_ratio FROM media_dimensions 
ORDER BY label
`

func (q *Queries) ListMediaDimension(ctx context.Context) ([]MediaDimensions, error) {
	rows, err := q.db.QueryContext(ctx, listMediaDimension)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaDimensions
	for rows.Next() {
		var i MediaDimensions
		if err := rows.Scan(
			&i.MdID,
			&i.Label,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermission = `-- name: ListPermission :many
SELECT permission_id, table_id, mode, label FROM permissions 
ORDER BY table_id
`

func (q *Queries) ListPermission(ctx context.Context) ([]Permissions, error) {
	rows, err := q.db.QueryContext(ctx, listPermission)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permissions
	for rows.Next() {
		var i Permissions
		if err := rows.Scan(
			&i.PermissionID,
			&i.TableID,
			&i.Mode,
			&i.Label,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRole = `-- name: ListRole :many
SELECT role_id, label, permissions FROM roles
`

func (q *Queries) ListRole(ctx context.Context) ([]Roles, error) {
	rows, err := q.db.QueryContext(ctx, listRole)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Roles
	for rows.Next() {
		var i Roles
		if err := rows.Scan(&i.RoleID, &i.Label, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoute = `-- name: ListRoute :many
SELECT route_id, slug, title, status, author_id, date_created, date_modified, history FROM routes
ORDER BY slug
`

func (q *Queries) ListRoute(ctx context.Context) ([]Routes, error) {
	rows, err := q.db.QueryContext(ctx, listRoute)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Routes
	for rows.Next() {
		var i Routes
		if err := rows.Scan(
			&i.RouteID,
			&i.Slug,
			&i.Title,
			&i.Status,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSession = `-- name: ListSession :many
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
`

func (q *Queries) ListSession(ctx context.Context) ([]Sessions, error) {
	rows, err := q.db.QueryContext(ctx, listSession)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sessions
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastAccess,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTable = `-- name: ListTable :many
SELECT id, label, author_id FROM tables
ORDER BY label
`

func (q *Queries) ListTable(ctx context.Context) ([]Tables, error) {
	rows, err := q.db.QueryContext(ctx, listTable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tables
	for rows.Next() {
		var i Tables
		if err := rows.Scan(&i.ID, &i.Label, &i.AuthorID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToken = `-- name: ListToken :many
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
`

func (q *Queries) ListToken(ctx context.Context) ([]Tokens, error) {
	rows, err := q.db.QueryContext(ctx, listToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tokens
	for rows.Next() {
		var i Tokens
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenType,
			&i.Token,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUser = `-- name: ListUser :many
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users 
ORDER BY user_id
`

func (q *Queries) ListUser(ctx context.Context) ([]Users, error) {
	rows, err := q.db.QueryContext(ctx, listUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Users
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Name,
			&i.Email,
			&i.Hash,
			&i.Role,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOauth = `-- name: ListUserOauth :many
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
ORDER BY user_oauth_id
`

func (q *Queries) ListUserOauth(ctx context.Context) ([]UserOauth, error) {
	rows, err := q.db.QueryContext(ctx, listUserOauth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserOauth
	for rows.Next() {
		var i UserOauth
		if err := rows.Scan(
			&i.UserOauthID,
			&i.UserID,
			&i.OauthProvider,
			&i.OauthProviderUserID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.TokenExpiresAt,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSshKeys = `-- name: ListUserSshKeys :many
SELECT ssh_key_id, user_id, public_key, key_type, fingerprint, label, date_created, last_used FROM user_ssh_keys
WHERE user_id = ?
ORDER BY date_created DESC
`

func (q *Queries) ListUserSshKeys(ctx context.Context, userID int32) ([]UserSshKeys, error) {
	rows, err := q.db.QueryContext(ctx, listUserSshKeys, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSshKeys
	for rows.Next() {
		var i UserSshKeys
		if err := rows.Scan(
			&i.SshKeyID,
			&i.UserID,
			&i.PublicKey,
			&i.KeyType,
			&i.Fingerprint,
			&i.Label,
			&i.DateCreated,
			&i.LastUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEventConsumed = `-- name: MarkEventConsumed :exec
UPDATE change_events
SET consumed_at = CURRENT_TIMESTAMP
WHERE event_id = ?
`

func (q *Queries) MarkEventConsumed(ctx context.Context, eventID string) error {
	_, err := q.db.ExecContext(ctx, markEventConsumed, eventID)
	return err
}

const markEventSynced = `-- name: MarkEventSynced :exec
UPDATE change_events
SET synced_at = CURRENT_TIMESTAMP
WHERE event_id = ?
`

func (q *Queries) MarkEventSynced(ctx context.Context, eventID string) error {
	_, err := q.db.ExecContext(ctx, markEventSynced, eventID)
	return err
}

const markEventsConsumedBatch = `-- name: MarkEventsConsumedBatch :exec
UPDATE change_events
SET consumed_at = CURRENT_TIMESTAMP
WHERE event_id IN (/*SLICE:event_ids*/?)
`

func (q *Queries) MarkEventsConsumedBatch(ctx context.Context, eventIds []string) error {
	query := markEventsConsumedBatch
	var queryParams []interface{}
	if len(eventIds) > 0 {
		for _, v := range eventIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:event_ids*/?", strings.Repeat(",?", len(eventIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:event_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const markEventsSyncedBatch = `-- name: MarkEventsSyncedBatch :exec
UPDATE change_events
SET synced_at = CURRENT_TIMESTAMP
WHERE event_id IN (/*SLICE:event_ids*/?)
`

func (q *Queries) MarkEventsSyncedBatch(ctx context.Context, eventIds []string) error {
	query := markEventsSyncedBatch
	var queryParams []interface{}
	if len(eventIds) > 0 {
		for _, v := range eventIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:event_ids*/?", strings.Repeat(",?", len(eventIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:event_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const recordChangeEvent = `-- name: RecordChangeEvent :exec
INSERT INTO change_events (
    event_id,
    hlc_timestamp,
    node_id,
    table_name,
    record_id,
    operation,
    action,
    user_id,
    old_values,
    new_values,
    metadata
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type RecordChangeEventParams struct {
	EventID      string          `json:"event_id"`
	HlcTimestamp int64           `json:"hlc_timestamp"`
	NodeID       string          `json:"node_id"`
	TableName    string          `json:"table_name"`
	RecordID     string          `json:"record_id"`
	Operation    string          `json:"operation"`
	Action       sql.NullString  `json:"action"`
	UserID       sql.NullString  `json:"user_id"`
	OldValues    json.RawMessage `json:"old_values"`
	NewValues    json.RawMessage `json:"new_values"`
	Metadata     json.RawMessage `json:"metadata"`
}

func (q *Queries) RecordChangeEvent(ctx context.Context, arg RecordChangeEventParams) error {
	_, err := q.db.ExecContext(ctx, recordChangeEvent,
		arg.EventID,
		arg.HlcTimestamp,
		arg.NodeID,
		arg.TableName,
		arg.RecordID,
		arg.Operation,
		arg.Action,
		arg.UserID,
		arg.OldValues,
		arg.NewValues,
		arg.Metadata,
	)
	return err
}

const updateAdminContentData = `-- name: UpdateAdminContentData :exec
UPDATE admin_content_data
SET parent_id = ?,
    admin_route_id = ?,
    admin_datatype_id = ?,
    author_id = ?,
    date_created = ?,
    date_modified = ?,
    history = ?
WHERE admin_content_data_id = ?
`

type UpdateAdminContentDataParams struct {
	ParentID           sql.NullInt32  `json:"parent_id"`
	AdminRouteID       int32          `json:"admin_route_id"`
	AdminDatatypeID    int32          `json:"admin_datatype_id"`
	AuthorID           int32          `json:"author_id"`
	DateCreated        time.Time      `json:"date_created"`
	DateModified       time.Time      `json:"date_modified"`
	History            sql.NullString `json:"history"`
	AdminContentDataID int32          `json:"admin_content_data_id"`
}

func (q *Queries) UpdateAdminContentData(ctx context.Context, arg UpdateAdminContentDataParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminContentData,
		arg.ParentID,
		arg.AdminRouteID,
		arg.AdminDatatypeID,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.AdminContentDataID,
	)
	return err
}

const updateAdminContentField = `-- name: UpdateAdminContentField :exec
UPDATE admin_content_fields
SET admin_route_id=?,
    admin_content_data_id=?,
    admin_field_id=?,
    admin_field_value=?, 
    author_id=?,
    date_created=?,
    date_modified=?,
    history=?
WHERE admin_content_field_id = ?
`

type UpdateAdminContentFieldParams struct {
	AdminRouteID        sql.NullInt32  `json:"admin_route_id"`
	AdminContentDataID  int32          `json:"admin_content_data_id"`
	AdminFieldID        int32          `json:"admin_field_id"`
	AdminFieldValue     string         `json:"admin_field_value"`
	AuthorID            int32          `json:"author_id"`
	DateCreated         time.Time      `json:"date_created"`
	DateModified        time.Time      `json:"date_modified"`
	History             sql.NullString `json:"history"`
	AdminContentFieldID int32          `json:"admin_content_field_id"`
}

func (q *Queries) UpdateAdminContentField(ctx context.Context, arg UpdateAdminContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminContentField,
		arg.AdminRouteID,
		arg.AdminContentDataID,
		arg.AdminFieldID,
		arg.AdminFieldValue,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.AdminContentFieldID,
	)
	return err
}

const updateAdminDatatype = `-- name: UpdateAdminDatatype :exec
UPDATE admin_datatypes
SET parent_id = ?,
    label = ?,
    type = ?,
    author_id = ?,
    date_created = ?,
    date_modified = ?,
    history = ?
WHERE admin_datatype_id = ?
`

type UpdateAdminDatatypeParams struct {
	ParentID        sql.NullInt32  `json:"parent_id"`
	Label           string         `json:"label"`
	Type            string         `json:"type"`
	AuthorID        int32          `json:"author_id"`
	DateCreated     time.Time      `json:"date_created"`
	DateModified    time.Time      `json:"date_modified"`
	History         sql.NullString `json:"history"`
	AdminDatatypeID int32          `json:"admin_datatype_id"`
}

func (q *Queries) UpdateAdminDatatype(ctx context.Context, arg UpdateAdminDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.AdminDatatypeID,
	)
	return err
}

const updateAdminDatatypeField = `-- name: UpdateAdminDatatypeField :exec
UPDATE admin_datatypes_fields SET
    admin_datatype_id = ?,
    admin_field_id = ?
WHERE id = ?
`

type UpdateAdminDatatypeFieldParams struct {
	AdminDatatypeID int32 `json:"admin_datatype_id"`
	AdminFieldID    int32 `json:"admin_field_id"`
	ID              int32 `json:"id"`
}

func (q *Queries) UpdateAdminDatatypeField(ctx context.Context, arg UpdateAdminDatatypeFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminDatatypeField, arg.AdminDatatypeID, arg.AdminFieldID, arg.ID)
	return err
}

const updateAdminField = `-- name: UpdateAdminField :exec
UPDATE admin_fields
SET  parent_id = ?,
    label = ?,
    data = ?,
    type = ?,
    author_id = ?,
    date_created = ?,
    date_modified = ?,
    history = ?
WHERE admin_field_id = ?
`

type UpdateAdminFieldParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	History      sql.NullString `json:"history"`
	AdminFieldID int32          `json:"admin_field_id"`
}

func (q *Queries) UpdateAdminField(ctx context.Context, arg UpdateAdminFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.AdminFieldID,
	)
	return err
}

const updateAdminRoute = `-- name: UpdateAdminRoute :exec
UPDATE admin_routes
SET slug = ?,
    title = ?,
    status = ?,
    author_id = ?,
    date_created = ?,
    date_modified = ?,
    history = ?
WHERE slug = ?
`

type UpdateAdminRouteParams struct {
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	Status       int32          `json:"status"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	History      sql.NullString `json:"history"`
	Slug_2       string         `json:"slug_2"`
}

func (q *Queries) UpdateAdminRoute(ctx context.Context, arg UpdateAdminRouteParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.Slug_2,
	)
	return err
}

const updateContentData = `-- name: UpdateContentData :exec
UPDATE content_data
set route_id = ?,
    parent_id = ?,
    first_child_id = ?,
    next_sibling_id = ?,
    prev_sibling_id = ?,
    datatype_id = ?,
    author_id = ?,
    date_created = ?,
    date_modified = ?,
    history = ?
WHERE content_data_id = ?
`

type UpdateContentDataParams struct {
	RouteID       sql.NullInt32  `json:"route_id"`
	ParentID      sql.NullInt32  `json:"parent_id"`
	FirstChildID  sql.NullInt32  `json:"first_child_id"`
	NextSiblingID sql.NullInt32  `json:"next_sibling_id"`
	PrevSiblingID sql.NullInt32  `json:"prev_sibling_id"`
	DatatypeID    sql.NullInt32  `json:"datatype_id"`
	AuthorID      int32          `json:"author_id"`
	DateCreated   time.Time      `json:"date_created"`
	DateModified  time.Time      `json:"date_modified"`
	History       sql.NullString `json:"history"`
	ContentDataID int32          `json:"content_data_id"`
}

func (q *Queries) UpdateContentData(ctx context.Context, arg UpdateContentDataParams) error {
	_, err := q.db.ExecContext(ctx, updateContentData,
		arg.RouteID,
		arg.ParentID,
		arg.FirstChildID,
		arg.NextSiblingID,
		arg.PrevSiblingID,
		arg.DatatypeID,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.ContentDataID,
	)
	return err
}

const updateContentField = `-- name: UpdateContentField :exec
UPDATE content_fields
set  route_id = ?,
    content_data_id = ?,
    field_id = ?,
    field_value = ?, 
    author_id = ?,
    history = ?
WHERE content_field_id = ?
`

type UpdateContentFieldParams struct {
	RouteID        sql.NullInt32  `json:"route_id"`
	ContentDataID  int32          `json:"content_data_id"`
	FieldID        int32          `json:"field_id"`
	FieldValue     string         `json:"field_value"`
	AuthorID       int32          `json:"author_id"`
	History        sql.NullString `json:"history"`
	ContentFieldID int32          `json:"content_field_id"`
}

func (q *Queries) UpdateContentField(ctx context.Context, arg UpdateContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateContentField,
		arg.RouteID,
		arg.ContentDataID,
		arg.FieldID,
		arg.FieldValue,
		arg.AuthorID,
		arg.History,
		arg.ContentFieldID,
	)
	return err
}

const updateDatatype = `-- name: UpdateDatatype :exec
UPDATE datatypes
set 
    parent_id = ?,
    label = ?,
    type = ?,
    author_id = ?,
    history = ?
    WHERE datatype_id = ?
`

type UpdateDatatypeParams struct {
	ParentID   sql.NullInt32  `json:"parent_id"`
	Label      string         `json:"label"`
	Type       string         `json:"type"`
	AuthorID   int32          `json:"author_id"`
	History    sql.NullString `json:"history"`
	DatatypeID int32          `json:"datatype_id"`
}

func (q *Queries) UpdateDatatype(ctx context.Context, arg UpdateDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, updateDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.AuthorID,
		arg.History,
		arg.DatatypeID,
	)
	return err
}

const updateDatatypeField = `-- name: UpdateDatatypeField :exec
UPDATE datatypes_fields SET
    datatype_id = ?,
    field_id = ?
WHERE id = ?
`

type UpdateDatatypeFieldParams struct {
	DatatypeID int32 `json:"datatype_id"`
	FieldID    int32 `json:"field_id"`
	ID         int32 `json:"id"`
}

func (q *Queries) UpdateDatatypeField(ctx context.Context, arg UpdateDatatypeFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateDatatypeField, arg.DatatypeID, arg.FieldID, arg.ID)
	return err
}

const updateField = `-- name: UpdateField :exec
UPDATE fields 
set 
    parent_id = ?,
    label = ?,
    data = ?,
    type = ?,
    author_id = ?,
    date_created = ?,
    date_modified = ?,
    history =?
    WHERE field_id = ?
`

type UpdateFieldParams struct {
	ParentID     sql.NullInt32  `json:"parent_id"`
	Label        string         `json:"label"`
	Data         string         `json:"data"`
	Type         string         `json:"type"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	History      sql.NullString `json:"history"`
	FieldID      int32          `json:"field_id"`
}

func (q *Queries) UpdateField(ctx context.Context, arg UpdateFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.History,
		arg.FieldID,
	)
	return err
}

const updateMedia = `-- name: UpdateMedia :exec
UPDATE media
SET name = ?,
    display_name = ?,
    alt = ?,
    caption = ?,
    description = ?,
    class = ?,
    url = ?,
    mimetype = ?,
    dimensions = ?,
    srcset = ?,
    author_id = ?,
    date_created = ?,
    date_modified = ?
WHERE media_id = ?
`

type UpdateMediaParams struct {
	Name         sql.NullString `json:"name"`
	DisplayName  sql.NullString `json:"display_name"`
	Alt          sql.NullString `json:"alt"`
	Caption      sql.NullString `json:"caption"`
	Description  sql.NullString `json:"description"`
	Class        sql.NullString `json:"class"`
	Url          sql.NullString `json:"url"`
	Mimetype     sql.NullString `json:"mimetype"`
	Dimensions   sql.NullString `json:"dimensions"`
	Srcset       sql.NullString `json:"srcset"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	MediaID      int32          `json:"media_id"`
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) error {
	_, err := q.db.ExecContext(ctx, updateMedia,
		arg.Name,
		arg.DisplayName,
		arg.Alt,
		arg.Caption,
		arg.Description,
		arg.Class,
		arg.Url,
		arg.Mimetype,
		arg.Dimensions,
		arg.Srcset,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.MediaID,
	)
	return err
}

const updateMediaDimension = `-- name: UpdateMediaDimension :exec
UPDATE media_dimensions
set label = ?,
    width = ?,
    height = ?,
    aspect_ratio = ?
WHERE md_id = ?
`

type UpdateMediaDimensionParams struct {
	Label       sql.NullString `json:"label"`
	Width       sql.NullInt32  `json:"width"`
	Height      sql.NullInt32  `json:"height"`
	AspectRatio sql.NullString `json:"aspect_ratio"`
	MdID        int32          `json:"md_id"`
}

func (q *Queries) UpdateMediaDimension(ctx context.Context, arg UpdateMediaDimensionParams) error {
	_, err := q.db.ExecContext(ctx, updateMediaDimension,
		arg.Label,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
		arg.MdID,
	)
	return err
}

const updatePermission = `-- name: UpdatePermission :exec
UPDATE permissions
set table_id=?,
    mode=?,
    label=?
WHERE permission_id = ?
`

type UpdatePermissionParams struct {
	TableID      int32  `json:"table_id"`
	Mode         int32  `json:"mode"`
	Label        string `json:"label"`
	PermissionID int32  `json:"permission_id"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) error {
	_, err := q.db.ExecContext(ctx, updatePermission,
		arg.TableID,
		arg.Mode,
		arg.Label,
		arg.PermissionID,
	)
	return err
}

const updateRole = `-- name: UpdateRole :exec
UPDATE roles
set label=?,
    permissions=?
WHERE role_id = ?
`

type UpdateRoleParams struct {
	Label       string         `json:"label"`
	Permissions sql.NullString `json:"permissions"`
	RoleID      int32          `json:"role_id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateRole, arg.Label, arg.Permissions, arg.RoleID)
	return err
}

const updateRoute = `-- name: UpdateRoute :exec
UPDATE routes
SET slug = ?,
    title = ?,
    status = ?,
    history = ?,
    author_id = ?,
    date_created = ?,
    date_modified = ?
WHERE slug = ?
`

type UpdateRouteParams struct {
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	Status       int32          `json:"status"`
	History      sql.NullString `json:"history"`
	AuthorID     int32          `json:"author_id"`
	DateCreated  time.Time      `json:"date_created"`
	DateModified time.Time      `json:"date_modified"`
	Slug_2       string         `json:"slug_2"`
}

func (q *Queries) UpdateRoute(ctx context.Context, arg UpdateRouteParams) error {
	_, err := q.db.ExecContext(ctx, updateRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.History,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.Slug_2,
	)
	return err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE sessions
    SET user_id=?,
    created_at=?,
    expires_at=?,
    last_access=?,
    ip_address=?,
    user_agent=?,
    session_data=?
WHERE session_id = ?
`

type UpdateSessionParams struct {
	UserID      int32          `json:"user_id"`
	CreatedAt   time.Time      `json:"created_at"`
	ExpiresAt   time.Time      `json:"expires_at"`
	LastAccess  time.Time      `json:"last_access"`
	IpAddress   sql.NullString `json:"ip_address"`
	UserAgent   sql.NullString `json:"user_agent"`
	SessionData sql.NullString `json:"session_data"`
	SessionID   int32          `json:"session_id"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateSession,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastAccess,
		arg.IpAddress,
		arg.UserAgent,
		arg.SessionData,
		arg.SessionID,
	)
	return err
}

const updateTable = `-- name: UpdateTable :exec
UPDATE tables
SET label = ?
WHERE id = ?
`

type UpdateTableParams struct {
	Label string `json:"label"`
	ID    int32  `json:"id"`
}

func (q *Queries) UpdateTable(ctx context.Context, arg UpdateTableParams) error {
	_, err := q.db.ExecContext(ctx, updateTable, arg.Label, arg.ID)
	return err
}

const updateToken = `-- name: UpdateToken :exec
UPDATE tokens
set token = ?,
    issued_at = ?,
    expires_at = ?,
    revoked = ?
WHERE id = ?
`

type UpdateTokenParams struct {
	Token     string    `json:"token"`
	IssuedAt  time.Time `json:"issued_at"`
	ExpiresAt time.Time `json:"expires_at"`
	Revoked   bool      `json:"revoked"`
	ID        int32     `json:"id"`
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateToken,
		arg.Token,
		arg.IssuedAt,
		arg.ExpiresAt,
		arg.Revoked,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
    SET username = ?,
        name = ?,
        email = ?,
        hash = ?,
        role = ?,
        date_created = ?,
        date_modified = ?
WHERE user_id = ?
`

type UpdateUserParams struct {
	Username     string    `json:"username"`
	Name         string    `json:"name"`
	Email        string    `json:"email"`
	Hash         string    `json:"hash"`
	Role         int32     `json:"role"`
	DateCreated  time.Time `json:"date_created"`
	DateModified time.Time `json:"date_modified"`
	UserID       int32     `json:"user_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.Hash,
		arg.Role,
		arg.DateCreated,
		arg.DateModified,
		arg.UserID,
	)
	return err
}

const updateUserOauth = `-- name: UpdateUserOauth :exec
UPDATE user_oauth
SET access_token = ?,
    refresh_token = ?,
    token_expires_at = ?
WHERE user_oauth_id = ?
`

type UpdateUserOauthParams struct {
	AccessToken    string    `json:"access_token"`
	RefreshToken   string    `json:"refresh_token"`
	TokenExpiresAt time.Time `json:"token_expires_at"`
	UserOauthID    int32     `json:"user_oauth_id"`
}

func (q *Queries) UpdateUserOauth(ctx context.Context, arg UpdateUserOauthParams) error {
	_, err := q.db.ExecContext(ctx, updateUserOauth,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenExpiresAt,
		arg.UserOauthID,
	)
	return err
}

const updateUserSshKeyLabel = `-- name: UpdateUserSshKeyLabel :exec
UPDATE user_ssh_keys
SET label = ?
WHERE ssh_key_id = ?
`

type UpdateUserSshKeyLabelParams struct {
	Label    sql.NullString `json:"label"`
	SshKeyID int32          `json:"ssh_key_id"`
}

func (q *Queries) UpdateUserSshKeyLabel(ctx context.Context, arg UpdateUserSshKeyLabelParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSshKeyLabel, arg.Label, arg.SshKeyID)
	return err
}

const updateUserSshKeyLastUsed = `-- name: UpdateUserSshKeyLastUsed :exec
UPDATE user_ssh_keys
SET last_used = ?
WHERE ssh_key_id = ?
`

type UpdateUserSshKeyLastUsedParams struct {
	LastUsed sql.NullTime `json:"last_used"`
	SshKeyID int32        `json:"ssh_key_id"`
}

func (q *Queries) UpdateUserSshKeyLastUsed(ctx context.Context, arg UpdateUserSshKeyLastUsedParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSshKeyLastUsed, arg.LastUsed, arg.SshKeyID)
	return err
}
