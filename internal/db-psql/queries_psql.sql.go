// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries_psql.sql

package mdbp

import (
	"context"
	"database/sql"
	"time"

	"github.com/hegner123/modulacms/internal/db/types"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const checkAdminParentExists = `-- name: CheckAdminParentExists :one
SELECT EXISTS(SELECT 1 FROM admin_datatypes WHERE admin_datatype_id = $1)
`

type CheckAdminParentExistsParams struct {
	AdminDatatypeID types.AdminDatatypeID `json:"admin_datatype_id"`
}

func (q *Queries) CheckAdminParentExists(ctx context.Context, arg CheckAdminParentExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAdminParentExists, arg.AdminDatatypeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAdminRouteExists = `-- name: CheckAdminRouteExists :one
SELECT EXISTS(SELECT 1 FROM admin_routes WHERE admin_route_id = $1)
`

type CheckAdminRouteExistsParams struct {
	AdminRouteID types.AdminRouteID `json:"admin_route_id"`
}

func (q *Queries) CheckAdminRouteExists(ctx context.Context, arg CheckAdminRouteExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAdminRouteExists, arg.AdminRouteID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAuthorExists = `-- name: CheckAuthorExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE username = $1)
`

type CheckAuthorExistsParams struct {
	Username string `json:"username"`
}

func (q *Queries) CheckAuthorExists(ctx context.Context, arg CheckAuthorExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAuthorExists, arg.Username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAuthorIdExists = `-- name: CheckAuthorIdExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE user_id = $1)
`

type CheckAuthorIdExistsParams struct {
	UserID types.UserID `json:"user_id"`
}

func (q *Queries) CheckAuthorIdExists(ctx context.Context, arg CheckAuthorIdExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAuthorIdExists, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkParentExists = `-- name: CheckParentExists :one
SELECT EXISTS(SELECT 1 FROM datatypes WHERE datatype_id = $1)
`

type CheckParentExistsParams struct {
	DatatypeID types.DatatypeID `json:"datatype_id"`
}

func (q *Queries) CheckParentExists(ctx context.Context, arg CheckParentExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkParentExists, arg.DatatypeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkRouteExists = `-- name: CheckRouteExists :one
SELECT EXISTS(SELECT 1 FROM routes WHERE route_id = $1)
`

type CheckRouteExistsParams struct {
	RouteID types.RouteID `json:"route_id"`
}

func (q *Queries) CheckRouteExists(ctx context.Context, arg CheckRouteExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkRouteExists, arg.RouteID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAdminContentData = `-- name: CountAdminContentData :one
SELECT COUNT(*)
FROM admin_content_data
`

func (q *Queries) CountAdminContentData(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminContentData)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminContentField = `-- name: CountAdminContentField :one
SELECT COUNT(*)
FROM admin_content_fields
`

func (q *Queries) CountAdminContentField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminContentField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminContentRelation = `-- name: CountAdminContentRelation :one
SELECT COUNT(*) FROM admin_content_relations
`

func (q *Queries) CountAdminContentRelation(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminContentRelation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminDatatype = `-- name: CountAdminDatatype :one
SELECT COUNT(*)
FROM admin_datatypes
`

func (q *Queries) CountAdminDatatype(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminDatatype)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminDatatypeField = `-- name: CountAdminDatatypeField :one
SELECT COUNT(*)
FROM admin_datatypes_fields
`

func (q *Queries) CountAdminDatatypeField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminDatatypeField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminField = `-- name: CountAdminField :one
SELECT COUNT(*)
FROM admin_fields
`

func (q *Queries) CountAdminField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminroute = `-- name: CountAdminroute :one
SELECT COUNT(*)
FROM admin_routes
`

func (q *Queries) CountAdminroute(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminroute)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBackupSets = `-- name: CountBackupSets :one
SELECT COUNT(*) FROM backup_sets
`

func (q *Queries) CountBackupSets(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBackupSets)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBackups = `-- name: CountBackups :one
SELECT COUNT(*) FROM backups
`

func (q *Queries) CountBackups(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBackups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBackupsByNode = `-- name: CountBackupsByNode :one
SELECT COUNT(*) FROM backups
WHERE node_id = $1
`

type CountBackupsByNodeParams struct {
	NodeID types.NodeID `json:"node_id"`
}

func (q *Queries) CountBackupsByNode(ctx context.Context, arg CountBackupsByNodeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBackupsByNode, arg.NodeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChangeEvents = `-- name: CountChangeEvents :one
SELECT COUNT(*) FROM change_events
`

func (q *Queries) CountChangeEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChangeEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChangeEventsByRecord = `-- name: CountChangeEventsByRecord :one
SELECT COUNT(*) FROM change_events
WHERE table_name = $1 AND record_id = $2
`

type CountChangeEventsByRecordParams struct {
	TableName string `json:"table_name"`
	RecordID  string `json:"record_id"`
}

func (q *Queries) CountChangeEventsByRecord(ctx context.Context, arg CountChangeEventsByRecordParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChangeEventsByRecord, arg.TableName, arg.RecordID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContentData = `-- name: CountContentData :one
SELECT COUNT(*)
FROM content_data
`

func (q *Queries) CountContentData(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContentData)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContentField = `-- name: CountContentField :one
SELECT COUNT(*)
FROM content_fields
`

func (q *Queries) CountContentField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContentField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContentRelation = `-- name: CountContentRelation :one
SELECT COUNT(*) FROM content_relations
`

func (q *Queries) CountContentRelation(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContentRelation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDatatype = `-- name: CountDatatype :one
SELECT COUNT(*)
FROM datatypes
`

func (q *Queries) CountDatatype(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDatatype)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDatatypeField = `-- name: CountDatatypeField :one
SELECT COUNT(*)
FROM datatypes_fields
`

func (q *Queries) CountDatatypeField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDatatypeField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countField = `-- name: CountField :one
SELECT COUNT(*)
FROM fields
`

func (q *Queries) CountField(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countField)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*)
FROM media
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMediaDimension = `-- name: CountMediaDimension :one
SELECT COUNT(*)
FROM media_dimensions
`

func (q *Queries) CountMediaDimension(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMediaDimension)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPermission = `-- name: CountPermission :one
SELECT COUNT(*)
FROM permissions
`

func (q *Queries) CountPermission(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPermission)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRole = `-- name: CountRole :one
SELECT COUNT(*)
FROM roles
`

func (q *Queries) CountRole(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRole)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRoute = `-- name: CountRoute :one
SELECT COUNT(*)
FROM routes
`

func (q *Queries) CountRoute(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRoute)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSession = `-- name: CountSession :one
SELECT COUNT(*)
FROM sessions
`

func (q *Queries) CountSession(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSession)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTables = `-- name: CountTables :one
SELECT COUNT(*)
FROM tables
`

func (q *Queries) CountTables(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTables)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countToken = `-- name: CountToken :one
SELECT COUNT(*)
FROM tokens
`

func (q *Queries) CountToken(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countToken)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUser = `-- name: CountUser :one
SELECT COUNT(*)
FROM users
`

func (q *Queries) CountUser(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUser)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserOauths = `-- name: CountUserOauths :one
SELECT COUNT(*)
FROM user_oauth
`

func (q *Queries) CountUserOauths(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserOauths)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserSshKeys = `-- name: CountUserSshKeys :one
SELECT COUNT(*) FROM user_ssh_keys
`

func (q *Queries) CountUserSshKeys(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserSshKeys)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVerifications = `-- name: CountVerifications :one
SELECT COUNT(*) FROM backup_verifications
`

func (q *Queries) CountVerifications(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVerifications)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAdminContentData = `-- name: CreateAdminContentData :one
INSERT INTO admin_content_data (
    admin_content_data_id,
    parent_id,
    first_child_id,
    next_sibling_id,
    prev_sibling_id,
    admin_route_id,
    admin_datatype_id,
    author_id,
    status,
    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
) RETURNING admin_content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, admin_route_id, admin_datatype_id, author_id, status, date_created, date_modified
`

type CreateAdminContentDataParams struct {
	AdminContentDataID types.AdminContentID          `json:"admin_content_data_id"`
	ParentID           types.NullableContentID       `json:"parent_id"`
	FirstChildID       sql.NullString                `json:"first_child_id"`
	NextSiblingID      sql.NullString                `json:"next_sibling_id"`
	PrevSiblingID      sql.NullString                `json:"prev_sibling_id"`
	AdminRouteID       string                        `json:"admin_route_id"`
	AdminDatatypeID    types.NullableAdminDatatypeID `json:"admin_datatype_id"`
	AuthorID           types.NullableUserID          `json:"author_id"`
	Status             types.ContentStatus           `json:"status"`
	DateCreated        types.Timestamp               `json:"date_created"`
	DateModified       types.Timestamp               `json:"date_modified"`
}

func (q *Queries) CreateAdminContentData(ctx context.Context, arg CreateAdminContentDataParams) (AdminContentData, error) {
	row := q.db.QueryRowContext(ctx, createAdminContentData,
		arg.AdminContentDataID,
		arg.ParentID,
		arg.FirstChildID,
		arg.NextSiblingID,
		arg.PrevSiblingID,
		arg.AdminRouteID,
		arg.AdminDatatypeID,
		arg.AuthorID,
		arg.Status,
		arg.DateCreated,
		arg.DateModified,
	)
	var i AdminContentData
	err := row.Scan(
		&i.AdminContentDataID,
		&i.ParentID,
		&i.FirstChildID,
		&i.NextSiblingID,
		&i.PrevSiblingID,
		&i.AdminRouteID,
		&i.AdminDatatypeID,
		&i.AuthorID,
		&i.Status,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createAdminContentDataTable = `-- name: CreateAdminContentDataTable :exec
CREATE TABLE IF NOT EXISTS admin_content_data (
    admin_content_data_id TEXT PRIMARY KEY NOT NULL,
    parent_id TEXT
        CONSTRAINT fk_parent_id
            REFERENCES admin_content_data
            ON UPDATE CASCADE ON DELETE SET NULL,
    first_child_id TEXT
        CONSTRAINT fk_first_child_id
            REFERENCES admin_content_data
            ON UPDATE CASCADE ON DELETE SET NULL,
    next_sibling_id TEXT
        CONSTRAINT fk_next_sibling_id
            REFERENCES admin_content_data
            ON UPDATE CASCADE ON DELETE SET NULL,
    prev_sibling_id TEXT
        CONSTRAINT fk_prev_sibling_id
            REFERENCES admin_content_data
            ON UPDATE CASCADE ON DELETE SET NULL,
    admin_route_id TEXT NOT NULL
        CONSTRAINT fk_admin_routes
            REFERENCES admin_routes
            ON UPDATE CASCADE,
    admin_datatype_id TEXT NOT NULL
        CONSTRAINT fk_admin_datatypes
            REFERENCES admin_datatypes
            ON UPDATE CASCADE,
    author_id TEXT NOT NULL
        CONSTRAINT fk_author_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    status TEXT NOT NULL DEFAULT 'draft',
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateAdminContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminContentDataTable)
	return err
}

const createAdminContentField = `-- name: CreateAdminContentField :one
INSERT INTO admin_content_fields (
    admin_content_field_id,
    admin_route_id,
    admin_content_data_id,
    admin_field_id,
    admin_field_value,
    author_id,
    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, author_id, date_created, date_modified
`

type CreateAdminContentFieldParams struct {
	AdminContentFieldID types.AdminContentFieldID  `json:"admin_content_field_id"`
	AdminRouteID        sql.NullString             `json:"admin_route_id"`
	AdminContentDataID  string                     `json:"admin_content_data_id"`
	AdminFieldID        types.NullableAdminFieldID `json:"admin_field_id"`
	AdminFieldValue     string                     `json:"admin_field_value"`
	AuthorID            types.NullableUserID       `json:"author_id"`
	DateCreated         types.Timestamp            `json:"date_created"`
	DateModified        types.Timestamp            `json:"date_modified"`
}

func (q *Queries) CreateAdminContentField(ctx context.Context, arg CreateAdminContentFieldParams) (AdminContentFields, error) {
	row := q.db.QueryRowContext(ctx, createAdminContentField,
		arg.AdminContentFieldID,
		arg.AdminRouteID,
		arg.AdminContentDataID,
		arg.AdminFieldID,
		arg.AdminFieldValue,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i AdminContentFields
	err := row.Scan(
		&i.AdminContentFieldID,
		&i.AdminRouteID,
		&i.AdminContentDataID,
		&i.AdminFieldID,
		&i.AdminFieldValue,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createAdminContentFieldTable = `-- name: CreateAdminContentFieldTable :exec
CREATE TABLE IF NOT EXISTS admin_content_fields (
    admin_content_field_id TEXT PRIMARY KEY NOT NULL,
    admin_route_id TEXT
        CONSTRAINT fk_admin_route_id
            REFERENCES admin_routes
            ON UPDATE CASCADE ON DELETE SET NULL,
    admin_content_data_id TEXT NOT NULL
        CONSTRAINT fk_admin_content_data
            REFERENCES admin_content_data
            ON UPDATE CASCADE ON DELETE CASCADE,
    admin_field_id TEXT NOT NULL
        CONSTRAINT fk_admin_fields
            REFERENCES admin_fields
            ON UPDATE CASCADE ON DELETE CASCADE,
    admin_field_value TEXT NOT NULL,
    author_id TEXT NOT NULL
        CONSTRAINT fk_author_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateAdminContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminContentFieldTable)
	return err
}

const createAdminContentRelation = `-- name: CreateAdminContentRelation :one
INSERT INTO admin_content_relations (
    admin_content_relation_id,
    source_content_id,
    target_content_id,
    admin_field_id,
    sort_order,
    date_created
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING admin_content_relation_id, source_content_id, target_content_id, admin_field_id, sort_order, date_created
`

type CreateAdminContentRelationParams struct {
	AdminContentRelationID types.AdminContentRelationID `json:"admin_content_relation_id"`
	SourceContentID        types.AdminContentID         `json:"source_content_id"`
	TargetContentID        types.AdminContentID         `json:"target_content_id"`
	AdminFieldID           types.AdminFieldID           `json:"admin_field_id"`
	SortOrder              int32                        `json:"sort_order"`
	DateCreated            types.Timestamp              `json:"date_created"`
}

func (q *Queries) CreateAdminContentRelation(ctx context.Context, arg CreateAdminContentRelationParams) (AdminContentRelations, error) {
	row := q.db.QueryRowContext(ctx, createAdminContentRelation,
		arg.AdminContentRelationID,
		arg.SourceContentID,
		arg.TargetContentID,
		arg.AdminFieldID,
		arg.SortOrder,
		arg.DateCreated,
	)
	var i AdminContentRelations
	err := row.Scan(
		&i.AdminContentRelationID,
		&i.SourceContentID,
		&i.TargetContentID,
		&i.AdminFieldID,
		&i.SortOrder,
		&i.DateCreated,
	)
	return i, err
}

const createAdminContentRelationTable = `-- name: CreateAdminContentRelationTable :exec
CREATE TABLE IF NOT EXISTS admin_content_relations (
    admin_content_relation_id TEXT PRIMARY KEY NOT NULL CHECK (length(admin_content_relation_id) = 26),
    -- holds admin_content_data_id, named for code symmetry with content_relations
    source_content_id TEXT NOT NULL
        REFERENCES admin_content_data(admin_content_data_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    -- holds admin_content_data_id, named for code symmetry with content_relations
    target_content_id TEXT NOT NULL
        REFERENCES admin_content_data(admin_content_data_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    admin_field_id TEXT NOT NULL
        REFERENCES admin_fields(admin_field_id)
            ON UPDATE CASCADE ON DELETE RESTRICT,
    sort_order INTEGER NOT NULL DEFAULT 0,
    date_created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (source_content_id != target_content_id)
)
`

func (q *Queries) CreateAdminContentRelationTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminContentRelationTable)
	return err
}

const createAdminDatatype = `-- name: CreateAdminDatatype :one
INSERT INTO admin_datatypes (
    admin_datatype_id,
    parent_id,
    label,
    type,
    author_id,
    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified
`

type CreateAdminDatatypeParams struct {
	AdminDatatypeID types.AdminDatatypeID   `json:"admin_datatype_id"`
	ParentID        types.NullableContentID `json:"parent_id"`
	Label           string                  `json:"label"`
	Type            string                  `json:"type"`
	AuthorID        types.NullableUserID    `json:"author_id"`
	DateCreated     types.Timestamp         `json:"date_created"`
	DateModified    types.Timestamp         `json:"date_modified"`
}

func (q *Queries) CreateAdminDatatype(ctx context.Context, arg CreateAdminDatatypeParams) (AdminDatatypes, error) {
	row := q.db.QueryRowContext(ctx, createAdminDatatype,
		arg.AdminDatatypeID,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i AdminDatatypes
	err := row.Scan(
		&i.AdminDatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createAdminDatatypeField = `-- name: CreateAdminDatatypeField :one
INSERT INTO admin_datatypes_fields (
    id,
    admin_datatype_id,
    admin_field_id
) VALUES (
    $1,
    $2,
    $3
) RETURNING id, admin_datatype_id, admin_field_id
`

type CreateAdminDatatypeFieldParams struct {
	ID              string                `json:"id"`
	AdminDatatypeID types.AdminDatatypeID `json:"admin_datatype_id"`
	AdminFieldID    types.AdminFieldID    `json:"admin_field_id"`
}

func (q *Queries) CreateAdminDatatypeField(ctx context.Context, arg CreateAdminDatatypeFieldParams) (AdminDatatypesFields, error) {
	row := q.db.QueryRowContext(ctx, createAdminDatatypeField, arg.ID, arg.AdminDatatypeID, arg.AdminFieldID)
	var i AdminDatatypesFields
	err := row.Scan(&i.ID, &i.AdminDatatypeID, &i.AdminFieldID)
	return i, err
}

const createAdminDatatypeTable = `-- name: CreateAdminDatatypeTable :exec
CREATE TABLE IF NOT EXISTS admin_datatypes (
    admin_datatype_id TEXT PRIMARY KEY NOT NULL,
    parent_id TEXT
        CONSTRAINT fk_parent_id
            REFERENCES admin_datatypes
            ON UPDATE CASCADE ON DELETE SET NULL,
    label TEXT NOT NULL,
    type TEXT NOT NULL,
    author_id TEXT NOT NULL
        CONSTRAINT fk_author_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateAdminDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminDatatypeTable)
	return err
}

const createAdminDatatypesFieldsTable = `-- name: CreateAdminDatatypesFieldsTable :exec
CREATE TABLE IF NOT EXISTS admin_datatypes_fields (
    id TEXT PRIMARY KEY NOT NULL,
    admin_datatype_id TEXT NOT NULL
        CONSTRAINT fk_df_admin_datatype
            REFERENCES admin_datatypes
            ON UPDATE CASCADE ON DELETE CASCADE,
    admin_field_id TEXT NOT NULL
        CONSTRAINT fk_df_admin_field
            REFERENCES admin_fields
            ON UPDATE CASCADE ON DELETE CASCADE
)
`

func (q *Queries) CreateAdminDatatypesFieldsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminDatatypesFieldsTable)
	return err
}

const createAdminField = `-- name: CreateAdminField :one
INSERT INTO admin_fields (
    admin_field_id,
    parent_id,
    label,
    data,
    validation,
    ui_config,
    type,
    author_id,
    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
RETURNING admin_field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified
`

type CreateAdminFieldParams struct {
	AdminFieldID types.AdminFieldID            `json:"admin_field_id"`
	ParentID     types.NullableAdminDatatypeID `json:"parent_id"`
	Label        string                        `json:"label"`
	Data         string                        `json:"data"`
	Validation   string                        `json:"validation"`
	UiConfig     string                        `json:"ui_config"`
	Type         types.FieldType               `json:"type"`
	AuthorID     types.NullableUserID          `json:"author_id"`
	DateCreated  types.Timestamp               `json:"date_created"`
	DateModified types.Timestamp               `json:"date_modified"`
}

func (q *Queries) CreateAdminField(ctx context.Context, arg CreateAdminFieldParams) (AdminFields, error) {
	row := q.db.QueryRowContext(ctx, createAdminField,
		arg.AdminFieldID,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Validation,
		arg.UiConfig,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i AdminFields
	err := row.Scan(
		&i.AdminFieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Validation,
		&i.UiConfig,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createAdminFieldTable = `-- name: CreateAdminFieldTable :exec
CREATE TABLE IF NOT EXISTS admin_fields (
    admin_field_id TEXT PRIMARY KEY NOT NULL,
    parent_id TEXT
        REFERENCES admin_datatypes
            ON UPDATE CASCADE ON DELETE SET NULL,
    label TEXT DEFAULT 'unlabeled'::TEXT NOT NULL,
    data TEXT DEFAULT ''::TEXT NOT NULL,
    validation TEXT NOT NULL,
    ui_config TEXT NOT NULL,
    type TEXT DEFAULT 'text'::TEXT NOT NULL,
    author_id TEXT NOT NULL
        REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateAdminFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminFieldTable)
	return err
}

const createAdminRoute = `-- name: CreateAdminRoute :one
INSERT INTO admin_routes (
    admin_route_id,
    slug,
    title,
    status,
    author_id,
    date_created,
    date_modified
    ) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
    ) RETURNING admin_route_id, slug, title, status, author_id, date_created, date_modified
`

type CreateAdminRouteParams struct {
	AdminRouteID types.AdminRouteID   `json:"admin_route_id"`
	Slug         types.Slug           `json:"slug"`
	Title        string               `json:"title"`
	Status       int32                `json:"status"`
	AuthorID     types.NullableUserID `json:"author_id"`
	DateCreated  types.Timestamp      `json:"date_created"`
	DateModified types.Timestamp      `json:"date_modified"`
}

func (q *Queries) CreateAdminRoute(ctx context.Context, arg CreateAdminRouteParams) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, createAdminRoute,
		arg.AdminRouteID,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createAdminRouteSlugIndex = `-- name: CreateAdminRouteSlugIndex :exec
CREATE INDEX IF NOT EXISTS idx_admin_routes_slug
ON admin_routes(slug)
`

func (q *Queries) CreateAdminRouteSlugIndex(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminRouteSlugIndex)
	return err
}

const createAdminRouteTable = `-- name: CreateAdminRouteTable :exec
CREATE TABLE IF NOT EXISTS admin_routes (
    admin_route_id TEXT PRIMARY KEY NOT NULL,
    slug TEXT NOT NULL
        UNIQUE,
    title TEXT NOT NULL,
    status INTEGER NOT NULL,
    author_id TEXT NOT NULL
        REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateAdminRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createAdminRouteTable)
	return err
}

const createBackup = `-- name: CreateBackup :one

INSERT INTO backups (
    backup_id, node_id, backup_type, status, started_at, storage_path,
    triggered_by, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING backup_id, node_id, backup_type, status, started_at, completed_at, duration_ms, record_count, size_bytes, replication_lsn, hlc_timestamp, storage_path, checksum, triggered_by, error_message, metadata
`

type CreateBackupParams struct {
	BackupID    types.BackupID       `json:"backup_id"`
	NodeID      types.NodeID         `json:"node_id"`
	BackupType  types.BackupType     `json:"backup_type"`
	Status      types.BackupStatus   `json:"status"`
	StartedAt   types.Timestamp      `json:"started_at"`
	StoragePath string               `json:"storage_path"`
	TriggeredBy types.NullableString `json:"triggered_by"`
	Metadata    types.JSONData       `json:"metadata"`
}

// Backups CRUD
func (q *Queries) CreateBackup(ctx context.Context, arg CreateBackupParams) (Backup, error) {
	row := q.db.QueryRowContext(ctx, createBackup,
		arg.BackupID,
		arg.NodeID,
		arg.BackupType,
		arg.Status,
		arg.StartedAt,
		arg.StoragePath,
		arg.TriggeredBy,
		arg.Metadata,
	)
	var i Backup
	err := row.Scan(
		&i.BackupID,
		&i.NodeID,
		&i.BackupType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.RecordCount,
		&i.SizeBytes,
		&i.ReplicationLsn,
		&i.HlcTimestamp,
		&i.StoragePath,
		&i.Checksum,
		&i.TriggeredBy,
		&i.ErrorMessage,
		&i.Metadata,
	)
	return i, err
}

const createBackupSet = `-- name: CreateBackupSet :one

INSERT INTO backup_sets (
    backup_set_id, created_at, hlc_timestamp, status,
    backup_ids, node_count, completed_count, error_message
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING backup_set_id, created_at, hlc_timestamp, status, backup_ids, node_count, completed_count, error_message
`

type CreateBackupSetParams struct {
	BackupSetID    types.BackupSetID     `json:"backup_set_id"`
	CreatedAt      types.Timestamp       `json:"created_at"`
	HlcTimestamp   types.HLC             `json:"hlc_timestamp"`
	Status         types.BackupSetStatus `json:"status"`
	BackupIds      types.JSONData        `json:"backup_ids"`
	NodeCount      int32                 `json:"node_count"`
	CompletedCount types.NullableInt64   `json:"completed_count"`
	ErrorMessage   types.NullableString  `json:"error_message"`
}

// Backup Sets CRUD
func (q *Queries) CreateBackupSet(ctx context.Context, arg CreateBackupSetParams) (BackupSet, error) {
	row := q.db.QueryRowContext(ctx, createBackupSet,
		arg.BackupSetID,
		arg.CreatedAt,
		arg.HlcTimestamp,
		arg.Status,
		arg.BackupIds,
		arg.NodeCount,
		arg.CompletedCount,
		arg.ErrorMessage,
	)
	var i BackupSet
	err := row.Scan(
		&i.BackupSetID,
		&i.CreatedAt,
		&i.HlcTimestamp,
		&i.Status,
		&i.BackupIds,
		&i.NodeCount,
		&i.CompletedCount,
		&i.ErrorMessage,
	)
	return i, err
}

const createBackupTables = `-- name: CreateBackupTables :exec
CREATE TABLE IF NOT EXISTS backups (
    backup_id       CHAR(26) PRIMARY KEY,
    node_id         CHAR(26) NOT NULL,
    backup_type     VARCHAR(20) NOT NULL CHECK (backup_type IN ('full', 'incremental', 'snapshot')),
    status          VARCHAR(20) NOT NULL CHECK (status IN ('started', 'completed', 'failed', 'verified')),
    started_at      TIMESTAMP WITH TIME ZONE NOT NULL,
    completed_at    TIMESTAMP WITH TIME ZONE,
    duration_ms     INTEGER,
    record_count    BIGINT,
    size_bytes      BIGINT,
    replication_lsn VARCHAR(64),
    hlc_timestamp   BIGINT,
    storage_path    TEXT NOT NULL,
    checksum        VARCHAR(64),
    triggered_by    VARCHAR(64),
    error_message   TEXT,
    metadata        JSONB
)
`

func (q *Queries) CreateBackupTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createBackupTables)
	return err
}

const createChangeEventsTable = `-- name: CreateChangeEventsTable :exec
CREATE TABLE IF NOT EXISTS change_events (
    event_id CHAR(26) PRIMARY KEY,
    hlc_timestamp BIGINT NOT NULL,
    wall_timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    node_id CHAR(26) NOT NULL,
    table_name VARCHAR(64) NOT NULL,
    record_id CHAR(26) NOT NULL,
    operation VARCHAR(20) NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),
    action VARCHAR(20),
    user_id CHAR(26),
    old_values JSONB,
    new_values JSONB,
    metadata JSONB,
    request_id TEXT,
    ip TEXT,
    synced_at TIMESTAMP WITH TIME ZONE,
    consumed_at TIMESTAMP WITH TIME ZONE
)
`

func (q *Queries) CreateChangeEventsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createChangeEventsTable)
	return err
}

const createContentData = `-- name: CreateContentData :one
INSERT INTO content_data (
    content_data_id,
    parent_id,
    first_child_id,
    next_sibling_id,
    prev_sibling_id,
    route_id,
    datatype_id,
    author_id,
    status,
    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
) RETURNING content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, route_id, datatype_id, author_id, status, date_created, date_modified
`

type CreateContentDataParams struct {
	ContentDataID types.ContentID          `json:"content_data_id"`
	ParentID      types.NullableContentID  `json:"parent_id"`
	FirstChildID  sql.NullString           `json:"first_child_id"`
	NextSiblingID sql.NullString           `json:"next_sibling_id"`
	PrevSiblingID sql.NullString           `json:"prev_sibling_id"`
	RouteID       types.NullableRouteID    `json:"route_id"`
	DatatypeID    types.NullableDatatypeID `json:"datatype_id"`
	AuthorID      types.NullableUserID     `json:"author_id"`
	Status        types.ContentStatus      `json:"status"`
	DateCreated   types.Timestamp          `json:"date_created"`
	DateModified  types.Timestamp          `json:"date_modified"`
}

func (q *Queries) CreateContentData(ctx context.Context, arg CreateContentDataParams) (ContentData, error) {
	row := q.db.QueryRowContext(ctx, createContentData,
		arg.ContentDataID,
		arg.ParentID,
		arg.FirstChildID,
		arg.NextSiblingID,
		arg.PrevSiblingID,
		arg.RouteID,
		arg.DatatypeID,
		arg.AuthorID,
		arg.Status,
		arg.DateCreated,
		arg.DateModified,
	)
	var i ContentData
	err := row.Scan(
		&i.ContentDataID,
		&i.ParentID,
		&i.FirstChildID,
		&i.NextSiblingID,
		&i.PrevSiblingID,
		&i.RouteID,
		&i.DatatypeID,
		&i.AuthorID,
		&i.Status,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createContentDataTable = `-- name: CreateContentDataTable :exec
CREATE TABLE IF NOT EXISTS content_data (
    content_data_id TEXT PRIMARY KEY NOT NULL,
    parent_id TEXT
        CONSTRAINT fk_parent_id
            REFERENCES content_data
            ON UPDATE CASCADE ON DELETE SET NULL,
    first_child_id TEXT
        CONSTRAINT fk_first_child_id
            REFERENCES content_data
            ON UPDATE CASCADE ON DELETE SET NULL,
    next_sibling_id TEXT
        CONSTRAINT fk_next_sibling_id
            REFERENCES content_data
            ON UPDATE CASCADE ON DELETE SET NULL,
    prev_sibling_id TEXT
        CONSTRAINT fk_prev_sibling_id
            REFERENCES content_data
            ON UPDATE CASCADE ON DELETE SET NULL,
    route_id TEXT
        CONSTRAINT fk_routes
            REFERENCES routes
            ON UPDATE CASCADE ON DELETE SET NULL,
    datatype_id TEXT
        CONSTRAINT fk_datatypes
            REFERENCES datatypes
            ON UPDATE CASCADE ON DELETE SET NULL,
    author_id TEXT NOT NULL
        CONSTRAINT fk_author_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    status TEXT NOT NULL DEFAULT 'draft',
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createContentDataTable)
	return err
}

const createContentField = `-- name: CreateContentField :one
INSERT INTO content_fields (
    content_field_id,
    route_id,
    content_data_id,
    field_id,
    field_value,
    author_id, 

    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified
`

type CreateContentFieldParams struct {
	ContentFieldID types.ContentFieldID    `json:"content_field_id"`
	RouteID        types.NullableRouteID   `json:"route_id"`
	ContentDataID  types.NullableContentID `json:"content_data_id"`
	FieldID        types.NullableFieldID   `json:"field_id"`
	FieldValue     string                  `json:"field_value"`
	AuthorID       types.NullableUserID    `json:"author_id"`
	DateCreated    types.Timestamp         `json:"date_created"`
	DateModified   types.Timestamp         `json:"date_modified"`
}

func (q *Queries) CreateContentField(ctx context.Context, arg CreateContentFieldParams) (ContentFields, error) {
	row := q.db.QueryRowContext(ctx, createContentField,
		arg.ContentFieldID,
		arg.RouteID,
		arg.ContentDataID,
		arg.FieldID,
		arg.FieldValue,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i ContentFields
	err := row.Scan(
		&i.ContentFieldID,
		&i.RouteID,
		&i.ContentDataID,
		&i.FieldID,
		&i.FieldValue,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createContentFieldTable = `-- name: CreateContentFieldTable :exec
CREATE TABLE IF NOT EXISTS content_fields (
    content_field_id TEXT PRIMARY KEY NOT NULL,
    route_id TEXT
        CONSTRAINT fk_route_id
            REFERENCES routes
            ON UPDATE CASCADE ON DELETE SET NULL,
    content_data_id TEXT NOT NULL
        CONSTRAINT fk_content_data
            REFERENCES content_data
            ON UPDATE CASCADE ON DELETE CASCADE,
    field_id TEXT NOT NULL
        CONSTRAINT fk_fields_field
            REFERENCES fields
            ON UPDATE CASCADE ON DELETE CASCADE,
    field_value TEXT NOT NULL,
    author_id TEXT NOT NULL
        CONSTRAINT fk_author_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createContentFieldTable)
	return err
}

const createContentRelation = `-- name: CreateContentRelation :one
INSERT INTO content_relations (
    content_relation_id,
    source_content_id,
    target_content_id,
    field_id,
    sort_order,
    date_created
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING content_relation_id, source_content_id, target_content_id, field_id, sort_order, date_created
`

type CreateContentRelationParams struct {
	ContentRelationID types.ContentRelationID `json:"content_relation_id"`
	SourceContentID   types.ContentID         `json:"source_content_id"`
	TargetContentID   types.ContentID         `json:"target_content_id"`
	FieldID           types.FieldID           `json:"field_id"`
	SortOrder         int32                   `json:"sort_order"`
	DateCreated       types.Timestamp         `json:"date_created"`
}

func (q *Queries) CreateContentRelation(ctx context.Context, arg CreateContentRelationParams) (ContentRelations, error) {
	row := q.db.QueryRowContext(ctx, createContentRelation,
		arg.ContentRelationID,
		arg.SourceContentID,
		arg.TargetContentID,
		arg.FieldID,
		arg.SortOrder,
		arg.DateCreated,
	)
	var i ContentRelations
	err := row.Scan(
		&i.ContentRelationID,
		&i.SourceContentID,
		&i.TargetContentID,
		&i.FieldID,
		&i.SortOrder,
		&i.DateCreated,
	)
	return i, err
}

const createContentRelationTable = `-- name: CreateContentRelationTable :exec
CREATE TABLE IF NOT EXISTS content_relations (
    content_relation_id TEXT PRIMARY KEY NOT NULL CHECK (length(content_relation_id) = 26),
    source_content_id TEXT NOT NULL
        REFERENCES content_data(content_data_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    target_content_id TEXT NOT NULL
        REFERENCES content_data(content_data_id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    field_id TEXT NOT NULL
        REFERENCES fields(field_id)
            ON UPDATE CASCADE ON DELETE RESTRICT,
    sort_order INTEGER NOT NULL DEFAULT 0,
    date_created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (source_content_id != target_content_id)
)
`

func (q *Queries) CreateContentRelationTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createContentRelationTable)
	return err
}

const createDatatype = `-- name: CreateDatatype :one
INSERT INTO datatypes (
    datatype_id,
    parent_id,
    label,
    type,
    author_id,
    date_created,
    date_modified
    ) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
    ) RETURNING datatype_id, parent_id, label, type, author_id, date_created, date_modified
`

type CreateDatatypeParams struct {
	DatatypeID   types.DatatypeID        `json:"datatype_id"`
	ParentID     types.NullableContentID `json:"parent_id"`
	Label        string                  `json:"label"`
	Type         string                  `json:"type"`
	AuthorID     types.NullableUserID    `json:"author_id"`
	DateCreated  types.Timestamp         `json:"date_created"`
	DateModified types.Timestamp         `json:"date_modified"`
}

func (q *Queries) CreateDatatype(ctx context.Context, arg CreateDatatypeParams) (Datatypes, error) {
	row := q.db.QueryRowContext(ctx, createDatatype,
		arg.DatatypeID,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i Datatypes
	err := row.Scan(
		&i.DatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createDatatypeField = `-- name: CreateDatatypeField :one
INSERT INTO datatypes_fields (
    id,
    datatype_id,
    field_id,
    sort_order
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING id, datatype_id, field_id, sort_order
`

type CreateDatatypeFieldParams struct {
	ID         string           `json:"id"`
	DatatypeID types.DatatypeID `json:"datatype_id"`
	FieldID    types.FieldID    `json:"field_id"`
	SortOrder  int32            `json:"sort_order"`
}

func (q *Queries) CreateDatatypeField(ctx context.Context, arg CreateDatatypeFieldParams) (DatatypesFields, error) {
	row := q.db.QueryRowContext(ctx, createDatatypeField,
		arg.ID,
		arg.DatatypeID,
		arg.FieldID,
		arg.SortOrder,
	)
	var i DatatypesFields
	err := row.Scan(
		&i.ID,
		&i.DatatypeID,
		&i.FieldID,
		&i.SortOrder,
	)
	return i, err
}

const createDatatypeTable = `-- name: CreateDatatypeTable :exec
CREATE TABLE IF NOT EXISTS datatypes (
    datatype_id TEXT PRIMARY KEY NOT NULL,
    parent_id TEXT
        CONSTRAINT fk_datatypes_parent
            REFERENCES datatypes
            ON UPDATE CASCADE ON DELETE SET NULL,
    label TEXT NOT NULL,
    type TEXT NOT NULL,
    author_id TEXT NOT NULL
        CONSTRAINT fk_users_author_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createDatatypeTable)
	return err
}

const createDatatypesFieldsTable = `-- name: CreateDatatypesFieldsTable :exec
CREATE TABLE IF NOT EXISTS datatypes_fields (
    id TEXT PRIMARY KEY NOT NULL,
    datatype_id TEXT NOT NULL
        CONSTRAINT fk_df_datatype
            REFERENCES datatypes
            ON UPDATE CASCADE ON DELETE CASCADE,
    field_id TEXT NOT NULL
        CONSTRAINT fk_df_field
            REFERENCES fields
            ON UPDATE CASCADE ON DELETE CASCADE,
    sort_order INTEGER NOT NULL DEFAULT 0
)
`

func (q *Queries) CreateDatatypesFieldsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createDatatypesFieldsTable)
	return err
}

const createField = `-- name: CreateField :one
INSERT INTO fields  (
    field_id,
    parent_id,
    label,
    data,
    validation,
    ui_config,
    type,
    author_id,
    date_created,
    date_modified
    ) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
    ) RETURNING field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified
`

type CreateFieldParams struct {
	FieldID      types.FieldID            `json:"field_id"`
	ParentID     types.NullableDatatypeID `json:"parent_id"`
	Label        string                   `json:"label"`
	Data         string                   `json:"data"`
	Validation   string                   `json:"validation"`
	UiConfig     string                   `json:"ui_config"`
	Type         types.FieldType          `json:"type"`
	AuthorID     types.NullableUserID     `json:"author_id"`
	DateCreated  types.Timestamp          `json:"date_created"`
	DateModified types.Timestamp          `json:"date_modified"`
}

func (q *Queries) CreateField(ctx context.Context, arg CreateFieldParams) (Fields, error) {
	row := q.db.QueryRowContext(ctx, createField,
		arg.FieldID,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Validation,
		arg.UiConfig,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i Fields
	err := row.Scan(
		&i.FieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Validation,
		&i.UiConfig,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createFieldTable = `-- name: CreateFieldTable :exec
CREATE TABLE IF NOT EXISTS fields (
    field_id TEXT PRIMARY KEY NOT NULL,
    parent_id TEXT
        CONSTRAINT fk_datatypes
            REFERENCES datatypes
            ON UPDATE CASCADE ON DELETE SET NULL,
    label TEXT DEFAULT 'unlabeled'::TEXT NOT NULL,
    data TEXT NOT NULL,
    validation TEXT NOT NULL,
    ui_config TEXT NOT NULL,
    type TEXT NOT NULL,
    author_id TEXT NOT NULL
        CONSTRAINT fk_users_author_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createFieldTable)
	return err
}

const createIDIndex = `-- name: CreateIDIndex :exec
CREATE INDEX IF NOT EXISTS idx_role_id ON roles(role_id)
`

func (q *Queries) CreateIDIndex(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createIDIndex)
	return err
}

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (
    media_id,
    name,
    display_name,
    alt,
    caption,
    description,
    class,
    url,
    mimetype,
    dimensions,
    srcset,
    author_id,
    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
)
RETURNING media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified
`

type CreateMediaParams struct {
	MediaID      types.MediaID        `json:"media_id"`
	Name         sql.NullString       `json:"name"`
	DisplayName  sql.NullString       `json:"display_name"`
	Alt          sql.NullString       `json:"alt"`
	Caption      sql.NullString       `json:"caption"`
	Description  sql.NullString       `json:"description"`
	Class        sql.NullString       `json:"class"`
	URL          types.URL            `json:"url"`
	Mimetype     sql.NullString       `json:"mimetype"`
	Dimensions   sql.NullString       `json:"dimensions"`
	Srcset       sql.NullString       `json:"srcset"`
	AuthorID     types.NullableUserID `json:"author_id"`
	DateCreated  types.Timestamp      `json:"date_created"`
	DateModified types.Timestamp      `json:"date_modified"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Media, error) {
	row := q.db.QueryRowContext(ctx, createMedia,
		arg.MediaID,
		arg.Name,
		arg.DisplayName,
		arg.Alt,
		arg.Caption,
		arg.Description,
		arg.Class,
		arg.URL,
		arg.Mimetype,
		arg.Dimensions,
		arg.Srcset,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.URL,
		&i.Srcset,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createMediaDimension = `-- name: CreateMediaDimension :one
INSERT INTO media_dimensions(
    md_id,
    label,
    width,
    height,
    aspect_ratio
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING md_id, label, width, height, aspect_ratio
`

type CreateMediaDimensionParams struct {
	MdID        string         `json:"md_id"`
	Label       sql.NullString `json:"label"`
	Width       sql.NullInt32  `json:"width"`
	Height      sql.NullInt32  `json:"height"`
	AspectRatio sql.NullString `json:"aspect_ratio"`
}

func (q *Queries) CreateMediaDimension(ctx context.Context, arg CreateMediaDimensionParams) (MediaDimensions, error) {
	row := q.db.QueryRowContext(ctx, createMediaDimension,
		arg.MdID,
		arg.Label,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
	)
	var i MediaDimensions
	err := row.Scan(
		&i.MdID,
		&i.Label,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
	)
	return i, err
}

const createMediaDimensionTable = `-- name: CreateMediaDimensionTable :exec
CREATE TABLE IF NOT EXISTS media_dimensions (
    md_id TEXT PRIMARY KEY NOT NULL,
    label TEXT
        UNIQUE,
    width INTEGER,
    height INTEGER,
    aspect_ratio TEXT
)
`

func (q *Queries) CreateMediaDimensionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createMediaDimensionTable)
	return err
}

const createMediaTable = `-- name: CreateMediaTable :exec
CREATE TABLE IF NOT EXISTS media (
    media_id TEXT PRIMARY KEY NOT NULL,
    name TEXT,
    display_name TEXT,
    alt TEXT,
    caption TEXT,
    description TEXT,
    class TEXT,
    mimetype TEXT,
    dimensions TEXT,
    url TEXT
        UNIQUE,
    srcset TEXT,
    author_id TEXT NOT NULL
        CONSTRAINT fk_users_author_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateMediaTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createMediaTable)
	return err
}

const createParentIDIndex = `-- name: CreateParentIDIndex :exec
CREATE INDEX parent_id
    ON fields (parent_id)
`

func (q *Queries) CreateParentIDIndex(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createParentIDIndex)
	return err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions(
    permission_id,
    table_id,
    mode,
    label
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING permission_id, table_id, mode, label
`

type CreatePermissionParams struct {
	PermissionID types.PermissionID `json:"permission_id"`
	TableID      string             `json:"table_id"`
	Mode         int32              `json:"mode"`
	Label        string             `json:"label"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permissions, error) {
	row := q.db.QueryRowContext(ctx, createPermission,
		arg.PermissionID,
		arg.TableID,
		arg.Mode,
		arg.Label,
	)
	var i Permissions
	err := row.Scan(
		&i.PermissionID,
		&i.TableID,
		&i.Mode,
		&i.Label,
	)
	return i, err
}

const createPermissionTable = `-- name: CreatePermissionTable :exec
CREATE TABLE IF NOT EXISTS permissions (
    permission_id TEXT PRIMARY KEY NOT NULL,
    table_id TEXT NOT NULL,
    mode INTEGER NOT NULL,
    label TEXT NOT NULL
)
`

func (q *Queries) CreatePermissionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createPermissionTable)
	return err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (
    role_id,
    label,
    permissions
) VALUES (
    $1,
    $2,
    $3
)
RETURNING role_id, label, permissions
`

type CreateRoleParams struct {
	RoleID      types.RoleID          `json:"role_id"`
	Label       string                `json:"label"`
	Permissions pqtype.NullRawMessage `json:"permissions"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Roles, error) {
	row := q.db.QueryRowContext(ctx, createRole, arg.RoleID, arg.Label, arg.Permissions)
	var i Roles
	err := row.Scan(&i.RoleID, &i.Label, &i.Permissions)
	return i, err
}

const createRoleTable = `-- name: CreateRoleTable :exec
CREATE TABLE IF NOT EXISTS roles (
    role_id TEXT PRIMARY KEY NOT NULL,
    label TEXT NOT NULL
        UNIQUE,
    permissions jsonb
)
`

func (q *Queries) CreateRoleTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createRoleTable)
	return err
}

const createRoute = `-- name: CreateRoute :one
INSERT INTO routes (
    route_id,
    slug,
    title,
    status,
    author_id,
    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING route_id, slug, title, status, author_id, date_created, date_modified
`

type CreateRouteParams struct {
	RouteID      types.RouteID        `json:"route_id"`
	Slug         types.Slug           `json:"slug"`
	Title        string               `json:"title"`
	Status       int32                `json:"status"`
	AuthorID     types.NullableUserID `json:"author_id"`
	DateCreated  types.Timestamp      `json:"date_created"`
	DateModified types.Timestamp      `json:"date_modified"`
}

func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) (Routes, error) {
	row := q.db.QueryRowContext(ctx, createRoute,
		arg.RouteID,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
	)
	var i Routes
	err := row.Scan(
		&i.RouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createRouteTable = `-- name: CreateRouteTable :exec
CREATE TABLE IF NOT EXISTS routes (
    route_id TEXT PRIMARY KEY NOT NULL,
    slug TEXT NOT NULL
        UNIQUE,
    title TEXT NOT NULL,
    status INTEGER NOT NULL,
    author_id TEXT NOT NULL
        REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TEXT DEFAULT CURRENT_TIMESTAMP,
    date_modified TEXT DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createRouteTable)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    session_id,
    user_id,
    created_at,
    expires_at,
    last_access,
    ip_address,
    user_agent,
    session_data
) VALUES(
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data
`

type CreateSessionParams struct {
	SessionID   types.SessionID      `json:"session_id"`
	UserID      types.NullableUserID `json:"user_id"`
	CreatedAt   types.Timestamp      `json:"created_at"`
	ExpiresAt   types.Timestamp      `json:"expires_at"`
	LastAccess  sql.NullTime         `json:"last_access"`
	IpAddress   sql.NullString       `json:"ip_address"`
	UserAgent   sql.NullString       `json:"user_agent"`
	SessionData sql.NullString       `json:"session_data"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Sessions, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.SessionID,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastAccess,
		arg.IpAddress,
		arg.UserAgent,
		arg.SessionData,
	)
	var i Sessions
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccess,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionData,
	)
	return i, err
}

const createSessionTable = `-- name: CreateSessionTable :exec
CREATE TABLE IF NOT EXISTS sessions (
    session_id TEXT PRIMARY KEY NOT NULL,
    user_id TEXT NOT NULL
        CONSTRAINT fk_sessions_user_id
            REFERENCES users
            ON UPDATE CASCADE ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    last_access TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address TEXT,
    user_agent TEXT,
    session_data TEXT
)
`

func (q *Queries) CreateSessionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createSessionTable)
	return err
}

const createTable = `-- name: CreateTable :one
INSERT INTO tables (
    id,
    label
) VALUES (
    $1,
    $2
)
RETURNING id, label, author_id
`

type CreateTableParams struct {
	ID    string `json:"id"`
	Label string `json:"label"`
}

func (q *Queries) CreateTable(ctx context.Context, arg CreateTableParams) (Tables, error) {
	row := q.db.QueryRowContext(ctx, createTable, arg.ID, arg.Label)
	var i Tables
	err := row.Scan(&i.ID, &i.Label, &i.AuthorID)
	return i, err
}

const createTablesTable = `-- name: CreateTablesTable :exec
CREATE TABLE IF NOT EXISTS tables (
    id TEXT PRIMARY KEY NOT NULL,
    label TEXT NOT NULL
        UNIQUE,
    author_id TEXT
        REFERENCES users
            ON UPDATE CASCADE ON DELETE SET NULL
)
`

func (q *Queries) CreateTablesTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTablesTable)
	return err
}

const createToken = `-- name: CreateToken :one
INSERT INTO tokens (
    id,
    user_id,
    token_type,
    token,
    issued_at,
    expires_at,
    revoked
    ) VALUES(
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
) RETURNING id, user_id, token_type, token, issued_at, expires_at, revoked
`

type CreateTokenParams struct {
	ID        string               `json:"id"`
	UserID    types.NullableUserID `json:"user_id"`
	TokenType string               `json:"token_type"`
	Tokens    string               `json:"token"`
	IssuedAt  time.Time            `json:"issued_at"`
	ExpiresAt types.Timestamp      `json:"expires_at"`
	Revoked   bool                 `json:"revoked"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (Tokens, error) {
	row := q.db.QueryRowContext(ctx, createToken,
		arg.ID,
		arg.UserID,
		arg.TokenType,
		arg.Tokens,
		arg.IssuedAt,
		arg.ExpiresAt,
		arg.Revoked,
	)
	var i Tokens
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.Tokens,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const createTokenTable = `-- name: CreateTokenTable :exec
CREATE TABLE IF NOT EXISTS tokens (
    id TEXT PRIMARY KEY NOT NULL,
    user_id TEXT NOT NULL,
    token_type TEXT NOT NULL,
    token TEXT NOT NULL UNIQUE,
    issued_at TIMESTAMP NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    revoked BOOLEAN NOT NULL DEFAULT false,
    CONSTRAINT fk_tokens_users FOREIGN KEY (user_id)
        REFERENCES users(user_id)
        ON DELETE CASCADE
)
`

func (q *Queries) CreateTokenTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTokenTable)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    user_id,
    username,
    name,
    email,
    hash,
    role,
    date_created,
    date_modified
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING user_id, username, name, email, hash, role, date_created, date_modified
`

type CreateUserParams struct {
	UserID       types.UserID    `json:"user_id"`
	Username     string          `json:"username"`
	Name         string          `json:"name"`
	Email        types.Email     `json:"email"`
	Hash         string          `json:"hash"`
	Roles        string          `json:"role"`
	DateCreated  types.Timestamp `json:"date_created"`
	DateModified types.Timestamp `json:"date_modified"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Users, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.UserID,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.Hash,
		arg.Roles,
		arg.DateCreated,
		arg.DateModified,
	)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Roles,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const createUserOauth = `-- name: CreateUserOauth :one
INSERT INTO user_oauth (
    user_oauth_id,
    user_id,
    oauth_provider,
    oauth_provider_user_id,
    access_token,
    refresh_token,
    token_expires_at,
    date_created
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
`

type CreateUserOauthParams struct {
	UserOAuthID         types.UserOauthID    `json:"user_oauth_id"`
	UserID              types.NullableUserID `json:"user_id"`
	OauthProvider       string               `json:"oauth_provider"`
	OAuthProviderUserID string               `json:"oauth_provider_user_id"`
	AccessToken         string               `json:"access_token"`
	RefreshToken        string               `json:"refresh_token"`
	TokenExpiresAt      time.Time            `json:"token_expires_at"`
	DateCreated         types.Timestamp      `json:"date_created"`
}

func (q *Queries) CreateUserOauth(ctx context.Context, arg CreateUserOauthParams) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, createUserOauth,
		arg.UserOAuthID,
		arg.UserID,
		arg.OauthProvider,
		arg.OAuthProviderUserID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenExpiresAt,
		arg.DateCreated,
	)
	var i UserOauth
	err := row.Scan(
		&i.UserOAuthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OAuthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const createUserOauthTable = `-- name: CreateUserOauthTable :exec
CREATE TABLE IF NOT EXISTS user_oauth (
    user_oauth_id TEXT PRIMARY KEY NOT NULL,
    user_id TEXT NOT NULL
        REFERENCES users
            ON UPDATE CASCADE ON DELETE CASCADE,
    oauth_provider VARCHAR(255) NOT NULL,
    oauth_provider_user_id VARCHAR(255) NOT NULL,
    access_token  TEXT NOT NULL,
    refresh_token TEXT NOT NULL,
    token_expires_at TIMESTAMP NOT NULL,
    date_created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateUserOauthTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUserOauthTable)
	return err
}

const createUserSshKey = `-- name: CreateUserSshKey :one
INSERT INTO user_ssh_keys (
    ssh_key_id,
    user_id,
    public_key,
    key_type,
    fingerprint,
    label,
    date_created
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING ssh_key_id, user_id, public_key, key_type, fingerprint, label, date_created, last_used
`

type CreateUserSshKeyParams struct {
	SSHKeyID    string               `json:"ssh_key_id"`
	UserID      types.NullableUserID `json:"user_id"`
	PublicKey   string               `json:"public_key"`
	KeyType     string               `json:"key_type"`
	Fingerprint string               `json:"fingerprint"`
	Label       sql.NullString       `json:"label"`
	DateCreated types.Timestamp      `json:"date_created"`
}

func (q *Queries) CreateUserSshKey(ctx context.Context, arg CreateUserSshKeyParams) (UserSshKeys, error) {
	row := q.db.QueryRowContext(ctx, createUserSshKey,
		arg.SSHKeyID,
		arg.UserID,
		arg.PublicKey,
		arg.KeyType,
		arg.Fingerprint,
		arg.Label,
		arg.DateCreated,
	)
	var i UserSshKeys
	err := row.Scan(
		&i.SSHKeyID,
		&i.UserID,
		&i.PublicKey,
		&i.KeyType,
		&i.Fingerprint,
		&i.Label,
		&i.DateCreated,
		&i.LastUsed,
	)
	return i, err
}

const createUserSshKeyTable = `-- name: CreateUserSshKeyTable :exec
CREATE TABLE IF NOT EXISTS user_ssh_keys (
    ssh_key_id TEXT PRIMARY KEY NOT NULL,
    user_id TEXT NOT NULL,
    public_key TEXT NOT NULL,
    key_type VARCHAR(50) NOT NULL,
    fingerprint VARCHAR(255) NOT NULL UNIQUE,
    label VARCHAR(255),
    date_created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_used TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
)
`

func (q *Queries) CreateUserSshKeyTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUserSshKeyTable)
	return err
}

const createUserTable = `-- name: CreateUserTable :exec
CREATE TABLE IF NOT EXISTS users (
    user_id TEXT PRIMARY KEY NOT NULL,
    username TEXT NOT NULL
        UNIQUE,
    name TEXT NOT NULL,
    email TEXT NOT NULL,
    hash TEXT NOT NULL,
    role TEXT NOT NULL
        CONSTRAINT fk_users_role
            REFERENCES roles
            ON UPDATE CASCADE ON DELETE SET NULL,
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`

func (q *Queries) CreateUserTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUserTable)
	return err
}

const createUsersEmailIndex = `-- name: CreateUsersEmailIndex :exec
CREATE INDEX idx_users_email 
    ON users (email)
`

func (q *Queries) CreateUsersEmailIndex(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createUsersEmailIndex)
	return err
}

const createVerification = `-- name: CreateVerification :one

INSERT INTO backup_verifications (
    verification_id, backup_id, verified_at, verified_by,
    restore_tested, checksum_valid, record_count_match,
    status, error_message, duration_ms
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING verification_id, backup_id, verified_at, verified_by, restore_tested, checksum_valid, record_count_match, status, error_message, duration_ms
`

type CreateVerificationParams struct {
	VerificationID   types.VerificationID     `json:"verification_id"`
	BackupID         types.BackupID           `json:"backup_id"`
	VerifiedAt       types.Timestamp          `json:"verified_at"`
	VerifiedBy       types.NullableString     `json:"verified_by"`
	RestoreTested    types.NullableBool       `json:"restore_tested"`
	ChecksumValid    types.NullableBool       `json:"checksum_valid"`
	RecordCountMatch types.NullableBool       `json:"record_count_match"`
	Status           types.VerificationStatus `json:"status"`
	ErrorMessage     types.NullableString     `json:"error_message"`
	DurationMs       types.NullableInt64      `json:"duration_ms"`
}

// Backup Verifications CRUD
func (q *Queries) CreateVerification(ctx context.Context, arg CreateVerificationParams) (BackupVerification, error) {
	row := q.db.QueryRowContext(ctx, createVerification,
		arg.VerificationID,
		arg.BackupID,
		arg.VerifiedAt,
		arg.VerifiedBy,
		arg.RestoreTested,
		arg.ChecksumValid,
		arg.RecordCountMatch,
		arg.Status,
		arg.ErrorMessage,
		arg.DurationMs,
	)
	var i BackupVerification
	err := row.Scan(
		&i.VerificationID,
		&i.BackupID,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.RestoreTested,
		&i.ChecksumValid,
		&i.RecordCountMatch,
		&i.Status,
		&i.ErrorMessage,
		&i.DurationMs,
	)
	return i, err
}

const deleteAdminContentData = `-- name: DeleteAdminContentData :exec
DELETE FROM admin_content_data
WHERE admin_content_data_id = $1
`

type DeleteAdminContentDataParams struct {
	AdminContentDataID types.AdminContentID `json:"admin_content_data_id"`
}

func (q *Queries) DeleteAdminContentData(ctx context.Context, arg DeleteAdminContentDataParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdminContentData, arg.AdminContentDataID)
	return err
}

const deleteAdminContentField = `-- name: DeleteAdminContentField :exec
DELETE FROM admin_content_fields
WHERE admin_content_field_id = $1
`

type DeleteAdminContentFieldParams struct {
	AdminContentFieldID types.AdminContentFieldID `json:"admin_content_field_id"`
}

func (q *Queries) DeleteAdminContentField(ctx context.Context, arg DeleteAdminContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdminContentField, arg.AdminContentFieldID)
	return err
}

const deleteAdminContentRelation = `-- name: DeleteAdminContentRelation :exec
DELETE FROM admin_content_relations
WHERE admin_content_relation_id = $1
`

type DeleteAdminContentRelationParams struct {
	AdminContentRelationID types.AdminContentRelationID `json:"admin_content_relation_id"`
}

func (q *Queries) DeleteAdminContentRelation(ctx context.Context, arg DeleteAdminContentRelationParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdminContentRelation, arg.AdminContentRelationID)
	return err
}

const deleteAdminDatatype = `-- name: DeleteAdminDatatype :exec
DELETE FROM admin_datatypes
WHERE admin_datatype_id = $1
`

type DeleteAdminDatatypeParams struct {
	AdminDatatypeID types.AdminDatatypeID `json:"admin_datatype_id"`
}

func (q *Queries) DeleteAdminDatatype(ctx context.Context, arg DeleteAdminDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdminDatatype, arg.AdminDatatypeID)
	return err
}

const deleteAdminDatatypeField = `-- name: DeleteAdminDatatypeField :exec
DELETE FROM admin_datatypes_fields
WHERE id = $1
`

type DeleteAdminDatatypeFieldParams struct {
	ID string `json:"id"`
}

func (q *Queries) DeleteAdminDatatypeField(ctx context.Context, arg DeleteAdminDatatypeFieldParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdminDatatypeField, arg.ID)
	return err
}

const deleteAdminField = `-- name: DeleteAdminField :exec
DELETE FROM admin_fields
WHERE admin_field_id = $1
`

type DeleteAdminFieldParams struct {
	AdminFieldID types.AdminFieldID `json:"admin_field_id"`
}

func (q *Queries) DeleteAdminField(ctx context.Context, arg DeleteAdminFieldParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdminField, arg.AdminFieldID)
	return err
}

const deleteAdminRoute = `-- name: DeleteAdminRoute :exec
DELETE FROM admin_routes
WHERE admin_route_id = $1
`

type DeleteAdminRouteParams struct {
	AdminRouteID types.AdminRouteID `json:"admin_route_id"`
}

func (q *Queries) DeleteAdminRoute(ctx context.Context, arg DeleteAdminRouteParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdminRoute, arg.AdminRouteID)
	return err
}

const deleteBackup = `-- name: DeleteBackup :exec
DELETE FROM backups
WHERE backup_id = $1
`

type DeleteBackupParams struct {
	BackupID types.BackupID `json:"backup_id"`
}

func (q *Queries) DeleteBackup(ctx context.Context, arg DeleteBackupParams) error {
	_, err := q.db.ExecContext(ctx, deleteBackup, arg.BackupID)
	return err
}

const deleteBackupSet = `-- name: DeleteBackupSet :exec
DELETE FROM backup_sets
WHERE backup_set_id = $1
`

type DeleteBackupSetParams struct {
	BackupSetID types.BackupSetID `json:"backup_set_id"`
}

func (q *Queries) DeleteBackupSet(ctx context.Context, arg DeleteBackupSetParams) error {
	_, err := q.db.ExecContext(ctx, deleteBackupSet, arg.BackupSetID)
	return err
}

const deleteChangeEvent = `-- name: DeleteChangeEvent :exec
DELETE FROM change_events
WHERE event_id = $1
`

type DeleteChangeEventParams struct {
	EventID types.EventID `json:"event_id"`
}

func (q *Queries) DeleteChangeEvent(ctx context.Context, arg DeleteChangeEventParams) error {
	_, err := q.db.ExecContext(ctx, deleteChangeEvent, arg.EventID)
	return err
}

const deleteChangeEventsOlderThan = `-- name: DeleteChangeEventsOlderThan :exec
DELETE FROM change_events
WHERE wall_timestamp < $1
AND synced_at IS NOT NULL
AND consumed_at IS NOT NULL
`

type DeleteChangeEventsOlderThanParams struct {
	WallTimestamp types.Timestamp `json:"wall_timestamp"`
}

func (q *Queries) DeleteChangeEventsOlderThan(ctx context.Context, arg DeleteChangeEventsOlderThanParams) error {
	_, err := q.db.ExecContext(ctx, deleteChangeEventsOlderThan, arg.WallTimestamp)
	return err
}

const deleteContentData = `-- name: DeleteContentData :exec
DELETE FROM content_data
WHERE content_data_id = $1
`

type DeleteContentDataParams struct {
	ContentDataID types.ContentID `json:"content_data_id"`
}

func (q *Queries) DeleteContentData(ctx context.Context, arg DeleteContentDataParams) error {
	_, err := q.db.ExecContext(ctx, deleteContentData, arg.ContentDataID)
	return err
}

const deleteContentField = `-- name: DeleteContentField :exec
DELETE FROM content_fields
WHERE content_field_id = $1
`

type DeleteContentFieldParams struct {
	ContentFieldID types.ContentFieldID `json:"content_field_id"`
}

func (q *Queries) DeleteContentField(ctx context.Context, arg DeleteContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, deleteContentField, arg.ContentFieldID)
	return err
}

const deleteContentRelation = `-- name: DeleteContentRelation :exec
DELETE FROM content_relations
WHERE content_relation_id = $1
`

type DeleteContentRelationParams struct {
	ContentRelationID types.ContentRelationID `json:"content_relation_id"`
}

func (q *Queries) DeleteContentRelation(ctx context.Context, arg DeleteContentRelationParams) error {
	_, err := q.db.ExecContext(ctx, deleteContentRelation, arg.ContentRelationID)
	return err
}

const deleteDatatype = `-- name: DeleteDatatype :exec
DELETE FROM datatypes
WHERE datatype_id = $1
`

type DeleteDatatypeParams struct {
	DatatypeID types.DatatypeID `json:"datatype_id"`
}

func (q *Queries) DeleteDatatype(ctx context.Context, arg DeleteDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, deleteDatatype, arg.DatatypeID)
	return err
}

const deleteDatatypeField = `-- name: DeleteDatatypeField :exec
DELETE FROM datatypes_fields
WHERE id = $1
`

type DeleteDatatypeFieldParams struct {
	ID string `json:"id"`
}

func (q *Queries) DeleteDatatypeField(ctx context.Context, arg DeleteDatatypeFieldParams) error {
	_, err := q.db.ExecContext(ctx, deleteDatatypeField, arg.ID)
	return err
}

const deleteField = `-- name: DeleteField :exec
DELETE FROM fields
WHERE field_id = $1
`

type DeleteFieldParams struct {
	FieldID types.FieldID `json:"field_id"`
}

func (q *Queries) DeleteField(ctx context.Context, arg DeleteFieldParams) error {
	_, err := q.db.ExecContext(ctx, deleteField, arg.FieldID)
	return err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media
WHERE media_id = $1
`

type DeleteMediaParams struct {
	MediaID types.MediaID `json:"media_id"`
}

func (q *Queries) DeleteMedia(ctx context.Context, arg DeleteMediaParams) error {
	_, err := q.db.ExecContext(ctx, deleteMedia, arg.MediaID)
	return err
}

const deleteMediaDimension = `-- name: DeleteMediaDimension :exec
DELETE FROM media_dimensions
WHERE md_id = $1
`

type DeleteMediaDimensionParams struct {
	MdID string `json:"md_id"`
}

func (q *Queries) DeleteMediaDimension(ctx context.Context, arg DeleteMediaDimensionParams) error {
	_, err := q.db.ExecContext(ctx, deleteMediaDimension, arg.MdID)
	return err
}

const deleteOldBackups = `-- name: DeleteOldBackups :exec
DELETE FROM backups
WHERE started_at < $1 AND status IN ('completed', 'verified')
`

type DeleteOldBackupsParams struct {
	StartedAt types.Timestamp `json:"started_at"`
}

func (q *Queries) DeleteOldBackups(ctx context.Context, arg DeleteOldBackupsParams) error {
	_, err := q.db.ExecContext(ctx, deleteOldBackups, arg.StartedAt)
	return err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions 
WHERE permission_id = $1
`

type DeletePermissionParams struct {
	PermissionID types.PermissionID `json:"permission_id"`
}

func (q *Queries) DeletePermission(ctx context.Context, arg DeletePermissionParams) error {
	_, err := q.db.ExecContext(ctx, deletePermission, arg.PermissionID)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE role_id = $1
`

type DeleteRoleParams struct {
	RoleID types.RoleID `json:"role_id"`
}

func (q *Queries) DeleteRole(ctx context.Context, arg DeleteRoleParams) error {
	_, err := q.db.ExecContext(ctx, deleteRole, arg.RoleID)
	return err
}

const deleteRoute = `-- name: DeleteRoute :exec
DELETE FROM routes
WHERE route_id = $1
`

type DeleteRouteParams struct {
	RouteID types.RouteID `json:"route_id"`
}

func (q *Queries) DeleteRoute(ctx context.Context, arg DeleteRouteParams) error {
	_, err := q.db.ExecContext(ctx, deleteRoute, arg.RouteID)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE session_id = $1
`

type DeleteSessionParams struct {
	SessionID types.SessionID `json:"session_id"`
}

func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) error {
	_, err := q.db.ExecContext(ctx, deleteSession, arg.SessionID)
	return err
}

const deleteTable = `-- name: DeleteTable :exec
DELETE FROM tables
WHERE id = $1
`

type DeleteTableParams struct {
	ID string `json:"id"`
}

func (q *Queries) DeleteTable(ctx context.Context, arg DeleteTableParams) error {
	_, err := q.db.ExecContext(ctx, deleteTable, arg.ID)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM tokens
WHERE id = $1
`

type DeleteTokenParams struct {
	ID string `json:"id"`
}

func (q *Queries) DeleteToken(ctx context.Context, arg DeleteTokenParams) error {
	_, err := q.db.ExecContext(ctx, deleteToken, arg.ID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = $1
`

type DeleteUserParams struct {
	UserID types.UserID `json:"user_id"`
}

func (q *Queries) DeleteUser(ctx context.Context, arg DeleteUserParams) error {
	_, err := q.db.ExecContext(ctx, deleteUser, arg.UserID)
	return err
}

const deleteUserOauth = `-- name: DeleteUserOauth :exec
DELETE FROM user_oauth
WHERE user_oauth_id = $1
`

type DeleteUserOauthParams struct {
	UserOAuthID types.UserOauthID `json:"user_oauth_id"`
}

func (q *Queries) DeleteUserOauth(ctx context.Context, arg DeleteUserOauthParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserOauth, arg.UserOAuthID)
	return err
}

const deleteUserSshKey = `-- name: DeleteUserSshKey :exec
DELETE FROM user_ssh_keys
WHERE ssh_key_id = $1
`

type DeleteUserSshKeyParams struct {
	SSHKeyID string `json:"ssh_key_id"`
}

func (q *Queries) DeleteUserSshKey(ctx context.Context, arg DeleteUserSshKeyParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserSshKey, arg.SSHKeyID)
	return err
}

const deleteVerification = `-- name: DeleteVerification :exec
DELETE FROM backup_verifications
WHERE verification_id = $1
`

type DeleteVerificationParams struct {
	VerificationID types.VerificationID `json:"verification_id"`
}

func (q *Queries) DeleteVerification(ctx context.Context, arg DeleteVerificationParams) error {
	_, err := q.db.ExecContext(ctx, deleteVerification, arg.VerificationID)
	return err
}

const dropAdminContentDataTable = `-- name: DropAdminContentDataTable :exec
DROP TABLE admin_content_data
`

func (q *Queries) DropAdminContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminContentDataTable)
	return err
}

const dropAdminContentFieldTable = `-- name: DropAdminContentFieldTable :exec
DROP TABLE admin_content_fields
`

func (q *Queries) DropAdminContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminContentFieldTable)
	return err
}

const dropAdminContentRelationTable = `-- name: DropAdminContentRelationTable :exec
DROP TABLE IF EXISTS admin_content_relations
`

func (q *Queries) DropAdminContentRelationTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminContentRelationTable)
	return err
}

const dropAdminDatatypeTable = `-- name: DropAdminDatatypeTable :exec
DROP TABLE admin_datatypes
`

func (q *Queries) DropAdminDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminDatatypeTable)
	return err
}

const dropAdminDatatypesFieldsTable = `-- name: DropAdminDatatypesFieldsTable :exec
DROP TABLE admin_datatypes_fields
`

func (q *Queries) DropAdminDatatypesFieldsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminDatatypesFieldsTable)
	return err
}

const dropAdminFieldTable = `-- name: DropAdminFieldTable :exec
DROP TABLE admin_fields
`

func (q *Queries) DropAdminFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminFieldTable)
	return err
}

const dropAdminRouteTable = `-- name: DropAdminRouteTable :exec
DROP TABLE admin_routes
`

func (q *Queries) DropAdminRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAdminRouteTable)
	return err
}

const dropAllTables = `-- name: DropAllTables :exec
DROP TABLE IF EXISTS admin_content_relations
`

func (q *Queries) DropAllTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropAllTables)
	return err
}

const dropBackupSetsTable = `-- name: DropBackupSetsTable :exec
DROP TABLE IF EXISTS backup_sets
`

func (q *Queries) DropBackupSetsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropBackupSetsTable)
	return err
}

const dropBackupTables = `-- name: DropBackupTables :exec
DROP TABLE IF EXISTS backup_sets
`

func (q *Queries) DropBackupTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropBackupTables)
	return err
}

const dropBackupVerificationsTable = `-- name: DropBackupVerificationsTable :exec
DROP TABLE IF EXISTS backup_verifications
`

func (q *Queries) DropBackupVerificationsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropBackupVerificationsTable)
	return err
}

const dropBackupsTable = `-- name: DropBackupsTable :exec
DROP TABLE IF EXISTS backups
`

func (q *Queries) DropBackupsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropBackupsTable)
	return err
}

const dropChangeEventsTable = `-- name: DropChangeEventsTable :exec
DROP TABLE IF EXISTS change_events
`

func (q *Queries) DropChangeEventsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropChangeEventsTable)
	return err
}

const dropContentDataTable = `-- name: DropContentDataTable :exec
DROP TABLE content_data
`

func (q *Queries) DropContentDataTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropContentDataTable)
	return err
}

const dropContentFieldTable = `-- name: DropContentFieldTable :exec
DROP TABLE content_fields
`

func (q *Queries) DropContentFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropContentFieldTable)
	return err
}

const dropContentRelationTable = `-- name: DropContentRelationTable :exec
DROP TABLE IF EXISTS content_relations
`

func (q *Queries) DropContentRelationTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropContentRelationTable)
	return err
}

const dropDatatypeTable = `-- name: DropDatatypeTable :exec
DROP TABLE datatypes
`

func (q *Queries) DropDatatypeTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropDatatypeTable)
	return err
}

const dropDatatypesFieldsTable = `-- name: DropDatatypesFieldsTable :exec
DROP TABLE datatypes_fields
`

func (q *Queries) DropDatatypesFieldsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropDatatypesFieldsTable)
	return err
}

const dropFieldTable = `-- name: DropFieldTable :exec
DROP TABLE fields
`

func (q *Queries) DropFieldTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropFieldTable)
	return err
}

const dropMediaDimensionTable = `-- name: DropMediaDimensionTable :exec
DROP TABLE media_dimensions
`

func (q *Queries) DropMediaDimensionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropMediaDimensionTable)
	return err
}

const dropMediaTable = `-- name: DropMediaTable :exec
DROP TABLE media
`

func (q *Queries) DropMediaTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropMediaTable)
	return err
}

const dropPermissionTable = `-- name: DropPermissionTable :exec
DROP TABLE permissions
`

func (q *Queries) DropPermissionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropPermissionTable)
	return err
}

const dropRoleTable = `-- name: DropRoleTable :exec
DROP TABLE roles
`

func (q *Queries) DropRoleTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropRoleTable)
	return err
}

const dropRouteTable = `-- name: DropRouteTable :exec
DROP TABLE routes
`

func (q *Queries) DropRouteTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropRouteTable)
	return err
}

const dropSessionTable = `-- name: DropSessionTable :exec
DROP TABLE sessions
`

func (q *Queries) DropSessionTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropSessionTable)
	return err
}

const dropTableTable = `-- name: DropTableTable :exec
DROP TABLE tables
`

func (q *Queries) DropTableTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropTableTable)
	return err
}

const dropTokenTable = `-- name: DropTokenTable :exec
DROP TABLE tokens
`

func (q *Queries) DropTokenTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropTokenTable)
	return err
}

const dropUserOauthTable = `-- name: DropUserOauthTable :exec
DROP TABLE user_oauth
`

func (q *Queries) DropUserOauthTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropUserOauthTable)
	return err
}

const dropUserSshKeyTable = `-- name: DropUserSshKeyTable :exec
DROP TABLE user_ssh_keys
`

func (q *Queries) DropUserSshKeyTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropUserSshKeyTable)
	return err
}

const dropUserTable = `-- name: DropUserTable :exec
DROP TABLE users
`

func (q *Queries) DropUserTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, dropUserTable)
	return err
}

const getAdminContentData = `-- name: GetAdminContentData :one
SELECT admin_content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, admin_route_id, admin_datatype_id, author_id, status, date_created, date_modified FROM admin_content_data
WHERE admin_content_data_id = $1 LIMIT 1
`

type GetAdminContentDataParams struct {
	AdminContentDataID types.AdminContentID `json:"admin_content_data_id"`
}

func (q *Queries) GetAdminContentData(ctx context.Context, arg GetAdminContentDataParams) (AdminContentData, error) {
	row := q.db.QueryRowContext(ctx, getAdminContentData, arg.AdminContentDataID)
	var i AdminContentData
	err := row.Scan(
		&i.AdminContentDataID,
		&i.ParentID,
		&i.FirstChildID,
		&i.NextSiblingID,
		&i.PrevSiblingID,
		&i.AdminRouteID,
		&i.AdminDatatypeID,
		&i.AuthorID,
		&i.Status,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getAdminContentField = `-- name: GetAdminContentField :one
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, author_id, date_created, date_modified FROM admin_content_fields
WHERE admin_content_field_id = $1 LIMIT 1
`

type GetAdminContentFieldParams struct {
	AdminContentFieldID types.AdminContentFieldID `json:"admin_content_field_id"`
}

func (q *Queries) GetAdminContentField(ctx context.Context, arg GetAdminContentFieldParams) (AdminContentFields, error) {
	row := q.db.QueryRowContext(ctx, getAdminContentField, arg.AdminContentFieldID)
	var i AdminContentFields
	err := row.Scan(
		&i.AdminContentFieldID,
		&i.AdminRouteID,
		&i.AdminContentDataID,
		&i.AdminFieldID,
		&i.AdminFieldValue,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getAdminContentRelation = `-- name: GetAdminContentRelation :one
SELECT admin_content_relation_id, source_content_id, target_content_id, admin_field_id, sort_order, date_created FROM admin_content_relations
WHERE admin_content_relation_id = $1 LIMIT 1
`

type GetAdminContentRelationParams struct {
	AdminContentRelationID types.AdminContentRelationID `json:"admin_content_relation_id"`
}

func (q *Queries) GetAdminContentRelation(ctx context.Context, arg GetAdminContentRelationParams) (AdminContentRelations, error) {
	row := q.db.QueryRowContext(ctx, getAdminContentRelation, arg.AdminContentRelationID)
	var i AdminContentRelations
	err := row.Scan(
		&i.AdminContentRelationID,
		&i.SourceContentID,
		&i.TargetContentID,
		&i.AdminFieldID,
		&i.SortOrder,
		&i.DateCreated,
	)
	return i, err
}

const getAdminDatatype = `-- name: GetAdminDatatype :one
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM admin_datatypes
WHERE admin_datatype_id = $1
LIMIT 1
`

type GetAdminDatatypeParams struct {
	AdminDatatypeID types.AdminDatatypeID `json:"admin_datatype_id"`
}

func (q *Queries) GetAdminDatatype(ctx context.Context, arg GetAdminDatatypeParams) (AdminDatatypes, error) {
	row := q.db.QueryRowContext(ctx, getAdminDatatype, arg.AdminDatatypeID)
	var i AdminDatatypes
	err := row.Scan(
		&i.AdminDatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getAdminField = `-- name: GetAdminField :one
SELECT admin_field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified
FROM admin_fields
WHERE admin_field_id = $1
LIMIT 1
`

type GetAdminFieldParams struct {
	AdminFieldID types.AdminFieldID `json:"admin_field_id"`
}

func (q *Queries) GetAdminField(ctx context.Context, arg GetAdminFieldParams) (AdminFields, error) {
	row := q.db.QueryRowContext(ctx, getAdminField, arg.AdminFieldID)
	var i AdminFields
	err := row.Scan(
		&i.AdminFieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Validation,
		&i.UiConfig,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getAdminRoute = `-- name: GetAdminRoute :one
SELECT admin_route_id, slug, title, status, author_id, date_created, date_modified FROM admin_routes
WHERE admin_route_id = $1 LIMIT 1
`

type GetAdminRouteParams struct {
	AdminRouteID types.AdminRouteID `json:"admin_route_id"`
}

func (q *Queries) GetAdminRoute(ctx context.Context, arg GetAdminRouteParams) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, getAdminRoute, arg.AdminRouteID)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getAdminRouteBySlug = `-- name: GetAdminRouteBySlug :one
SELECT admin_route_id, slug, title, status, author_id, date_created, date_modified FROM admin_routes
WHERE slug = $1 LIMIT 1
`

type GetAdminRouteBySlugParams struct {
	Slug types.Slug `json:"slug"`
}

func (q *Queries) GetAdminRouteBySlug(ctx context.Context, arg GetAdminRouteBySlugParams) (AdminRoutes, error) {
	row := q.db.QueryRowContext(ctx, getAdminRouteBySlug, arg.Slug)
	var i AdminRoutes
	err := row.Scan(
		&i.AdminRouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getAdminRouteIdBySlug = `-- name: GetAdminRouteIdBySlug :one
SELECT admin_route_id FROM admin_routes
WHERE slug = $1 LIMIT 1
`

type GetAdminRouteIdBySlugParams struct {
	Slug types.Slug `json:"slug"`
}

func (q *Queries) GetAdminRouteIdBySlug(ctx context.Context, arg GetAdminRouteIdBySlugParams) (types.AdminRouteID, error) {
	row := q.db.QueryRowContext(ctx, getAdminRouteIdBySlug, arg.Slug)
	var admin_route_id types.AdminRouteID
	err := row.Scan(&admin_route_id)
	return admin_route_id, err
}

const getBackup = `-- name: GetBackup :one
SELECT backup_id, node_id, backup_type, status, started_at, completed_at, duration_ms, record_count, size_bytes, replication_lsn, hlc_timestamp, storage_path, checksum, triggered_by, error_message, metadata FROM backups
WHERE backup_id = $1 LIMIT 1
`

type GetBackupParams struct {
	BackupID types.BackupID `json:"backup_id"`
}

func (q *Queries) GetBackup(ctx context.Context, arg GetBackupParams) (Backup, error) {
	row := q.db.QueryRowContext(ctx, getBackup, arg.BackupID)
	var i Backup
	err := row.Scan(
		&i.BackupID,
		&i.NodeID,
		&i.BackupType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.RecordCount,
		&i.SizeBytes,
		&i.ReplicationLsn,
		&i.HlcTimestamp,
		&i.StoragePath,
		&i.Checksum,
		&i.TriggeredBy,
		&i.ErrorMessage,
		&i.Metadata,
	)
	return i, err
}

const getBackupSet = `-- name: GetBackupSet :one
SELECT backup_set_id, created_at, hlc_timestamp, status, backup_ids, node_count, completed_count, error_message FROM backup_sets
WHERE backup_set_id = $1 LIMIT 1
`

type GetBackupSetParams struct {
	BackupSetID types.BackupSetID `json:"backup_set_id"`
}

func (q *Queries) GetBackupSet(ctx context.Context, arg GetBackupSetParams) (BackupSet, error) {
	row := q.db.QueryRowContext(ctx, getBackupSet, arg.BackupSetID)
	var i BackupSet
	err := row.Scan(
		&i.BackupSetID,
		&i.CreatedAt,
		&i.HlcTimestamp,
		&i.Status,
		&i.BackupIds,
		&i.NodeCount,
		&i.CompletedCount,
		&i.ErrorMessage,
	)
	return i, err
}

const getBackupSetByHLC = `-- name: GetBackupSetByHLC :one
SELECT backup_set_id, created_at, hlc_timestamp, status, backup_ids, node_count, completed_count, error_message FROM backup_sets
WHERE hlc_timestamp = $1
ORDER BY created_at DESC
LIMIT 1
`

type GetBackupSetByHLCParams struct {
	HlcTimestamp types.HLC `json:"hlc_timestamp"`
}

func (q *Queries) GetBackupSetByHLC(ctx context.Context, arg GetBackupSetByHLCParams) (BackupSet, error) {
	row := q.db.QueryRowContext(ctx, getBackupSetByHLC, arg.HlcTimestamp)
	var i BackupSet
	err := row.Scan(
		&i.BackupSetID,
		&i.CreatedAt,
		&i.HlcTimestamp,
		&i.Status,
		&i.BackupIds,
		&i.NodeCount,
		&i.CompletedCount,
		&i.ErrorMessage,
	)
	return i, err
}

const getBackupsByHLCRange = `-- name: GetBackupsByHLCRange :many
SELECT backup_id, node_id, backup_type, status, started_at, completed_at, duration_ms, record_count, size_bytes, replication_lsn, hlc_timestamp, storage_path, checksum, triggered_by, error_message, metadata FROM backups
WHERE hlc_timestamp >= $1 AND hlc_timestamp <= $2
ORDER BY hlc_timestamp ASC
`

type GetBackupsByHLCRangeParams struct {
	HlcTimestamp   types.HLC `json:"hlc_timestamp"`
	HlcTimestamp_2 types.HLC `json:"hlc_timestamp_2"`
}

func (q *Queries) GetBackupsByHLCRange(ctx context.Context, arg GetBackupsByHLCRangeParams) ([]Backup, error) {
	rows, err := q.db.QueryContext(ctx, getBackupsByHLCRange, arg.HlcTimestamp, arg.HlcTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.BackupID,
			&i.NodeID,
			&i.BackupType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RecordCount,
			&i.SizeBytes,
			&i.ReplicationLsn,
			&i.HlcTimestamp,
			&i.StoragePath,
			&i.Checksum,
			&i.TriggeredBy,
			&i.ErrorMessage,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackupsByNode = `-- name: GetBackupsByNode :many
SELECT backup_id, node_id, backup_type, status, started_at, completed_at, duration_ms, record_count, size_bytes, replication_lsn, hlc_timestamp, storage_path, checksum, triggered_by, error_message, metadata FROM backups
WHERE node_id = $1
ORDER BY started_at DESC
LIMIT $2 OFFSET $3
`

type GetBackupsByNodeParams struct {
	NodeID types.NodeID `json:"node_id"`
	Limit  int32        `json:"limit"`
	Offset int32        `json:"offset"`
}

func (q *Queries) GetBackupsByNode(ctx context.Context, arg GetBackupsByNodeParams) ([]Backup, error) {
	rows, err := q.db.QueryContext(ctx, getBackupsByNode, arg.NodeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.BackupID,
			&i.NodeID,
			&i.BackupType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RecordCount,
			&i.SizeBytes,
			&i.ReplicationLsn,
			&i.HlcTimestamp,
			&i.StoragePath,
			&i.Checksum,
			&i.TriggeredBy,
			&i.ErrorMessage,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackupsByStatus = `-- name: GetBackupsByStatus :many
SELECT backup_id, node_id, backup_type, status, started_at, completed_at, duration_ms, record_count, size_bytes, replication_lsn, hlc_timestamp, storage_path, checksum, triggered_by, error_message, metadata FROM backups
WHERE status = $1
ORDER BY started_at DESC
LIMIT $2 OFFSET $3
`

type GetBackupsByStatusParams struct {
	Status types.BackupStatus `json:"status"`
	Limit  int32              `json:"limit"`
	Offset int32              `json:"offset"`
}

func (q *Queries) GetBackupsByStatus(ctx context.Context, arg GetBackupsByStatusParams) ([]Backup, error) {
	rows, err := q.db.QueryContext(ctx, getBackupsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.BackupID,
			&i.NodeID,
			&i.BackupType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RecordCount,
			&i.SizeBytes,
			&i.ReplicationLsn,
			&i.HlcTimestamp,
			&i.StoragePath,
			&i.Checksum,
			&i.TriggeredBy,
			&i.ErrorMessage,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangeEvent = `-- name: GetChangeEvent :one
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
WHERE event_id = $1 LIMIT 1
`

type GetChangeEventParams struct {
	EventID types.EventID `json:"event_id"`
}

func (q *Queries) GetChangeEvent(ctx context.Context, arg GetChangeEventParams) (ChangeEvent, error) {
	row := q.db.QueryRowContext(ctx, getChangeEvent, arg.EventID)
	var i ChangeEvent
	err := row.Scan(
		&i.EventID,
		&i.HlcTimestamp,
		&i.WallTimestamp,
		&i.NodeID,
		&i.TableName,
		&i.RecordID,
		&i.Operation,
		&i.Action,
		&i.UserID,
		&i.OldValues,
		&i.NewValues,
		&i.Metadata,
		&i.RequestId,
		&i.Ip,
		&i.SyncedAt,
		&i.ConsumedAt,
	)
	return i, err
}

const getChangeEventsByRecord = `-- name: GetChangeEventsByRecord :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
WHERE table_name = $1 AND record_id = $2
ORDER BY hlc_timestamp DESC
`

type GetChangeEventsByRecordParams struct {
	TableName string `json:"table_name"`
	RecordID  string `json:"record_id"`
}

func (q *Queries) GetChangeEventsByRecord(ctx context.Context, arg GetChangeEventsByRecordParams) ([]ChangeEvent, error) {
	rows, err := q.db.QueryContext(ctx, getChangeEventsByRecord, arg.TableName, arg.RecordID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChangeEvent{}
	for rows.Next() {
		var i ChangeEvent
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.RequestId,
			&i.Ip,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangeEventsByRecordPaginated = `-- name: GetChangeEventsByRecordPaginated :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
WHERE table_name = $1 AND record_id = $2
ORDER BY hlc_timestamp DESC
LIMIT $3 OFFSET $4
`

type GetChangeEventsByRecordPaginatedParams struct {
	TableName string `json:"table_name"`
	RecordID  string `json:"record_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) GetChangeEventsByRecordPaginated(ctx context.Context, arg GetChangeEventsByRecordPaginatedParams) ([]ChangeEvent, error) {
	rows, err := q.db.QueryContext(ctx, getChangeEventsByRecordPaginated,
		arg.TableName,
		arg.RecordID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChangeEvent{}
	for rows.Next() {
		var i ChangeEvent
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.RequestId,
			&i.Ip,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentData = `-- name: GetContentData :one
SELECT content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, route_id, datatype_id, author_id, status, date_created, date_modified FROM content_data
WHERE content_data_id = $1 LIMIT 1
`

type GetContentDataParams struct {
	ContentDataID types.ContentID `json:"content_data_id"`
}

func (q *Queries) GetContentData(ctx context.Context, arg GetContentDataParams) (ContentData, error) {
	row := q.db.QueryRowContext(ctx, getContentData, arg.ContentDataID)
	var i ContentData
	err := row.Scan(
		&i.ContentDataID,
		&i.ParentID,
		&i.FirstChildID,
		&i.NextSiblingID,
		&i.PrevSiblingID,
		&i.RouteID,
		&i.DatatypeID,
		&i.AuthorID,
		&i.Status,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getContentField = `-- name: GetContentField :one
SELECT content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified FROM content_fields
WHERE content_field_id = $1 LIMIT 1
`

type GetContentFieldParams struct {
	ContentFieldID types.ContentFieldID `json:"content_field_id"`
}

func (q *Queries) GetContentField(ctx context.Context, arg GetContentFieldParams) (ContentFields, error) {
	row := q.db.QueryRowContext(ctx, getContentField, arg.ContentFieldID)
	var i ContentFields
	err := row.Scan(
		&i.ContentFieldID,
		&i.RouteID,
		&i.ContentDataID,
		&i.FieldID,
		&i.FieldValue,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getContentFieldsByRoute = `-- name: GetContentFieldsByRoute :many
SELECT cf.content_data_id, cf.field_id, cf.field_value
FROM content_data cd
JOIN content_fields cf ON cd.content_data_id = cf.content_data_id
WHERE cd.route_id = $1
ORDER BY cf.content_data_id, cf.field_id
`

type GetContentFieldsByRouteParams struct {
	RouteID types.NullableRouteID `json:"route_id"`
}

type GetContentFieldsByRouteRow struct {
	ContentDataID types.NullableContentID `json:"content_data_id"`
	FieldID       types.NullableFieldID   `json:"field_id"`
	FieldValue    string                  `json:"field_value"`
}

func (q *Queries) GetContentFieldsByRoute(ctx context.Context, arg GetContentFieldsByRouteParams) ([]GetContentFieldsByRouteRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentFieldsByRoute, arg.RouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContentFieldsByRouteRow{}
	for rows.Next() {
		var i GetContentFieldsByRouteRow
		if err := rows.Scan(&i.ContentDataID, &i.FieldID, &i.FieldValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentRelation = `-- name: GetContentRelation :one
SELECT content_relation_id, source_content_id, target_content_id, field_id, sort_order, date_created FROM content_relations
WHERE content_relation_id = $1 LIMIT 1
`

type GetContentRelationParams struct {
	ContentRelationID types.ContentRelationID `json:"content_relation_id"`
}

func (q *Queries) GetContentRelation(ctx context.Context, arg GetContentRelationParams) (ContentRelations, error) {
	row := q.db.QueryRowContext(ctx, getContentRelation, arg.ContentRelationID)
	var i ContentRelations
	err := row.Scan(
		&i.ContentRelationID,
		&i.SourceContentID,
		&i.TargetContentID,
		&i.FieldID,
		&i.SortOrder,
		&i.DateCreated,
	)
	return i, err
}

const getContentTreeByRoute = `-- name: GetContentTreeByRoute :many
SELECT cd.content_data_id, 
        cd.parent_id, 
        cd.first_child_id,
        cd.next_sibling_id,
        cd.prev_sibling_id,
        cd.datatype_id, 
        cd.route_id, 
        cd.author_id, 
        cd.date_created,
        cd.date_modified,
        cd.status,
       dt.label as datatype_label, dt.type as datatype_type
FROM content_data cd
JOIN datatypes dt ON cd.datatype_id = dt.datatype_id
WHERE cd.route_id = $1
ORDER BY cd.parent_id NULLS FIRST, cd.content_data_id
`

type GetContentTreeByRouteParams struct {
	RouteID types.NullableRouteID `json:"route_id"`
}

type GetContentTreeByRouteRow struct {
	ContentDataID types.ContentID          `json:"content_data_id"`
	ParentID      types.NullableContentID  `json:"parent_id"`
	FirstChildID  sql.NullString           `json:"first_child_id"`
	NextSiblingID sql.NullString           `json:"next_sibling_id"`
	PrevSiblingID sql.NullString           `json:"prev_sibling_id"`
	DatatypeID    types.NullableDatatypeID `json:"datatype_id"`
	RouteID       types.NullableRouteID    `json:"route_id"`
	AuthorID      types.NullableUserID     `json:"author_id"`
	DateCreated   types.Timestamp          `json:"date_created"`
	DateModified  types.Timestamp          `json:"date_modified"`
	Status        types.ContentStatus      `json:"status"`
	DatatypeLabel string                   `json:"datatype_label"`
	DatatypeType  string                   `json:"datatype_type"`
}

func (q *Queries) GetContentTreeByRoute(ctx context.Context, arg GetContentTreeByRouteParams) ([]GetContentTreeByRouteRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentTreeByRoute, arg.RouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContentTreeByRouteRow{}
	for rows.Next() {
		var i GetContentTreeByRouteRow
		if err := rows.Scan(
			&i.ContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.DatatypeID,
			&i.RouteID,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
			&i.Status,
			&i.DatatypeLabel,
			&i.DatatypeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatatype = `-- name: GetDatatype :one
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM datatypes
WHERE datatype_id = $1 LIMIT 1
`

type GetDatatypeParams struct {
	DatatypeID types.DatatypeID `json:"datatype_id"`
}

func (q *Queries) GetDatatype(ctx context.Context, arg GetDatatypeParams) (Datatypes, error) {
	row := q.db.QueryRowContext(ctx, getDatatype, arg.DatatypeID)
	var i Datatypes
	err := row.Scan(
		&i.DatatypeID,
		&i.ParentID,
		&i.Label,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getField = `-- name: GetField :one
SELECT field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified FROM fields
WHERE field_id = $1 LIMIT 1
`

type GetFieldParams struct {
	FieldID types.FieldID `json:"field_id"`
}

func (q *Queries) GetField(ctx context.Context, arg GetFieldParams) (Fields, error) {
	row := q.db.QueryRowContext(ctx, getField, arg.FieldID)
	var i Fields
	err := row.Scan(
		&i.FieldID,
		&i.ParentID,
		&i.Label,
		&i.Data,
		&i.Validation,
		&i.UiConfig,
		&i.Type,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getFieldDefinitionsByRoute = `-- name: GetFieldDefinitionsByRoute :many
SELECT DISTINCT f.field_id, f.label, f.type, df.datatype_id
FROM content_data cd
JOIN datatypes_fields df ON cd.datatype_id = df.datatype_id
JOIN fields f ON df.field_id = f.field_id  
WHERE cd.route_id = $1
ORDER BY df.datatype_id, f.field_id
`

type GetFieldDefinitionsByRouteParams struct {
	RouteID types.NullableRouteID `json:"route_id"`
}

type GetFieldDefinitionsByRouteRow struct {
	FieldID    types.FieldID    `json:"field_id"`
	Label      string           `json:"label"`
	Type       types.FieldType  `json:"type"`
	DatatypeID types.DatatypeID `json:"datatype_id"`
}

func (q *Queries) GetFieldDefinitionsByRoute(ctx context.Context, arg GetFieldDefinitionsByRouteParams) ([]GetFieldDefinitionsByRouteRow, error) {
	rows, err := q.db.QueryContext(ctx, getFieldDefinitionsByRoute, arg.RouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFieldDefinitionsByRouteRow{}
	for rows.Next() {
		var i GetFieldDefinitionsByRouteRow
		if err := rows.Scan(
			&i.FieldID,
			&i.Label,
			&i.Type,
			&i.DatatypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestBackup = `-- name: GetLatestBackup :one
SELECT backup_id, node_id, backup_type, status, started_at, completed_at, duration_ms, record_count, size_bytes, replication_lsn, hlc_timestamp, storage_path, checksum, triggered_by, error_message, metadata FROM backups
WHERE node_id = $1 AND status = 'completed'
ORDER BY started_at DESC
LIMIT 1
`

type GetLatestBackupParams struct {
	NodeID types.NodeID `json:"node_id"`
}

func (q *Queries) GetLatestBackup(ctx context.Context, arg GetLatestBackupParams) (Backup, error) {
	row := q.db.QueryRowContext(ctx, getLatestBackup, arg.NodeID)
	var i Backup
	err := row.Scan(
		&i.BackupID,
		&i.NodeID,
		&i.BackupType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.RecordCount,
		&i.SizeBytes,
		&i.ReplicationLsn,
		&i.HlcTimestamp,
		&i.StoragePath,
		&i.Checksum,
		&i.TriggeredBy,
		&i.ErrorMessage,
		&i.Metadata,
	)
	return i, err
}

const getLatestBackupByType = `-- name: GetLatestBackupByType :one
SELECT backup_id, node_id, backup_type, status, started_at, completed_at, duration_ms, record_count, size_bytes, replication_lsn, hlc_timestamp, storage_path, checksum, triggered_by, error_message, metadata FROM backups
WHERE node_id = $1 AND backup_type = $2 AND status = 'completed'
ORDER BY started_at DESC
LIMIT 1
`

type GetLatestBackupByTypeParams struct {
	NodeID     types.NodeID     `json:"node_id"`
	BackupType types.BackupType `json:"backup_type"`
}

func (q *Queries) GetLatestBackupByType(ctx context.Context, arg GetLatestBackupByTypeParams) (Backup, error) {
	row := q.db.QueryRowContext(ctx, getLatestBackupByType, arg.NodeID, arg.BackupType)
	var i Backup
	err := row.Scan(
		&i.BackupID,
		&i.NodeID,
		&i.BackupType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.RecordCount,
		&i.SizeBytes,
		&i.ReplicationLsn,
		&i.HlcTimestamp,
		&i.StoragePath,
		&i.Checksum,
		&i.TriggeredBy,
		&i.ErrorMessage,
		&i.Metadata,
	)
	return i, err
}

const getLatestVerification = `-- name: GetLatestVerification :one
SELECT verification_id, backup_id, verified_at, verified_by, restore_tested, checksum_valid, record_count_match, status, error_message, duration_ms FROM backup_verifications
WHERE backup_id = $1
ORDER BY verified_at DESC
LIMIT 1
`

type GetLatestVerificationParams struct {
	BackupID types.BackupID `json:"backup_id"`
}

func (q *Queries) GetLatestVerification(ctx context.Context, arg GetLatestVerificationParams) (BackupVerification, error) {
	row := q.db.QueryRowContext(ctx, getLatestVerification, arg.BackupID)
	var i BackupVerification
	err := row.Scan(
		&i.VerificationID,
		&i.BackupID,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.RestoreTested,
		&i.ChecksumValid,
		&i.RecordCountMatch,
		&i.Status,
		&i.ErrorMessage,
		&i.DurationMs,
	)
	return i, err
}

const getMaxSortOrderByDatatypeID = `-- name: GetMaxSortOrderByDatatypeID :one
SELECT COALESCE(MAX(sort_order), -1)
FROM datatypes_fields
WHERE datatype_id = $1
`

type GetMaxSortOrderByDatatypeIDParams struct {
	DatatypeID types.DatatypeID `json:"datatype_id"`
}

func (q *Queries) GetMaxSortOrderByDatatypeID(ctx context.Context, arg GetMaxSortOrderByDatatypeIDParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxSortOrderByDatatypeID, arg.DatatypeID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getMedia = `-- name: GetMedia :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media
WHERE media_id = $1 LIMIT 1
`

type GetMediaParams struct {
	MediaID types.MediaID `json:"media_id"`
}

func (q *Queries) GetMedia(ctx context.Context, arg GetMediaParams) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMedia, arg.MediaID)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.URL,
		&i.Srcset,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaByName = `-- name: GetMediaByName :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media
WHERE name = $1 LIMIT 1
`

type GetMediaByNameParams struct {
	Name sql.NullString `json:"name"`
}

func (q *Queries) GetMediaByName(ctx context.Context, arg GetMediaByNameParams) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMediaByName, arg.Name)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.URL,
		&i.Srcset,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaByUrl = `-- name: GetMediaByUrl :one
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media
WHERE url = $1 LIMIT 1
`

type GetMediaByUrlParams struct {
	URL types.URL `json:"url"`
}

func (q *Queries) GetMediaByUrl(ctx context.Context, arg GetMediaByUrlParams) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMediaByUrl, arg.URL)
	var i Media
	err := row.Scan(
		&i.MediaID,
		&i.Name,
		&i.DisplayName,
		&i.Alt,
		&i.Caption,
		&i.Description,
		&i.Class,
		&i.Mimetype,
		&i.Dimensions,
		&i.URL,
		&i.Srcset,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getMediaDimension = `-- name: GetMediaDimension :one
SELECT md_id, label, width, height, aspect_ratio FROM media_dimensions
WHERE md_id = $1 LIMIT 1
`

type GetMediaDimensionParams struct {
	MdID string `json:"md_id"`
}

func (q *Queries) GetMediaDimension(ctx context.Context, arg GetMediaDimensionParams) (MediaDimensions, error) {
	row := q.db.QueryRowContext(ctx, getMediaDimension, arg.MdID)
	var i MediaDimensions
	err := row.Scan(
		&i.MdID,
		&i.Label,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
	)
	return i, err
}

const getPendingBackupSets = `-- name: GetPendingBackupSets :many
SELECT backup_set_id, created_at, hlc_timestamp, status, backup_ids, node_count, completed_count, error_message FROM backup_sets
WHERE status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) GetPendingBackupSets(ctx context.Context) ([]BackupSet, error) {
	rows, err := q.db.QueryContext(ctx, getPendingBackupSets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BackupSet{}
	for rows.Next() {
		var i BackupSet
		if err := rows.Scan(
			&i.BackupSetID,
			&i.CreatedAt,
			&i.HlcTimestamp,
			&i.Status,
			&i.BackupIds,
			&i.NodeCount,
			&i.CompletedCount,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermission = `-- name: GetPermission :one
SELECT permission_id, table_id, mode, label FROM permissions 
WHERE permission_id = $1 LIMIT 1
`

type GetPermissionParams struct {
	PermissionID types.PermissionID `json:"permission_id"`
}

func (q *Queries) GetPermission(ctx context.Context, arg GetPermissionParams) (Permissions, error) {
	row := q.db.QueryRowContext(ctx, getPermission, arg.PermissionID)
	var i Permissions
	err := row.Scan(
		&i.PermissionID,
		&i.TableID,
		&i.Mode,
		&i.Label,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT role_id, label, permissions 
FROM roles
WHERE role_id = $1
`

type GetRoleParams struct {
	RoleID types.RoleID `json:"role_id"`
}

func (q *Queries) GetRole(ctx context.Context, arg GetRoleParams) (Roles, error) {
	row := q.db.QueryRowContext(ctx, getRole, arg.RoleID)
	var i Roles
	err := row.Scan(&i.RoleID, &i.Label, &i.Permissions)
	return i, err
}

const getRoute = `-- name: GetRoute :one
SELECT route_id, slug, title, status, author_id, date_created, date_modified 
FROM routes
WHERE route_id = $1
LIMIT 1
`

type GetRouteParams struct {
	RouteID types.RouteID `json:"route_id"`
}

func (q *Queries) GetRoute(ctx context.Context, arg GetRouteParams) (Routes, error) {
	row := q.db.QueryRowContext(ctx, getRoute, arg.RouteID)
	var i Routes
	err := row.Scan(
		&i.RouteID,
		&i.Slug,
		&i.Title,
		&i.Status,
		&i.AuthorID,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getRouteIDBySlug = `-- name: GetRouteIDBySlug :one
SELECT route_id 
FROM routes
WHERE slug = $1
LIMIT 1
`

type GetRouteIDBySlugParams struct {
	Slug types.Slug `json:"slug"`
}

func (q *Queries) GetRouteIDBySlug(ctx context.Context, arg GetRouteIDBySlugParams) (types.RouteID, error) {
	row := q.db.QueryRowContext(ctx, getRouteIDBySlug, arg.Slug)
	var route_id types.RouteID
	err := row.Scan(&route_id)
	return route_id, err
}

const getRouteTreeByRouteID = `-- name: GetRouteTreeByRouteID :many
SELECT 
    cd.content_data_id,
    cd.parent_id,
    cd.first_child_id,
    cd.next_sibling_id,
    cd.prev_sibling_id,
    dt.label AS datatype_label,
    dt.type AS datatype_type,
    f.label AS field_label,
    f.type AS field_type,
    cf.field_value
FROM content_data cd
    INNER JOIN datatypes dt ON cd.datatype_id = dt.datatype_id
    INNER JOIN datatypes_fields df ON dt.datatype_id = df.datatype_id
    INNER JOIN fields f ON df.field_id = f.field_id
    LEFT JOIN content_fields cf ON cd.content_data_id = cf.content_data_id 
        AND f.field_id = cf.field_id
WHERE cd.route_id = $1
ORDER BY cd.content_data_id, f.field_id
`

type GetRouteTreeByRouteIDParams struct {
	RouteID types.NullableRouteID `json:"route_id"`
}

type GetRouteTreeByRouteIDRow struct {
	ContentDataID types.ContentID         `json:"content_data_id"`
	ParentID      types.NullableContentID `json:"parent_id"`
	FirstChildID  sql.NullString          `json:"first_child_id"`
	NextSiblingID sql.NullString          `json:"next_sibling_id"`
	PrevSiblingID sql.NullString          `json:"prev_sibling_id"`
	DatatypeLabel string                  `json:"datatype_label"`
	DatatypeType  string                  `json:"datatype_type"`
	FieldLabel    string                  `json:"field_label"`
	FieldType     types.FieldType         `json:"field_type"`
	FieldValue    sql.NullString          `json:"field_value"`
}

func (q *Queries) GetRouteTreeByRouteID(ctx context.Context, arg GetRouteTreeByRouteIDParams) ([]GetRouteTreeByRouteIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRouteTreeByRouteID, arg.RouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRouteTreeByRouteIDRow{}
	for rows.Next() {
		var i GetRouteTreeByRouteIDRow
		if err := rows.Scan(
			&i.ContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.DatatypeLabel,
			&i.DatatypeType,
			&i.FieldLabel,
			&i.FieldType,
			&i.FieldValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
WHERE session_id = $1 LIMIT 1
`

type GetSessionParams struct {
	SessionID types.SessionID `json:"session_id"`
}

func (q *Queries) GetSession(ctx context.Context, arg GetSessionParams) (Sessions, error) {
	row := q.db.QueryRowContext(ctx, getSession, arg.SessionID)
	var i Sessions
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccess,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionData,
	)
	return i, err
}

const getSessionByUserId = `-- name: GetSessionByUserId :one
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
WHERE user_id = $1
ORDER BY session_id DESC
LIMIT 1
`

type GetSessionByUserIdParams struct {
	UserID types.NullableUserID `json:"user_id"`
}

func (q *Queries) GetSessionByUserId(ctx context.Context, arg GetSessionByUserIdParams) (Sessions, error) {
	row := q.db.QueryRowContext(ctx, getSessionByUserId, arg.UserID)
	var i Sessions
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccess,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionData,
	)
	return i, err
}

const getTable = `-- name: GetTable :one
SELECT id, label, author_id FROM tables
WHERE id = $1
LIMIT 1
`

type GetTableParams struct {
	ID string `json:"id"`
}

func (q *Queries) GetTable(ctx context.Context, arg GetTableParams) (Tables, error) {
	row := q.db.QueryRowContext(ctx, getTable, arg.ID)
	var i Tables
	err := row.Scan(&i.ID, &i.Label, &i.AuthorID)
	return i, err
}

const getTableId = `-- name: GetTableId :one
SELECT id FROM tables
WHERE id = $1
LIMIT 1
`

type GetTableIdParams struct {
	ID string `json:"id"`
}

func (q *Queries) GetTableId(ctx context.Context, arg GetTableIdParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getTableId, arg.ID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getToken = `-- name: GetToken :one
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
WHERE id = $1 LIMIT 1
`

type GetTokenParams struct {
	ID string `json:"id"`
}

func (q *Queries) GetToken(ctx context.Context, arg GetTokenParams) (Tokens, error) {
	row := q.db.QueryRowContext(ctx, getToken, arg.ID)
	var i Tokens
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.Tokens,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const getTokenByTokenValue = `-- name: GetTokenByTokenValue :one
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
WHERE token = $1 LIMIT 1
`

type GetTokenByTokenValueParams struct {
	Tokens string `json:"token"`
}

func (q *Queries) GetTokenByTokenValue(ctx context.Context, arg GetTokenByTokenValueParams) (Tokens, error) {
	row := q.db.QueryRowContext(ctx, getTokenByTokenValue, arg.Tokens)
	var i Tokens
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.Tokens,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const getTokenByUserId = `-- name: GetTokenByUserId :many
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
WHERE user_id = $1
`

type GetTokenByUserIdParams struct {
	UserID types.NullableUserID `json:"user_id"`
}

func (q *Queries) GetTokenByUserId(ctx context.Context, arg GetTokenByUserIdParams) ([]Tokens, error) {
	rows, err := q.db.QueryContext(ctx, getTokenByUserId, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tokens{}
	for rows.Next() {
		var i Tokens
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenType,
			&i.Tokens,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnconsumedEvents = `-- name: GetUnconsumedEvents :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
WHERE consumed_at IS NULL
ORDER BY hlc_timestamp ASC
LIMIT $1
`

type GetUnconsumedEventsParams struct {
	Limit int32 `json:"limit"`
}

func (q *Queries) GetUnconsumedEvents(ctx context.Context, arg GetUnconsumedEventsParams) ([]ChangeEvent, error) {
	rows, err := q.db.QueryContext(ctx, getUnconsumedEvents, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChangeEvent{}
	for rows.Next() {
		var i ChangeEvent
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.RequestId,
			&i.Ip,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnsyncedEvents = `-- name: GetUnsyncedEvents :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
WHERE synced_at IS NULL
ORDER BY hlc_timestamp ASC
LIMIT $1
`

type GetUnsyncedEventsParams struct {
	Limit int32 `json:"limit"`
}

func (q *Queries) GetUnsyncedEvents(ctx context.Context, arg GetUnsyncedEventsParams) ([]ChangeEvent, error) {
	rows, err := q.db.QueryContext(ctx, getUnsyncedEvents, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChangeEvent{}
	for rows.Next() {
		var i ChangeEvent
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.RequestId,
			&i.Ip,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnsyncedEventsByNode = `-- name: GetUnsyncedEventsByNode :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
WHERE synced_at IS NULL AND node_id = $1
ORDER BY hlc_timestamp ASC
LIMIT $2
`

type GetUnsyncedEventsByNodeParams struct {
	NodeID types.NodeID `json:"node_id"`
	Limit  int32        `json:"limit"`
}

func (q *Queries) GetUnsyncedEventsByNode(ctx context.Context, arg GetUnsyncedEventsByNodeParams) ([]ChangeEvent, error) {
	rows, err := q.db.QueryContext(ctx, getUnsyncedEventsByNode, arg.NodeID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChangeEvent{}
	for rows.Next() {
		var i ChangeEvent
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.RequestId,
			&i.Ip,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users
WHERE user_id = $1 LIMIT 1
`

type GetUserParams struct {
	UserID types.UserID `json:"user_id"`
}

func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUser, arg.UserID)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Roles,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users
WHERE email = $1 LIMIT 1
`

type GetUserByEmailParams struct {
	Email types.Email `json:"email"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, arg.Email)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Roles,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getUserBySSHFingerprint = `-- name: GetUserBySSHFingerprint :one
SELECT u.user_id, u.username, u.name, u.email, u.hash, u.role, u.date_created, u.date_modified FROM users u
INNER JOIN user_ssh_keys k ON u.user_id = k.user_id
WHERE k.fingerprint = $1
LIMIT 1
`

type GetUserBySSHFingerprintParams struct {
	Fingerprint string `json:"fingerprint"`
}

func (q *Queries) GetUserBySSHFingerprint(ctx context.Context, arg GetUserBySSHFingerprintParams) (Users, error) {
	row := q.db.QueryRowContext(ctx, getUserBySSHFingerprint, arg.Fingerprint)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Name,
		&i.Email,
		&i.Hash,
		&i.Roles,
		&i.DateCreated,
		&i.DateModified,
	)
	return i, err
}

const getUserId = `-- name: GetUserId :one
SELECT user_id FROM users
WHERE email = $1 LIMIT 1
`

type GetUserIdParams struct {
	Email types.Email `json:"email"`
}

func (q *Queries) GetUserId(ctx context.Context, arg GetUserIdParams) (types.UserID, error) {
	row := q.db.QueryRowContext(ctx, getUserId, arg.Email)
	var user_id types.UserID
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserOauth = `-- name: GetUserOauth :one
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
WHERE user_oauth_id = $1
LIMIT 1
`

type GetUserOauthParams struct {
	UserOAuthID types.UserOauthID `json:"user_oauth_id"`
}

func (q *Queries) GetUserOauth(ctx context.Context, arg GetUserOauthParams) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauth, arg.UserOAuthID)
	var i UserOauth
	err := row.Scan(
		&i.UserOAuthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OAuthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthByEmail = `-- name: GetUserOauthByEmail :one
SELECT uo.user_oauth_id, uo.user_id, uo.oauth_provider, uo.oauth_provider_user_id, uo.access_token, uo.refresh_token, uo.token_expires_at, uo.date_created
FROM user_oauth uo
JOIN users u ON uo.user_id = u.user_id
WHERE u.email = $1
LIMIT 1
`

type GetUserOauthByEmailParams struct {
	Email types.Email `json:"email"`
}

func (q *Queries) GetUserOauthByEmail(ctx context.Context, arg GetUserOauthByEmailParams) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthByEmail, arg.Email)
	var i UserOauth
	err := row.Scan(
		&i.UserOAuthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OAuthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthByProviderID = `-- name: GetUserOauthByProviderID :one
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
WHERE oauth_provider = $1 AND oauth_provider_user_id = $2
LIMIT 1
`

type GetUserOauthByProviderIDParams struct {
	OauthProvider       string `json:"oauth_provider"`
	OAuthProviderUserID string `json:"oauth_provider_user_id"`
}

func (q *Queries) GetUserOauthByProviderID(ctx context.Context, arg GetUserOauthByProviderIDParams) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthByProviderID, arg.OauthProvider, arg.OAuthProviderUserID)
	var i UserOauth
	err := row.Scan(
		&i.UserOAuthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OAuthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthByUserId = `-- name: GetUserOauthByUserId :one
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
WHERE user_id = $1
LIMIT 1
`

type GetUserOauthByUserIdParams struct {
	UserID types.NullableUserID `json:"user_id"`
}

func (q *Queries) GetUserOauthByUserId(ctx context.Context, arg GetUserOauthByUserIdParams) (UserOauth, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthByUserId, arg.UserID)
	var i UserOauth
	err := row.Scan(
		&i.UserOAuthID,
		&i.UserID,
		&i.OauthProvider,
		&i.OAuthProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiresAt,
		&i.DateCreated,
	)
	return i, err
}

const getUserOauthId = `-- name: GetUserOauthId :one
SELECT uo.user_id
FROM user_oauth uo
JOIN users u ON uo.user_id = u.user_id
WHERE u.email = $1
LIMIT 1
`

type GetUserOauthIdParams struct {
	Email types.Email `json:"email"`
}

func (q *Queries) GetUserOauthId(ctx context.Context, arg GetUserOauthIdParams) (types.NullableUserID, error) {
	row := q.db.QueryRowContext(ctx, getUserOauthId, arg.Email)
	var user_id types.NullableUserID
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserSshKey = `-- name: GetUserSshKey :one
SELECT ssh_key_id, user_id, public_key, key_type, fingerprint, label, date_created, last_used FROM user_ssh_keys
WHERE ssh_key_id = $1
LIMIT 1
`

type GetUserSshKeyParams struct {
	SSHKeyID string `json:"ssh_key_id"`
}

func (q *Queries) GetUserSshKey(ctx context.Context, arg GetUserSshKeyParams) (UserSshKeys, error) {
	row := q.db.QueryRowContext(ctx, getUserSshKey, arg.SSHKeyID)
	var i UserSshKeys
	err := row.Scan(
		&i.SSHKeyID,
		&i.UserID,
		&i.PublicKey,
		&i.KeyType,
		&i.Fingerprint,
		&i.Label,
		&i.DateCreated,
		&i.LastUsed,
	)
	return i, err
}

const getUserSshKeyByFingerprint = `-- name: GetUserSshKeyByFingerprint :one
SELECT ssh_key_id, user_id, public_key, key_type, fingerprint, label, date_created, last_used FROM user_ssh_keys
WHERE fingerprint = $1
LIMIT 1
`

type GetUserSshKeyByFingerprintParams struct {
	Fingerprint string `json:"fingerprint"`
}

func (q *Queries) GetUserSshKeyByFingerprint(ctx context.Context, arg GetUserSshKeyByFingerprintParams) (UserSshKeys, error) {
	row := q.db.QueryRowContext(ctx, getUserSshKeyByFingerprint, arg.Fingerprint)
	var i UserSshKeys
	err := row.Scan(
		&i.SSHKeyID,
		&i.UserID,
		&i.PublicKey,
		&i.KeyType,
		&i.Fingerprint,
		&i.Label,
		&i.DateCreated,
		&i.LastUsed,
	)
	return i, err
}

const getVerification = `-- name: GetVerification :one
SELECT verification_id, backup_id, verified_at, verified_by, restore_tested, checksum_valid, record_count_match, status, error_message, duration_ms FROM backup_verifications
WHERE verification_id = $1 LIMIT 1
`

type GetVerificationParams struct {
	VerificationID types.VerificationID `json:"verification_id"`
}

func (q *Queries) GetVerification(ctx context.Context, arg GetVerificationParams) (BackupVerification, error) {
	row := q.db.QueryRowContext(ctx, getVerification, arg.VerificationID)
	var i BackupVerification
	err := row.Scan(
		&i.VerificationID,
		&i.BackupID,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.RestoreTested,
		&i.ChecksumValid,
		&i.RecordCountMatch,
		&i.Status,
		&i.ErrorMessage,
		&i.DurationMs,
	)
	return i, err
}

const getVerificationsByBackup = `-- name: GetVerificationsByBackup :many
SELECT verification_id, backup_id, verified_at, verified_by, restore_tested, checksum_valid, record_count_match, status, error_message, duration_ms FROM backup_verifications
WHERE backup_id = $1
ORDER BY verified_at DESC
`

type GetVerificationsByBackupParams struct {
	BackupID types.BackupID `json:"backup_id"`
}

func (q *Queries) GetVerificationsByBackup(ctx context.Context, arg GetVerificationsByBackupParams) ([]BackupVerification, error) {
	rows, err := q.db.QueryContext(ctx, getVerificationsByBackup, arg.BackupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BackupVerification{}
	for rows.Next() {
		var i BackupVerification
		if err := rows.Scan(
			&i.VerificationID,
			&i.BackupID,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.RestoreTested,
			&i.ChecksumValid,
			&i.RecordCountMatch,
			&i.Status,
			&i.ErrorMessage,
			&i.DurationMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementBackupSetCompleted = `-- name: IncrementBackupSetCompleted :exec
UPDATE backup_sets
SET completed_count = completed_count + 1
WHERE backup_set_id = $1
`

type IncrementBackupSetCompletedParams struct {
	BackupSetID types.BackupSetID `json:"backup_set_id"`
}

func (q *Queries) IncrementBackupSetCompleted(ctx context.Context, arg IncrementBackupSetCompletedParams) error {
	_, err := q.db.ExecContext(ctx, incrementBackupSetCompleted, arg.BackupSetID)
	return err
}

const listAdminContentData = `-- name: ListAdminContentData :many
SELECT admin_content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, admin_route_id, admin_datatype_id, author_id, status, date_created, date_modified FROM admin_content_data
ORDER BY admin_content_data_id
`

func (q *Queries) ListAdminContentData(ctx context.Context) ([]AdminContentData, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminContentData{}
	for rows.Next() {
		var i AdminContentData
		if err := rows.Scan(
			&i.AdminContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.AdminRouteID,
			&i.AdminDatatypeID,
			&i.AuthorID,
			&i.Status,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentDataByRoute = `-- name: ListAdminContentDataByRoute :many
SELECT admin_content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, admin_route_id, admin_datatype_id, author_id, status, date_created, date_modified FROM admin_content_data
WHERE admin_route_id = $1
ORDER BY admin_content_data_id
`

type ListAdminContentDataByRouteParams struct {
	AdminRouteID string `json:"admin_route_id"`
}

func (q *Queries) ListAdminContentDataByRoute(ctx context.Context, arg ListAdminContentDataByRouteParams) ([]AdminContentData, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentDataByRoute, arg.AdminRouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminContentData{}
	for rows.Next() {
		var i AdminContentData
		if err := rows.Scan(
			&i.AdminContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.AdminRouteID,
			&i.AdminDatatypeID,
			&i.AuthorID,
			&i.Status,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentFields = `-- name: ListAdminContentFields :many
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, author_id, date_created, date_modified FROM admin_content_fields
ORDER BY admin_content_field_id
`

func (q *Queries) ListAdminContentFields(ctx context.Context) ([]AdminContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminContentFields{}
	for rows.Next() {
		var i AdminContentFields
		if err := rows.Scan(
			&i.AdminContentFieldID,
			&i.AdminRouteID,
			&i.AdminContentDataID,
			&i.AdminFieldID,
			&i.AdminFieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentFieldsByRoute = `-- name: ListAdminContentFieldsByRoute :many
SELECT admin_content_field_id, admin_route_id, admin_content_data_id, admin_field_id, admin_field_value, author_id, date_created, date_modified FROM admin_content_fields
WHERE admin_route_id = $1
ORDER BY admin_content_field_id
`

type ListAdminContentFieldsByRouteParams struct {
	AdminRouteID sql.NullString `json:"admin_route_id"`
}

func (q *Queries) ListAdminContentFieldsByRoute(ctx context.Context, arg ListAdminContentFieldsByRouteParams) ([]AdminContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentFieldsByRoute, arg.AdminRouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminContentFields{}
	for rows.Next() {
		var i AdminContentFields
		if err := rows.Scan(
			&i.AdminContentFieldID,
			&i.AdminRouteID,
			&i.AdminContentDataID,
			&i.AdminFieldID,
			&i.AdminFieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentRelationsBySource = `-- name: ListAdminContentRelationsBySource :many
SELECT admin_content_relation_id, source_content_id, target_content_id, admin_field_id, sort_order, date_created FROM admin_content_relations
WHERE source_content_id = $1
ORDER BY sort_order
`

type ListAdminContentRelationsBySourceParams struct {
	SourceContentID types.AdminContentID `json:"source_content_id"`
}

func (q *Queries) ListAdminContentRelationsBySource(ctx context.Context, arg ListAdminContentRelationsBySourceParams) ([]AdminContentRelations, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentRelationsBySource, arg.SourceContentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminContentRelations{}
	for rows.Next() {
		var i AdminContentRelations
		if err := rows.Scan(
			&i.AdminContentRelationID,
			&i.SourceContentID,
			&i.TargetContentID,
			&i.AdminFieldID,
			&i.SortOrder,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentRelationsBySourceAndField = `-- name: ListAdminContentRelationsBySourceAndField :many
SELECT admin_content_relation_id, source_content_id, target_content_id, admin_field_id, sort_order, date_created FROM admin_content_relations
WHERE source_content_id = $1 AND admin_field_id = $2
ORDER BY sort_order
`

type ListAdminContentRelationsBySourceAndFieldParams struct {
	SourceContentID types.AdminContentID `json:"source_content_id"`
	AdminFieldID    types.AdminFieldID   `json:"admin_field_id"`
}

func (q *Queries) ListAdminContentRelationsBySourceAndField(ctx context.Context, arg ListAdminContentRelationsBySourceAndFieldParams) ([]AdminContentRelations, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentRelationsBySourceAndField, arg.SourceContentID, arg.AdminFieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminContentRelations{}
	for rows.Next() {
		var i AdminContentRelations
		if err := rows.Scan(
			&i.AdminContentRelationID,
			&i.SourceContentID,
			&i.TargetContentID,
			&i.AdminFieldID,
			&i.SortOrder,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminContentRelationsByTarget = `-- name: ListAdminContentRelationsByTarget :many
SELECT admin_content_relation_id, source_content_id, target_content_id, admin_field_id, sort_order, date_created FROM admin_content_relations
WHERE target_content_id = $1
ORDER BY date_created
`

type ListAdminContentRelationsByTargetParams struct {
	TargetContentID types.AdminContentID `json:"target_content_id"`
}

func (q *Queries) ListAdminContentRelationsByTarget(ctx context.Context, arg ListAdminContentRelationsByTargetParams) ([]AdminContentRelations, error) {
	rows, err := q.db.QueryContext(ctx, listAdminContentRelationsByTarget, arg.TargetContentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminContentRelations{}
	for rows.Next() {
		var i AdminContentRelations
		if err := rows.Scan(
			&i.AdminContentRelationID,
			&i.SourceContentID,
			&i.TargetContentID,
			&i.AdminFieldID,
			&i.SortOrder,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatype = `-- name: ListAdminDatatype :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM admin_datatypes
ORDER BY admin_datatype_id
`

func (q *Queries) ListAdminDatatype(ctx context.Context) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminDatatypes{}
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeChildren = `-- name: ListAdminDatatypeChildren :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM admin_datatypes
WHERE parent_id = $1
`

type ListAdminDatatypeChildrenParams struct {
	ParentID types.NullableContentID `json:"parent_id"`
}

func (q *Queries) ListAdminDatatypeChildren(ctx context.Context, arg ListAdminDatatypeChildrenParams) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeChildren, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminDatatypes{}
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeField = `-- name: ListAdminDatatypeField :many
SELECT id, admin_datatype_id, admin_field_id FROM admin_datatypes_fields
`

func (q *Queries) ListAdminDatatypeField(ctx context.Context) ([]AdminDatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminDatatypesFields{}
	for rows.Next() {
		var i AdminDatatypesFields
		if err := rows.Scan(&i.ID, &i.AdminDatatypeID, &i.AdminFieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeFieldByDatatypeID = `-- name: ListAdminDatatypeFieldByDatatypeID :many
SELECT id, admin_datatype_id, admin_field_id FROM admin_datatypes_fields
WHERE admin_datatype_id = $1
`

type ListAdminDatatypeFieldByDatatypeIDParams struct {
	AdminDatatypeID types.AdminDatatypeID `json:"admin_datatype_id"`
}

func (q *Queries) ListAdminDatatypeFieldByDatatypeID(ctx context.Context, arg ListAdminDatatypeFieldByDatatypeIDParams) ([]AdminDatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeFieldByDatatypeID, arg.AdminDatatypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminDatatypesFields{}
	for rows.Next() {
		var i AdminDatatypesFields
		if err := rows.Scan(&i.ID, &i.AdminDatatypeID, &i.AdminFieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeFieldByFieldID = `-- name: ListAdminDatatypeFieldByFieldID :many
SELECT id, admin_datatype_id, admin_field_id FROM admin_datatypes_fields
WHERE admin_field_id = $1
`

type ListAdminDatatypeFieldByFieldIDParams struct {
	AdminFieldID types.AdminFieldID `json:"admin_field_id"`
}

func (q *Queries) ListAdminDatatypeFieldByFieldID(ctx context.Context, arg ListAdminDatatypeFieldByFieldIDParams) ([]AdminDatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeFieldByFieldID, arg.AdminFieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminDatatypesFields{}
	for rows.Next() {
		var i AdminDatatypesFields
		if err := rows.Scan(&i.ID, &i.AdminDatatypeID, &i.AdminFieldID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeGlobal = `-- name: ListAdminDatatypeGlobal :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM admin_datatypes
WHERE type = 'GLOBAL' LIMIT 1
`

func (q *Queries) ListAdminDatatypeGlobal(ctx context.Context) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeGlobal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminDatatypes{}
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminDatatypeRoot = `-- name: ListAdminDatatypeRoot :many
SELECT admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM admin_datatypes
WHERE type = 'ROOT' LIMIT 1
`

func (q *Queries) ListAdminDatatypeRoot(ctx context.Context) ([]AdminDatatypes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminDatatypeRoot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminDatatypes{}
	for rows.Next() {
		var i AdminDatatypes
		if err := rows.Scan(
			&i.AdminDatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminField = `-- name: ListAdminField :many
SELECT admin_field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified
FROM admin_fields
ORDER BY admin_field_id
`

func (q *Queries) ListAdminField(ctx context.Context) ([]AdminFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminFields{}
	for rows.Next() {
		var i AdminFields
		if err := rows.Scan(
			&i.AdminFieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Validation,
			&i.UiConfig,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminFieldByParentID = `-- name: ListAdminFieldByParentID :many
SELECT admin_field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified
FROM admin_fields
WHERE parent_id = $1
ORDER BY admin_field_id
`

type ListAdminFieldByParentIDParams struct {
	ParentID types.NullableAdminDatatypeID `json:"parent_id"`
}

func (q *Queries) ListAdminFieldByParentID(ctx context.Context, arg ListAdminFieldByParentIDParams) ([]AdminFields, error) {
	rows, err := q.db.QueryContext(ctx, listAdminFieldByParentID, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminFields{}
	for rows.Next() {
		var i AdminFields
		if err := rows.Scan(
			&i.AdminFieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Validation,
			&i.UiConfig,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdminRoute = `-- name: ListAdminRoute :many
SELECT admin_route_id, slug, title, status, author_id, date_created, date_modified FROM admin_routes
ORDER BY slug
`

func (q *Queries) ListAdminRoute(ctx context.Context) ([]AdminRoutes, error) {
	rows, err := q.db.QueryContext(ctx, listAdminRoute)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminRoutes{}
	for rows.Next() {
		var i AdminRoutes
		if err := rows.Scan(
			&i.AdminRouteID,
			&i.Slug,
			&i.Title,
			&i.Status,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackupSets = `-- name: ListBackupSets :many
SELECT backup_set_id, created_at, hlc_timestamp, status, backup_ids, node_count, completed_count, error_message FROM backup_sets
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListBackupSetsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBackupSets(ctx context.Context, arg ListBackupSetsParams) ([]BackupSet, error) {
	rows, err := q.db.QueryContext(ctx, listBackupSets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BackupSet{}
	for rows.Next() {
		var i BackupSet
		if err := rows.Scan(
			&i.BackupSetID,
			&i.CreatedAt,
			&i.HlcTimestamp,
			&i.Status,
			&i.BackupIds,
			&i.NodeCount,
			&i.CompletedCount,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackups = `-- name: ListBackups :many
SELECT backup_id, node_id, backup_type, status, started_at, completed_at, duration_ms, record_count, size_bytes, replication_lsn, hlc_timestamp, storage_path, checksum, triggered_by, error_message, metadata FROM backups
ORDER BY started_at DESC
LIMIT $1 OFFSET $2
`

type ListBackupsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBackups(ctx context.Context, arg ListBackupsParams) ([]Backup, error) {
	rows, err := q.db.QueryContext(ctx, listBackups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.BackupID,
			&i.NodeID,
			&i.BackupType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RecordCount,
			&i.SizeBytes,
			&i.ReplicationLsn,
			&i.HlcTimestamp,
			&i.StoragePath,
			&i.Checksum,
			&i.TriggeredBy,
			&i.ErrorMessage,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChangeEvents = `-- name: ListChangeEvents :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
ORDER BY hlc_timestamp DESC
LIMIT $1 OFFSET $2
`

type ListChangeEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListChangeEvents(ctx context.Context, arg ListChangeEventsParams) ([]ChangeEvent, error) {
	rows, err := q.db.QueryContext(ctx, listChangeEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChangeEvent{}
	for rows.Next() {
		var i ChangeEvent
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.RequestId,
			&i.Ip,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChangeEventsByAction = `-- name: ListChangeEventsByAction :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
WHERE action = $1
ORDER BY hlc_timestamp DESC
LIMIT $2 OFFSET $3
`

type ListChangeEventsByActionParams struct {
	Action types.Action `json:"action"`
	Limit  int32        `json:"limit"`
	Offset int32        `json:"offset"`
}

func (q *Queries) ListChangeEventsByAction(ctx context.Context, arg ListChangeEventsByActionParams) ([]ChangeEvent, error) {
	rows, err := q.db.QueryContext(ctx, listChangeEventsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChangeEvent{}
	for rows.Next() {
		var i ChangeEvent
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.RequestId,
			&i.Ip,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChangeEventsByUser = `-- name: ListChangeEventsByUser :many
SELECT event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at FROM change_events
WHERE user_id = $1
ORDER BY hlc_timestamp DESC
LIMIT $2 OFFSET $3
`

type ListChangeEventsByUserParams struct {
	UserID types.NullableUserID `json:"user_id"`
	Limit  int32                `json:"limit"`
	Offset int32                `json:"offset"`
}

func (q *Queries) ListChangeEventsByUser(ctx context.Context, arg ListChangeEventsByUserParams) ([]ChangeEvent, error) {
	rows, err := q.db.QueryContext(ctx, listChangeEventsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChangeEvent{}
	for rows.Next() {
		var i ChangeEvent
		if err := rows.Scan(
			&i.EventID,
			&i.HlcTimestamp,
			&i.WallTimestamp,
			&i.NodeID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.Action,
			&i.UserID,
			&i.OldValues,
			&i.NewValues,
			&i.Metadata,
			&i.RequestId,
			&i.Ip,
			&i.SyncedAt,
			&i.ConsumedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentData = `-- name: ListContentData :many
SELECT content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, route_id, datatype_id, author_id, status, date_created, date_modified FROM content_data
ORDER BY content_data_id
`

func (q *Queries) ListContentData(ctx context.Context) ([]ContentData, error) {
	rows, err := q.db.QueryContext(ctx, listContentData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContentData{}
	for rows.Next() {
		var i ContentData
		if err := rows.Scan(
			&i.ContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.RouteID,
			&i.DatatypeID,
			&i.AuthorID,
			&i.Status,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentDataByRoute = `-- name: ListContentDataByRoute :many
SELECT content_data_id, parent_id, first_child_id, next_sibling_id, prev_sibling_id, route_id, datatype_id, author_id, status, date_created, date_modified FROM content_data
WHERE route_id = $1
ORDER BY content_data_id
`

type ListContentDataByRouteParams struct {
	RouteID types.NullableRouteID `json:"route_id"`
}

func (q *Queries) ListContentDataByRoute(ctx context.Context, arg ListContentDataByRouteParams) ([]ContentData, error) {
	rows, err := q.db.QueryContext(ctx, listContentDataByRoute, arg.RouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContentData{}
	for rows.Next() {
		var i ContentData
		if err := rows.Scan(
			&i.ContentDataID,
			&i.ParentID,
			&i.FirstChildID,
			&i.NextSiblingID,
			&i.PrevSiblingID,
			&i.RouteID,
			&i.DatatypeID,
			&i.AuthorID,
			&i.Status,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentFields = `-- name: ListContentFields :many
SELECT content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified FROM content_fields
ORDER BY content_field_id
`

func (q *Queries) ListContentFields(ctx context.Context) ([]ContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listContentFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContentFields{}
	for rows.Next() {
		var i ContentFields
		if err := rows.Scan(
			&i.ContentFieldID,
			&i.RouteID,
			&i.ContentDataID,
			&i.FieldID,
			&i.FieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentFieldsByContentData = `-- name: ListContentFieldsByContentData :many
SELECT content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified FROM content_fields
WHERE content_data_id = $1
ORDER BY content_field_id
`

type ListContentFieldsByContentDataParams struct {
	ContentDataID types.NullableContentID `json:"content_data_id"`
}

func (q *Queries) ListContentFieldsByContentData(ctx context.Context, arg ListContentFieldsByContentDataParams) ([]ContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listContentFieldsByContentData, arg.ContentDataID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContentFields{}
	for rows.Next() {
		var i ContentFields
		if err := rows.Scan(
			&i.ContentFieldID,
			&i.RouteID,
			&i.ContentDataID,
			&i.FieldID,
			&i.FieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentFieldsByRoute = `-- name: ListContentFieldsByRoute :many
SELECT content_field_id, route_id, content_data_id, field_id, field_value, author_id, date_created, date_modified FROM content_fields
WHERE route_id = $1
ORDER BY content_field_id
`

type ListContentFieldsByRouteParams struct {
	RouteID types.NullableRouteID `json:"route_id"`
}

func (q *Queries) ListContentFieldsByRoute(ctx context.Context, arg ListContentFieldsByRouteParams) ([]ContentFields, error) {
	rows, err := q.db.QueryContext(ctx, listContentFieldsByRoute, arg.RouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContentFields{}
	for rows.Next() {
		var i ContentFields
		if err := rows.Scan(
			&i.ContentFieldID,
			&i.RouteID,
			&i.ContentDataID,
			&i.FieldID,
			&i.FieldValue,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentRelationsBySource = `-- name: ListContentRelationsBySource :many
SELECT content_relation_id, source_content_id, target_content_id, field_id, sort_order, date_created FROM content_relations
WHERE source_content_id = $1
ORDER BY sort_order
`

type ListContentRelationsBySourceParams struct {
	SourceContentID types.ContentID `json:"source_content_id"`
}

func (q *Queries) ListContentRelationsBySource(ctx context.Context, arg ListContentRelationsBySourceParams) ([]ContentRelations, error) {
	rows, err := q.db.QueryContext(ctx, listContentRelationsBySource, arg.SourceContentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContentRelations{}
	for rows.Next() {
		var i ContentRelations
		if err := rows.Scan(
			&i.ContentRelationID,
			&i.SourceContentID,
			&i.TargetContentID,
			&i.FieldID,
			&i.SortOrder,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentRelationsBySourceAndField = `-- name: ListContentRelationsBySourceAndField :many
SELECT content_relation_id, source_content_id, target_content_id, field_id, sort_order, date_created FROM content_relations
WHERE source_content_id = $1 AND field_id = $2
ORDER BY sort_order
`

type ListContentRelationsBySourceAndFieldParams struct {
	SourceContentID types.ContentID `json:"source_content_id"`
	FieldID         types.FieldID   `json:"field_id"`
}

func (q *Queries) ListContentRelationsBySourceAndField(ctx context.Context, arg ListContentRelationsBySourceAndFieldParams) ([]ContentRelations, error) {
	rows, err := q.db.QueryContext(ctx, listContentRelationsBySourceAndField, arg.SourceContentID, arg.FieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContentRelations{}
	for rows.Next() {
		var i ContentRelations
		if err := rows.Scan(
			&i.ContentRelationID,
			&i.SourceContentID,
			&i.TargetContentID,
			&i.FieldID,
			&i.SortOrder,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentRelationsByTarget = `-- name: ListContentRelationsByTarget :many
SELECT content_relation_id, source_content_id, target_content_id, field_id, sort_order, date_created FROM content_relations
WHERE target_content_id = $1
ORDER BY date_created
`

type ListContentRelationsByTargetParams struct {
	TargetContentID types.ContentID `json:"target_content_id"`
}

func (q *Queries) ListContentRelationsByTarget(ctx context.Context, arg ListContentRelationsByTargetParams) ([]ContentRelations, error) {
	rows, err := q.db.QueryContext(ctx, listContentRelationsByTarget, arg.TargetContentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContentRelations{}
	for rows.Next() {
		var i ContentRelations
		if err := rows.Scan(
			&i.ContentRelationID,
			&i.SourceContentID,
			&i.TargetContentID,
			&i.FieldID,
			&i.SortOrder,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatype = `-- name: ListDatatype :many
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM datatypes
ORDER BY datatype_id
`

func (q *Queries) ListDatatype(ctx context.Context) ([]Datatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Datatypes{}
	for rows.Next() {
		var i Datatypes
		if err := rows.Scan(
			&i.DatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeChildren = `-- name: ListDatatypeChildren :many
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM datatypes
WHERE parent_id = $1
ORDER BY label
`

type ListDatatypeChildrenParams struct {
	ParentID types.NullableContentID `json:"parent_id"`
}

func (q *Queries) ListDatatypeChildren(ctx context.Context, arg ListDatatypeChildrenParams) ([]Datatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeChildren, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Datatypes{}
	for rows.Next() {
		var i Datatypes
		if err := rows.Scan(
			&i.DatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeField = `-- name: ListDatatypeField :many
SELECT id, datatype_id, field_id, sort_order FROM datatypes_fields
ORDER BY sort_order, id
`

func (q *Queries) ListDatatypeField(ctx context.Context) ([]DatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatatypesFields{}
	for rows.Next() {
		var i DatatypesFields
		if err := rows.Scan(
			&i.ID,
			&i.DatatypeID,
			&i.FieldID,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeFieldByDatatypeID = `-- name: ListDatatypeFieldByDatatypeID :many
SELECT id, datatype_id, field_id, sort_order FROM datatypes_fields
WHERE datatype_id = $1
ORDER BY sort_order, id
`

type ListDatatypeFieldByDatatypeIDParams struct {
	DatatypeID types.DatatypeID `json:"datatype_id"`
}

func (q *Queries) ListDatatypeFieldByDatatypeID(ctx context.Context, arg ListDatatypeFieldByDatatypeIDParams) ([]DatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeFieldByDatatypeID, arg.DatatypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatatypesFields{}
	for rows.Next() {
		var i DatatypesFields
		if err := rows.Scan(
			&i.ID,
			&i.DatatypeID,
			&i.FieldID,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeFieldByFieldID = `-- name: ListDatatypeFieldByFieldID :many
SELECT id, datatype_id, field_id, sort_order FROM datatypes_fields
WHERE field_id = $1
ORDER BY sort_order, id
`

type ListDatatypeFieldByFieldIDParams struct {
	FieldID types.FieldID `json:"field_id"`
}

func (q *Queries) ListDatatypeFieldByFieldID(ctx context.Context, arg ListDatatypeFieldByFieldIDParams) ([]DatatypesFields, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeFieldByFieldID, arg.FieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatatypesFields{}
	for rows.Next() {
		var i DatatypesFields
		if err := rows.Scan(
			&i.ID,
			&i.DatatypeID,
			&i.FieldID,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeGlobal = `-- name: ListDatatypeGlobal :many
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM datatypes
WHERE type = 'GLOBAL'
ORDER BY datatype_id
`

func (q *Queries) ListDatatypeGlobal(ctx context.Context) ([]Datatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeGlobal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Datatypes{}
	for rows.Next() {
		var i Datatypes
		if err := rows.Scan(
			&i.DatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatatypeRoot = `-- name: ListDatatypeRoot :many
SELECT datatype_id, parent_id, label, type, author_id, date_created, date_modified FROM datatypes
WHERE type = 'ROOT'
ORDER BY datatype_id
`

func (q *Queries) ListDatatypeRoot(ctx context.Context) ([]Datatypes, error) {
	rows, err := q.db.QueryContext(ctx, listDatatypeRoot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Datatypes{}
	for rows.Next() {
		var i Datatypes
		if err := rows.Scan(
			&i.DatatypeID,
			&i.ParentID,
			&i.Label,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listField = `-- name: ListField :many
SELECT field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified FROM fields
ORDER BY field_id
`

func (q *Queries) ListField(ctx context.Context) ([]Fields, error) {
	rows, err := q.db.QueryContext(ctx, listField)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fields{}
	for rows.Next() {
		var i Fields
		if err := rows.Scan(
			&i.FieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Validation,
			&i.UiConfig,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFieldByDatatypeID = `-- name: ListFieldByDatatypeID :many
SELECT field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified FROM fields
WHERE parent_id = $1
ORDER BY field_id
`

type ListFieldByDatatypeIDParams struct {
	ParentID types.NullableDatatypeID `json:"parent_id"`
}

func (q *Queries) ListFieldByDatatypeID(ctx context.Context, arg ListFieldByDatatypeIDParams) ([]Fields, error) {
	rows, err := q.db.QueryContext(ctx, listFieldByDatatypeID, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fields{}
	for rows.Next() {
		var i Fields
		if err := rows.Scan(
			&i.FieldID,
			&i.ParentID,
			&i.Label,
			&i.Data,
			&i.Validation,
			&i.UiConfig,
			&i.Type,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMedia = `-- name: ListMedia :many
SELECT media_id, name, display_name, alt, caption, description, class, mimetype, dimensions, url, srcset, author_id, date_created, date_modified FROM media
ORDER BY name
`

func (q *Queries) ListMedia(ctx context.Context) ([]Media, error) {
	rows, err := q.db.QueryContext(ctx, listMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.MediaID,
			&i.Name,
			&i.DisplayName,
			&i.Alt,
			&i.Caption,
			&i.Description,
			&i.Class,
			&i.Mimetype,
			&i.Dimensions,
			&i.URL,
			&i.Srcset,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaDimension = `-- name: ListMediaDimension :many
SELECT md_id, label, width, height, aspect_ratio FROM media_dimensions 
ORDER BY label
`

func (q *Queries) ListMediaDimension(ctx context.Context) ([]MediaDimensions, error) {
	rows, err := q.db.QueryContext(ctx, listMediaDimension)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MediaDimensions{}
	for rows.Next() {
		var i MediaDimensions
		if err := rows.Scan(
			&i.MdID,
			&i.Label,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermission = `-- name: ListPermission :many
SELECT permission_id, table_id, mode, label FROM permissions 
ORDER BY table_id
`

func (q *Queries) ListPermission(ctx context.Context) ([]Permissions, error) {
	rows, err := q.db.QueryContext(ctx, listPermission)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permissions{}
	for rows.Next() {
		var i Permissions
		if err := rows.Scan(
			&i.PermissionID,
			&i.TableID,
			&i.Mode,
			&i.Label,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRole = `-- name: ListRole :many
SELECT role_id, label, permissions 
FROM roles 
ORDER BY role_id
`

func (q *Queries) ListRole(ctx context.Context) ([]Roles, error) {
	rows, err := q.db.QueryContext(ctx, listRole)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Roles{}
	for rows.Next() {
		var i Roles
		if err := rows.Scan(&i.RoleID, &i.Label, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootContentSummary = `-- name: ListRootContentSummary :many
SELECT
    cd.content_data_id,
    cd.route_id,
    cd.datatype_id,
    r.slug AS route_slug,
    r.title AS route_title,
    dt.label AS datatype_label,
    cd.date_created,
    cd.date_modified
FROM content_data cd
    INNER JOIN routes r ON cd.route_id = r.route_id
    INNER JOIN datatypes dt ON cd.datatype_id = dt.datatype_id
WHERE cd.parent_id IS NULL
    AND dt.type = 'ROOT'
ORDER BY dt.label, r.slug
`

type ListRootContentSummaryRow struct {
	ContentDataID types.ContentID          `json:"content_data_id"`
	RouteID       types.NullableRouteID    `json:"route_id"`
	DatatypeID    types.NullableDatatypeID `json:"datatype_id"`
	RouteSlug     types.Slug               `json:"route_slug"`
	RouteTitle    string                   `json:"route_title"`
	DatatypeLabel string                   `json:"datatype_label"`
	DateCreated   types.Timestamp          `json:"date_created"`
	DateModified  types.Timestamp          `json:"date_modified"`
}

func (q *Queries) ListRootContentSummary(ctx context.Context) ([]ListRootContentSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, listRootContentSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRootContentSummaryRow{}
	for rows.Next() {
		var i ListRootContentSummaryRow
		if err := rows.Scan(
			&i.ContentDataID,
			&i.RouteID,
			&i.DatatypeID,
			&i.RouteSlug,
			&i.RouteTitle,
			&i.DatatypeLabel,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoute = `-- name: ListRoute :many
SELECT route_id, slug, title, status, author_id, date_created, date_modified 
FROM routes
ORDER BY slug
`

func (q *Queries) ListRoute(ctx context.Context) ([]Routes, error) {
	rows, err := q.db.QueryContext(ctx, listRoute)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Routes{}
	for rows.Next() {
		var i Routes
		if err := rows.Scan(
			&i.RouteID,
			&i.Slug,
			&i.Title,
			&i.Status,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutesByDatatype = `-- name: ListRoutesByDatatype :many
SELECT DISTINCT r.route_id, r.slug, r.title, r.status, r.author_id, r.date_created, r.date_modified
FROM routes r
INNER JOIN content_data cd ON r.route_id = cd.route_id
WHERE cd.datatype_id = $1
ORDER BY r.title
`

type ListRoutesByDatatypeParams struct {
	DatatypeID types.NullableDatatypeID `json:"datatype_id"`
}

func (q *Queries) ListRoutesByDatatype(ctx context.Context, arg ListRoutesByDatatypeParams) ([]Routes, error) {
	rows, err := q.db.QueryContext(ctx, listRoutesByDatatype, arg.DatatypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Routes{}
	for rows.Next() {
		var i Routes
		if err := rows.Scan(
			&i.RouteID,
			&i.Slug,
			&i.Title,
			&i.Status,
			&i.AuthorID,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSession = `-- name: ListSession :many
SELECT session_id, user_id, created_at, expires_at, last_access, ip_address, user_agent, session_data FROM sessions
`

func (q *Queries) ListSession(ctx context.Context) ([]Sessions, error) {
	rows, err := q.db.QueryContext(ctx, listSession)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sessions{}
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastAccess,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTable = `-- name: ListTable :many
SELECT id, label, author_id FROM tables 
ORDER BY label
`

func (q *Queries) ListTable(ctx context.Context) ([]Tables, error) {
	rows, err := q.db.QueryContext(ctx, listTable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tables{}
	for rows.Next() {
		var i Tables
		if err := rows.Scan(&i.ID, &i.Label, &i.AuthorID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToken = `-- name: ListToken :many
SELECT id, user_id, token_type, token, issued_at, expires_at, revoked FROM tokens
`

func (q *Queries) ListToken(ctx context.Context) ([]Tokens, error) {
	rows, err := q.db.QueryContext(ctx, listToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tokens{}
	for rows.Next() {
		var i Tokens
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenType,
			&i.Tokens,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUser = `-- name: ListUser :many
SELECT user_id, username, name, email, hash, role, date_created, date_modified FROM users 
ORDER BY user_id
`

func (q *Queries) ListUser(ctx context.Context) ([]Users, error) {
	rows, err := q.db.QueryContext(ctx, listUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Name,
			&i.Email,
			&i.Hash,
			&i.Roles,
			&i.DateCreated,
			&i.DateModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOauth = `-- name: ListUserOauth :many
SELECT user_oauth_id, user_id, oauth_provider, oauth_provider_user_id, access_token, refresh_token, token_expires_at, date_created
FROM user_oauth
ORDER BY user_oauth_id
`

func (q *Queries) ListUserOauth(ctx context.Context) ([]UserOauth, error) {
	rows, err := q.db.QueryContext(ctx, listUserOauth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserOauth{}
	for rows.Next() {
		var i UserOauth
		if err := rows.Scan(
			&i.UserOAuthID,
			&i.UserID,
			&i.OauthProvider,
			&i.OAuthProviderUserID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.TokenExpiresAt,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSshKeys = `-- name: ListUserSshKeys :many
SELECT ssh_key_id, user_id, public_key, key_type, fingerprint, label, date_created, last_used FROM user_ssh_keys
WHERE user_id = $1
ORDER BY date_created DESC
`

type ListUserSshKeysParams struct {
	UserID types.NullableUserID `json:"user_id"`
}

func (q *Queries) ListUserSshKeys(ctx context.Context, arg ListUserSshKeysParams) ([]UserSshKeys, error) {
	rows, err := q.db.QueryContext(ctx, listUserSshKeys, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSshKeys{}
	for rows.Next() {
		var i UserSshKeys
		if err := rows.Scan(
			&i.SSHKeyID,
			&i.UserID,
			&i.PublicKey,
			&i.KeyType,
			&i.Fingerprint,
			&i.Label,
			&i.DateCreated,
			&i.LastUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerifications = `-- name: ListVerifications :many
SELECT verification_id, backup_id, verified_at, verified_by, restore_tested, checksum_valid, record_count_match, status, error_message, duration_ms FROM backup_verifications
ORDER BY verified_at DESC
LIMIT $1 OFFSET $2
`

type ListVerificationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListVerifications(ctx context.Context, arg ListVerificationsParams) ([]BackupVerification, error) {
	rows, err := q.db.QueryContext(ctx, listVerifications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BackupVerification{}
	for rows.Next() {
		var i BackupVerification
		if err := rows.Scan(
			&i.VerificationID,
			&i.BackupID,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.RestoreTested,
			&i.ChecksumValid,
			&i.RecordCountMatch,
			&i.Status,
			&i.ErrorMessage,
			&i.DurationMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEventConsumed = `-- name: MarkEventConsumed :exec
UPDATE change_events
SET consumed_at = CURRENT_TIMESTAMP
WHERE event_id = $1
`

type MarkEventConsumedParams struct {
	EventID types.EventID `json:"event_id"`
}

func (q *Queries) MarkEventConsumed(ctx context.Context, arg MarkEventConsumedParams) error {
	_, err := q.db.ExecContext(ctx, markEventConsumed, arg.EventID)
	return err
}

const markEventSynced = `-- name: MarkEventSynced :exec
UPDATE change_events
SET synced_at = CURRENT_TIMESTAMP
WHERE event_id = $1
`

type MarkEventSyncedParams struct {
	EventID types.EventID `json:"event_id"`
}

func (q *Queries) MarkEventSynced(ctx context.Context, arg MarkEventSyncedParams) error {
	_, err := q.db.ExecContext(ctx, markEventSynced, arg.EventID)
	return err
}

const markEventsConsumedBatch = `-- name: MarkEventsConsumedBatch :exec
UPDATE change_events
SET consumed_at = CURRENT_TIMESTAMP
WHERE event_id = ANY($1::char(26)[])
`

type MarkEventsConsumedBatchParams struct {
	Column1 []string `json:"column_1"`
}

func (q *Queries) MarkEventsConsumedBatch(ctx context.Context, arg MarkEventsConsumedBatchParams) error {
	_, err := q.db.ExecContext(ctx, markEventsConsumedBatch, pq.Array(arg.Column1))
	return err
}

const markEventsSyncedBatch = `-- name: MarkEventsSyncedBatch :exec
UPDATE change_events
SET synced_at = CURRENT_TIMESTAMP
WHERE event_id = ANY($1::char(26)[])
`

type MarkEventsSyncedBatchParams struct {
	Column1 []string `json:"column_1"`
}

func (q *Queries) MarkEventsSyncedBatch(ctx context.Context, arg MarkEventsSyncedBatchParams) error {
	_, err := q.db.ExecContext(ctx, markEventsSyncedBatch, pq.Array(arg.Column1))
	return err
}

const recordChangeEvent = `-- name: RecordChangeEvent :one
INSERT INTO change_events (
    event_id,
    hlc_timestamp,
    node_id,
    table_name,
    record_id,
    operation,
    action,
    user_id,
    old_values,
    new_values,
    metadata,
    request_id,
    ip
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING event_id, hlc_timestamp, wall_timestamp, node_id, table_name, record_id, operation, action, user_id, old_values, new_values, metadata, request_id, ip, synced_at, consumed_at
`

type RecordChangeEventParams struct {
	EventID      types.EventID        `json:"event_id"`
	HlcTimestamp types.HLC            `json:"hlc_timestamp"`
	NodeID       types.NodeID         `json:"node_id"`
	TableName    string               `json:"table_name"`
	RecordID     string               `json:"record_id"`
	Operation    types.Operation      `json:"operation"`
	Action       types.Action         `json:"action"`
	UserID       types.NullableUserID `json:"user_id"`
	OldValues    types.JSONData       `json:"old_values"`
	NewValues    types.JSONData       `json:"new_values"`
	Metadata     types.JSONData       `json:"metadata"`
	RequestId    types.NullableString `json:"request_id"`
	Ip           types.NullableString `json:"ip"`
}

func (q *Queries) RecordChangeEvent(ctx context.Context, arg RecordChangeEventParams) (ChangeEvent, error) {
	row := q.db.QueryRowContext(ctx, recordChangeEvent,
		arg.EventID,
		arg.HlcTimestamp,
		arg.NodeID,
		arg.TableName,
		arg.RecordID,
		arg.Operation,
		arg.Action,
		arg.UserID,
		arg.OldValues,
		arg.NewValues,
		arg.Metadata,
		arg.RequestId,
		arg.Ip,
	)
	var i ChangeEvent
	err := row.Scan(
		&i.EventID,
		&i.HlcTimestamp,
		&i.WallTimestamp,
		&i.NodeID,
		&i.TableName,
		&i.RecordID,
		&i.Operation,
		&i.Action,
		&i.UserID,
		&i.OldValues,
		&i.NewValues,
		&i.Metadata,
		&i.RequestId,
		&i.Ip,
		&i.SyncedAt,
		&i.ConsumedAt,
	)
	return i, err
}

const updateAdminContentData = `-- name: UpdateAdminContentData :exec
UPDATE admin_content_data
SET parent_id = $1,
    first_child_id = $2,
    next_sibling_id = $3,
    prev_sibling_id = $4,
    admin_route_id = $5,
    admin_datatype_id = $6,
    author_id = $7,
    status = $8,
    date_created = $9,
    date_modified = $10
WHERE admin_content_data_id = $11
`

type UpdateAdminContentDataParams struct {
	ParentID           types.NullableContentID       `json:"parent_id"`
	FirstChildID       sql.NullString                `json:"first_child_id"`
	NextSiblingID      sql.NullString                `json:"next_sibling_id"`
	PrevSiblingID      sql.NullString                `json:"prev_sibling_id"`
	AdminRouteID       string                        `json:"admin_route_id"`
	AdminDatatypeID    types.NullableAdminDatatypeID `json:"admin_datatype_id"`
	AuthorID           types.NullableUserID          `json:"author_id"`
	Status             types.ContentStatus           `json:"status"`
	DateCreated        types.Timestamp               `json:"date_created"`
	DateModified       types.Timestamp               `json:"date_modified"`
	AdminContentDataID types.AdminContentID          `json:"admin_content_data_id"`
}

func (q *Queries) UpdateAdminContentData(ctx context.Context, arg UpdateAdminContentDataParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminContentData,
		arg.ParentID,
		arg.FirstChildID,
		arg.NextSiblingID,
		arg.PrevSiblingID,
		arg.AdminRouteID,
		arg.AdminDatatypeID,
		arg.AuthorID,
		arg.Status,
		arg.DateCreated,
		arg.DateModified,
		arg.AdminContentDataID,
	)
	return err
}

const updateAdminContentField = `-- name: UpdateAdminContentField :exec
UPDATE admin_content_fields
SET admin_route_id=$1,
    admin_content_data_id=$2,
    admin_field_id=$3,
    admin_field_value=$4,
    author_id=$5,
    date_created=$6,
    date_modified=$7
WHERE admin_content_field_id = $8
`

type UpdateAdminContentFieldParams struct {
	AdminRouteID        sql.NullString             `json:"admin_route_id"`
	AdminContentDataID  string                     `json:"admin_content_data_id"`
	AdminFieldID        types.NullableAdminFieldID `json:"admin_field_id"`
	AdminFieldValue     string                     `json:"admin_field_value"`
	AuthorID            types.NullableUserID       `json:"author_id"`
	DateCreated         types.Timestamp            `json:"date_created"`
	DateModified        types.Timestamp            `json:"date_modified"`
	AdminContentFieldID types.AdminContentFieldID  `json:"admin_content_field_id"`
}

func (q *Queries) UpdateAdminContentField(ctx context.Context, arg UpdateAdminContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminContentField,
		arg.AdminRouteID,
		arg.AdminContentDataID,
		arg.AdminFieldID,
		arg.AdminFieldValue,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.AdminContentFieldID,
	)
	return err
}

const updateAdminContentRelationSortOrder = `-- name: UpdateAdminContentRelationSortOrder :exec
UPDATE admin_content_relations
SET sort_order = $1
WHERE admin_content_relation_id = $2
`

type UpdateAdminContentRelationSortOrderParams struct {
	SortOrder              int32                        `json:"sort_order"`
	AdminContentRelationID types.AdminContentRelationID `json:"admin_content_relation_id"`
}

func (q *Queries) UpdateAdminContentRelationSortOrder(ctx context.Context, arg UpdateAdminContentRelationSortOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminContentRelationSortOrder, arg.SortOrder, arg.AdminContentRelationID)
	return err
}

const updateAdminDatatype = `-- name: UpdateAdminDatatype :exec
UPDATE admin_datatypes
SET parent_id = $1,
    label = $2,
    type = $3,
    author_id = $4,
    date_created = $5,
    date_modified = $6
WHERE admin_datatype_id = $7
RETURNING admin_datatype_id, parent_id, label, type, author_id, date_created, date_modified
`

type UpdateAdminDatatypeParams struct {
	ParentID        types.NullableContentID `json:"parent_id"`
	Label           string                  `json:"label"`
	Type            string                  `json:"type"`
	AuthorID        types.NullableUserID    `json:"author_id"`
	DateCreated     types.Timestamp         `json:"date_created"`
	DateModified    types.Timestamp         `json:"date_modified"`
	AdminDatatypeID types.AdminDatatypeID   `json:"admin_datatype_id"`
}

func (q *Queries) UpdateAdminDatatype(ctx context.Context, arg UpdateAdminDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.AdminDatatypeID,
	)
	return err
}

const updateAdminDatatypeField = `-- name: UpdateAdminDatatypeField :exec
UPDATE admin_datatypes_fields SET
    admin_datatype_id = $1,
    admin_field_id = $2
WHERE id = $3
`

type UpdateAdminDatatypeFieldParams struct {
	AdminDatatypeID types.AdminDatatypeID `json:"admin_datatype_id"`
	AdminFieldID    types.AdminFieldID    `json:"admin_field_id"`
	ID              string                `json:"id"`
}

func (q *Queries) UpdateAdminDatatypeField(ctx context.Context, arg UpdateAdminDatatypeFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminDatatypeField, arg.AdminDatatypeID, arg.AdminFieldID, arg.ID)
	return err
}

const updateAdminField = `-- name: UpdateAdminField :exec
UPDATE admin_fields
SET parent_id    = $1,
    label        = $2,
    data         = $3,
    validation   = $4,
    ui_config    = $5,
    type         = $6,
    author_id    = $7,
    date_created = $8,
    date_modified= $9
WHERE admin_field_id = $10
`

type UpdateAdminFieldParams struct {
	ParentID     types.NullableAdminDatatypeID `json:"parent_id"`
	Label        string                        `json:"label"`
	Data         string                        `json:"data"`
	Validation   string                        `json:"validation"`
	UiConfig     string                        `json:"ui_config"`
	Type         types.FieldType               `json:"type"`
	AuthorID     types.NullableUserID          `json:"author_id"`
	DateCreated  types.Timestamp               `json:"date_created"`
	DateModified types.Timestamp               `json:"date_modified"`
	AdminFieldID types.AdminFieldID            `json:"admin_field_id"`
}

func (q *Queries) UpdateAdminField(ctx context.Context, arg UpdateAdminFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Validation,
		arg.UiConfig,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.AdminFieldID,
	)
	return err
}

const updateAdminRoute = `-- name: UpdateAdminRoute :exec
UPDATE admin_routes
SET slug = $1,
    title = $2,
    status = $3, 
    author_id = $4,
    date_created = $5,
    date_modified = $6
    WHERE slug = $7
    RETURNING admin_route_id, slug, title, status, author_id, date_created, date_modified
`

type UpdateAdminRouteParams struct {
	Slug         types.Slug           `json:"slug"`
	Title        string               `json:"title"`
	Status       int32                `json:"status"`
	AuthorID     types.NullableUserID `json:"author_id"`
	DateCreated  types.Timestamp      `json:"date_created"`
	DateModified types.Timestamp      `json:"date_modified"`
	Slug_2       types.Slug           `json:"slug_2"`
}

func (q *Queries) UpdateAdminRoute(ctx context.Context, arg UpdateAdminRouteParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.Slug_2,
	)
	return err
}

const updateBackupHLC = `-- name: UpdateBackupHLC :exec
UPDATE backups
SET hlc_timestamp = $1, replication_lsn = $2
WHERE backup_id = $3
`

type UpdateBackupHLCParams struct {
	HlcTimestamp   types.HLC            `json:"hlc_timestamp"`
	ReplicationLsn types.NullableString `json:"replication_lsn"`
	BackupID       types.BackupID       `json:"backup_id"`
}

func (q *Queries) UpdateBackupHLC(ctx context.Context, arg UpdateBackupHLCParams) error {
	_, err := q.db.ExecContext(ctx, updateBackupHLC, arg.HlcTimestamp, arg.ReplicationLsn, arg.BackupID)
	return err
}

const updateBackupSetStatus = `-- name: UpdateBackupSetStatus :exec
UPDATE backup_sets
SET status = $1, completed_count = $2, error_message = $3
WHERE backup_set_id = $4
`

type UpdateBackupSetStatusParams struct {
	Status         types.BackupSetStatus `json:"status"`
	CompletedCount types.NullableInt64   `json:"completed_count"`
	ErrorMessage   types.NullableString  `json:"error_message"`
	BackupSetID    types.BackupSetID     `json:"backup_set_id"`
}

func (q *Queries) UpdateBackupSetStatus(ctx context.Context, arg UpdateBackupSetStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateBackupSetStatus,
		arg.Status,
		arg.CompletedCount,
		arg.ErrorMessage,
		arg.BackupSetID,
	)
	return err
}

const updateBackupStatus = `-- name: UpdateBackupStatus :exec
UPDATE backups
SET status = $1,
    completed_at = $2,
    duration_ms = $3,
    record_count = $4,
    size_bytes = $5,
    checksum = $6,
    error_message = $7
WHERE backup_id = $8
`

type UpdateBackupStatusParams struct {
	Status       types.BackupStatus   `json:"status"`
	CompletedAt  types.Timestamp      `json:"completed_at"`
	DurationMs   types.NullableInt64  `json:"duration_ms"`
	RecordCount  types.NullableInt64  `json:"record_count"`
	SizeBytes    types.NullableInt64  `json:"size_bytes"`
	Checksum     types.NullableString `json:"checksum"`
	ErrorMessage types.NullableString `json:"error_message"`
	BackupID     types.BackupID       `json:"backup_id"`
}

func (q *Queries) UpdateBackupStatus(ctx context.Context, arg UpdateBackupStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateBackupStatus,
		arg.Status,
		arg.CompletedAt,
		arg.DurationMs,
		arg.RecordCount,
		arg.SizeBytes,
		arg.Checksum,
		arg.ErrorMessage,
		arg.BackupID,
	)
	return err
}

const updateContentData = `-- name: UpdateContentData :exec
UPDATE content_data
SET route_id = $1,
    parent_id = $2,
    first_child_id = $3,
    next_sibling_id = $4,
    prev_sibling_id = $5,
    datatype_id = $6,
    author_id = $7,
    status = $8,
    date_created = $9,
    date_modified = $10
WHERE content_data_id = $11
`

type UpdateContentDataParams struct {
	RouteID       types.NullableRouteID    `json:"route_id"`
	ParentID      types.NullableContentID  `json:"parent_id"`
	FirstChildID  sql.NullString           `json:"first_child_id"`
	NextSiblingID sql.NullString           `json:"next_sibling_id"`
	PrevSiblingID sql.NullString           `json:"prev_sibling_id"`
	DatatypeID    types.NullableDatatypeID `json:"datatype_id"`
	AuthorID      types.NullableUserID     `json:"author_id"`
	Status        types.ContentStatus      `json:"status"`
	DateCreated   types.Timestamp          `json:"date_created"`
	DateModified  types.Timestamp          `json:"date_modified"`
	ContentDataID types.ContentID          `json:"content_data_id"`
}

func (q *Queries) UpdateContentData(ctx context.Context, arg UpdateContentDataParams) error {
	_, err := q.db.ExecContext(ctx, updateContentData,
		arg.RouteID,
		arg.ParentID,
		arg.FirstChildID,
		arg.NextSiblingID,
		arg.PrevSiblingID,
		arg.DatatypeID,
		arg.AuthorID,
		arg.Status,
		arg.DateCreated,
		arg.DateModified,
		arg.ContentDataID,
	)
	return err
}

const updateContentField = `-- name: UpdateContentField :exec
UPDATE content_fields
SET  content_field_id = $1,
    route_id = $2,
    content_data_id = $3,
    field_id = $4,
    field_value = $5,
    author_id = $6,
    date_created = $7,
    date_modified = $8
WHERE content_field_id = $9
`

type UpdateContentFieldParams struct {
	ContentFieldID   types.ContentFieldID    `json:"content_field_id"`
	RouteID          types.NullableRouteID   `json:"route_id"`
	ContentDataID    types.NullableContentID `json:"content_data_id"`
	FieldID          types.NullableFieldID   `json:"field_id"`
	FieldValue       string                  `json:"field_value"`
	AuthorID         types.NullableUserID    `json:"author_id"`
	DateCreated      types.Timestamp         `json:"date_created"`
	DateModified     types.Timestamp         `json:"date_modified"`
	ContentFieldID_2 types.ContentFieldID    `json:"content_field_id_2"`
}

func (q *Queries) UpdateContentField(ctx context.Context, arg UpdateContentFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateContentField,
		arg.ContentFieldID,
		arg.RouteID,
		arg.ContentDataID,
		arg.FieldID,
		arg.FieldValue,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.ContentFieldID_2,
	)
	return err
}

const updateContentRelationSortOrder = `-- name: UpdateContentRelationSortOrder :exec
UPDATE content_relations
SET sort_order = $1
WHERE content_relation_id = $2
`

type UpdateContentRelationSortOrderParams struct {
	SortOrder         int32                   `json:"sort_order"`
	ContentRelationID types.ContentRelationID `json:"content_relation_id"`
}

func (q *Queries) UpdateContentRelationSortOrder(ctx context.Context, arg UpdateContentRelationSortOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateContentRelationSortOrder, arg.SortOrder, arg.ContentRelationID)
	return err
}

const updateDatatype = `-- name: UpdateDatatype :exec
UPDATE datatypes
SET parent_id = $1,
    label = $2,
    type = $3,
    author_id = $4,
    date_created = $5,
    date_modified = $6
    WHERE datatype_id = $7
    RETURNING datatype_id, parent_id, label, type, author_id, date_created, date_modified
`

type UpdateDatatypeParams struct {
	ParentID     types.NullableContentID `json:"parent_id"`
	Label        string                  `json:"label"`
	Type         string                  `json:"type"`
	AuthorID     types.NullableUserID    `json:"author_id"`
	DateCreated  types.Timestamp         `json:"date_created"`
	DateModified types.Timestamp         `json:"date_modified"`
	DatatypeID   types.DatatypeID        `json:"datatype_id"`
}

func (q *Queries) UpdateDatatype(ctx context.Context, arg UpdateDatatypeParams) error {
	_, err := q.db.ExecContext(ctx, updateDatatype,
		arg.ParentID,
		arg.Label,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.DatatypeID,
	)
	return err
}

const updateDatatypeField = `-- name: UpdateDatatypeField :exec
UPDATE datatypes_fields SET
    datatype_id = $1,
    field_id = $2,
    sort_order = $3
WHERE id = $4
`

type UpdateDatatypeFieldParams struct {
	DatatypeID types.DatatypeID `json:"datatype_id"`
	FieldID    types.FieldID    `json:"field_id"`
	SortOrder  int32            `json:"sort_order"`
	ID         string           `json:"id"`
}

func (q *Queries) UpdateDatatypeField(ctx context.Context, arg UpdateDatatypeFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateDatatypeField,
		arg.DatatypeID,
		arg.FieldID,
		arg.SortOrder,
		arg.ID,
	)
	return err
}

const updateDatatypeFieldSortOrder = `-- name: UpdateDatatypeFieldSortOrder :exec
UPDATE datatypes_fields
SET sort_order = $1
WHERE id = $2
`

type UpdateDatatypeFieldSortOrderParams struct {
	SortOrder int32  `json:"sort_order"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateDatatypeFieldSortOrder(ctx context.Context, arg UpdateDatatypeFieldSortOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateDatatypeFieldSortOrder, arg.SortOrder, arg.ID)
	return err
}

const updateField = `-- name: UpdateField :exec
UPDATE fields
SET parent_id = $1,
    label = $2,
    data = $3,
    validation = $4,
    ui_config = $5,
    type = $6,
    author_id = $7,
    date_created = $8,
    date_modified = $9
    WHERE field_id = $10
    RETURNING field_id, parent_id, label, data, validation, ui_config, type, author_id, date_created, date_modified
`

type UpdateFieldParams struct {
	ParentID     types.NullableDatatypeID `json:"parent_id"`
	Label        string                   `json:"label"`
	Data         string                   `json:"data"`
	Validation   string                   `json:"validation"`
	UiConfig     string                   `json:"ui_config"`
	Type         types.FieldType          `json:"type"`
	AuthorID     types.NullableUserID     `json:"author_id"`
	DateCreated  types.Timestamp          `json:"date_created"`
	DateModified types.Timestamp          `json:"date_modified"`
	FieldID      types.FieldID            `json:"field_id"`
}

func (q *Queries) UpdateField(ctx context.Context, arg UpdateFieldParams) error {
	_, err := q.db.ExecContext(ctx, updateField,
		arg.ParentID,
		arg.Label,
		arg.Data,
		arg.Validation,
		arg.UiConfig,
		arg.Type,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.FieldID,
	)
	return err
}

const updateMedia = `-- name: UpdateMedia :exec
UPDATE media
SET name = $1,
    display_name = $2,
    alt = $3,
    caption = $4,
    description = $5,
    class = $6,
    url = $7,
    mimetype = $8,
    dimensions = $9,
    srcset = $10,
    author_id = $11,
    date_created = $12,
    date_modified = $13
WHERE media_id = $14
`

type UpdateMediaParams struct {
	Name         sql.NullString       `json:"name"`
	DisplayName  sql.NullString       `json:"display_name"`
	Alt          sql.NullString       `json:"alt"`
	Caption      sql.NullString       `json:"caption"`
	Description  sql.NullString       `json:"description"`
	Class        sql.NullString       `json:"class"`
	URL          types.URL            `json:"url"`
	Mimetype     sql.NullString       `json:"mimetype"`
	Dimensions   sql.NullString       `json:"dimensions"`
	Srcset       sql.NullString       `json:"srcset"`
	AuthorID     types.NullableUserID `json:"author_id"`
	DateCreated  types.Timestamp      `json:"date_created"`
	DateModified types.Timestamp      `json:"date_modified"`
	MediaID      types.MediaID        `json:"media_id"`
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) error {
	_, err := q.db.ExecContext(ctx, updateMedia,
		arg.Name,
		arg.DisplayName,
		arg.Alt,
		arg.Caption,
		arg.Description,
		arg.Class,
		arg.URL,
		arg.Mimetype,
		arg.Dimensions,
		arg.Srcset,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.MediaID,
	)
	return err
}

const updateMediaDimension = `-- name: UpdateMediaDimension :exec
UPDATE media_dimensions
SET label = $1, 
    width = $2, 
    height = $3, 
    aspect_ratio = $4
WHERE md_id = $5
`

type UpdateMediaDimensionParams struct {
	Label       sql.NullString `json:"label"`
	Width       sql.NullInt32  `json:"width"`
	Height      sql.NullInt32  `json:"height"`
	AspectRatio sql.NullString `json:"aspect_ratio"`
	MdID        string         `json:"md_id"`
}

func (q *Queries) UpdateMediaDimension(ctx context.Context, arg UpdateMediaDimensionParams) error {
	_, err := q.db.ExecContext(ctx, updateMediaDimension,
		arg.Label,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
		arg.MdID,
	)
	return err
}

const updatePermission = `-- name: UpdatePermission :exec
UPDATE permissions
SET table_id=$1,
    mode=$2,
    label=$3
WHERE permission_id = $4
`

type UpdatePermissionParams struct {
	TableID      string             `json:"table_id"`
	Mode         int32              `json:"mode"`
	Label        string             `json:"label"`
	PermissionID types.PermissionID `json:"permission_id"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) error {
	_, err := q.db.ExecContext(ctx, updatePermission,
		arg.TableID,
		arg.Mode,
		arg.Label,
		arg.PermissionID,
	)
	return err
}

const updateRole = `-- name: UpdateRole :exec
UPDATE roles
SET label = $1,
    permissions = $2
WHERE role_id = $3
`

type UpdateRoleParams struct {
	Label       string                `json:"label"`
	Permissions pqtype.NullRawMessage `json:"permissions"`
	RoleID      types.RoleID          `json:"role_id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateRole, arg.Label, arg.Permissions, arg.RoleID)
	return err
}

const updateRoute = `-- name: UpdateRoute :exec
UPDATE routes
SET slug = $1,
    title = $2,
    status = $3,
    author_id = $4,
    date_created = $5,
    date_modified = $6
WHERE slug = $7
RETURNING route_id, slug, title, status, author_id, date_created, date_modified
`

type UpdateRouteParams struct {
	Slug         types.Slug           `json:"slug"`
	Title        string               `json:"title"`
	Status       int32                `json:"status"`
	AuthorID     types.NullableUserID `json:"author_id"`
	DateCreated  types.Timestamp      `json:"date_created"`
	DateModified types.Timestamp      `json:"date_modified"`
	Slug_2       types.Slug           `json:"slug_2"`
}

func (q *Queries) UpdateRoute(ctx context.Context, arg UpdateRouteParams) error {
	_, err := q.db.ExecContext(ctx, updateRoute,
		arg.Slug,
		arg.Title,
		arg.Status,
		arg.AuthorID,
		arg.DateCreated,
		arg.DateModified,
		arg.Slug_2,
	)
	return err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE sessions
    SET user_id=$1,
    created_at=$2,
    expires_at=$3,
    last_access=$4,
    ip_address=$5,
    user_agent=$6,
    session_data=$7
WHERE session_id = $8
`

type UpdateSessionParams struct {
	UserID      types.NullableUserID `json:"user_id"`
	CreatedAt   types.Timestamp      `json:"created_at"`
	ExpiresAt   types.Timestamp      `json:"expires_at"`
	LastAccess  sql.NullTime         `json:"last_access"`
	IpAddress   sql.NullString       `json:"ip_address"`
	UserAgent   sql.NullString       `json:"user_agent"`
	SessionData sql.NullString       `json:"session_data"`
	SessionID   types.SessionID      `json:"session_id"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateSession,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastAccess,
		arg.IpAddress,
		arg.UserAgent,
		arg.SessionData,
		arg.SessionID,
	)
	return err
}

const updateTable = `-- name: UpdateTable :exec
UPDATE tables
SET label = $1
WHERE id = $2
`

type UpdateTableParams struct {
	Label string `json:"label"`
	ID    string `json:"id"`
}

func (q *Queries) UpdateTable(ctx context.Context, arg UpdateTableParams) error {
	_, err := q.db.ExecContext(ctx, updateTable, arg.Label, arg.ID)
	return err
}

const updateToken = `-- name: UpdateToken :exec
UPDATE tokens
SET token = $1,
    issued_at = $2,
    expires_at = $3,
    revoked = $4
WHERE id = $5
`

type UpdateTokenParams struct {
	Tokens    string          `json:"token"`
	IssuedAt  time.Time       `json:"issued_at"`
	ExpiresAt types.Timestamp `json:"expires_at"`
	Revoked   bool            `json:"revoked"`
	ID        string          `json:"id"`
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateToken,
		arg.Tokens,
		arg.IssuedAt,
		arg.ExpiresAt,
		arg.Revoked,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET username = $1,
    name = $2,
    email = $3,
    hash = $4,
    role = $5,
    date_created = $6,
    date_modified = $7
WHERE user_id = $8
`

type UpdateUserParams struct {
	Username     string          `json:"username"`
	Name         string          `json:"name"`
	Email        types.Email     `json:"email"`
	Hash         string          `json:"hash"`
	Roles        string          `json:"role"`
	DateCreated  types.Timestamp `json:"date_created"`
	DateModified types.Timestamp `json:"date_modified"`
	UserID       types.UserID    `json:"user_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.Hash,
		arg.Roles,
		arg.DateCreated,
		arg.DateModified,
		arg.UserID,
	)
	return err
}

const updateUserOauth = `-- name: UpdateUserOauth :exec
UPDATE user_oauth
SET access_token = $1,
    refresh_token = $2,
    token_expires_at = $3
WHERE user_oauth_id = $4
`

type UpdateUserOauthParams struct {
	AccessToken    string            `json:"access_token"`
	RefreshToken   string            `json:"refresh_token"`
	TokenExpiresAt time.Time         `json:"token_expires_at"`
	UserOAuthID    types.UserOauthID `json:"user_oauth_id"`
}

func (q *Queries) UpdateUserOauth(ctx context.Context, arg UpdateUserOauthParams) error {
	_, err := q.db.ExecContext(ctx, updateUserOauth,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenExpiresAt,
		arg.UserOAuthID,
	)
	return err
}

const updateUserSshKeyLabel = `-- name: UpdateUserSshKeyLabel :exec
UPDATE user_ssh_keys
SET label = $1
WHERE ssh_key_id = $2
`

type UpdateUserSshKeyLabelParams struct {
	Label    sql.NullString `json:"label"`
	SSHKeyID string         `json:"ssh_key_id"`
}

func (q *Queries) UpdateUserSshKeyLabel(ctx context.Context, arg UpdateUserSshKeyLabelParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSshKeyLabel, arg.Label, arg.SSHKeyID)
	return err
}

const updateUserSshKeyLastUsed = `-- name: UpdateUserSshKeyLastUsed :exec
UPDATE user_ssh_keys
SET last_used = $1
WHERE ssh_key_id = $2
`

type UpdateUserSshKeyLastUsedParams struct {
	LastUsed sql.NullTime `json:"last_used"`
	SSHKeyID string       `json:"ssh_key_id"`
}

func (q *Queries) UpdateUserSshKeyLastUsed(ctx context.Context, arg UpdateUserSshKeyLastUsedParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSshKeyLastUsed, arg.LastUsed, arg.SSHKeyID)
	return err
}
